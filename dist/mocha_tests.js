(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

exports.newDocument = function () {
	return document.implementation.createDocument("", "", null);
};

exports.newNode = function (xmlDoc, name, text) {
	var doc =  xmlDoc.ownerDocument || xmlDoc;

	var element = doc.createElement(name);
	if ((text !== undefined) && (text !== null)) {
		var textNode = doc.createTextNode(text);
		element.appendChild(textNode);
	}
	if (xmlDoc.ownerDocument) {
		xmlDoc.appendChild(element);
	} else {
		xmlDoc.appendChild(element);
	}
	return element;
};

exports.nodeAttr = function (node, attr) {
	Object.keys(attr).forEach(function(key) {
		var value = attr[key];
		node.setAttribute(key, value);
	});
};

exports.serializeToString = function (xmlDoc) {
	var serializer = new XMLSerializer();
	var result = serializer.serializeToString(xmlDoc);
	return result;
};

},{}],2:[function(require,module,exports){
"use strict";

/*
This script converts CCDA data in JSON format (originally generated from a Continuity of Care Document (CCD) in 
standard XML/CCDA format) back to XML/CCDA format.
*/

var bbu = require("blue-button-util");

var engine = require('./lib/engine');
var documentLevel = require('./lib/documentLevel');

var bbuo = bbu.object;

var createContext = (function () {
    var base = {
        nextReference: function (referenceKey) {
            var index = this.references[referenceKey] || 0;
            ++index;
            this.references[referenceKey] = index;
            return "#" + referenceKey + index;
        },
        sameReference: function (referenceKey) {
            var index = this.references[referenceKey] || 0;
            return "#" + referenceKey + index;
        }
    };

    return function (options) {
        var result = Object.create(base);
        result.references = {};
        if (options.meta && options.addUniqueIds) {
            result.rootId = bbuo.deepValue(options.meta, 'identifiers.0.identifier');
        } else {
            result.rootId = null;
        }

        return result;
    };
})();

var generate = exports.generate = function (template, input, options) {
    var context = createContext(options);
    return engine.create(documentLevel.ccd, input, context);
};

exports.generateCCD = function (input, options) {
    options = options || {};
    options.meta = input.meta;
    return generate(documentLevel.ccd, input, options);
};

},{"./lib/documentLevel":5,"./lib/engine":6,"blue-button-util":35}],3:[function(require,module,exports){
"use strict";

exports.keyExists = function (key) {
    return function (input) {
        return input.hasOwnProperty(key);
    };
};

exports.eitherKeyExists = function (key0, key1, key2, key3) {
    return function (input) {
        return input.hasOwnProperty(key0) || input.hasOwnProperty(key1) || input.hasOwnProperty(key2) || input.hasOwnProperty(key3);
    };
};

exports.codeOrDisplayname = function (input) {
    return input.code || input.name;
};

exports.propertyEquals = function (property, value) {
    return function (input) {
        return input && (input[property] === value);
    };
};

},{}],4:[function(require,module,exports){
"use strict";

exports.key = function (overrideKeyValue) {
    return function (template) {
        template.key = overrideKeyValue;
    };
};

exports.required = function (template) {
    template.required = true;
};

exports.dataKey = function (overrideKeyValue) {
    return function (template) {
        template.dataKey = overrideKeyValue;
    };
};

},{}],5:[function(require,module,exports){
"use strict";

var headerLevel = require('./headerLevel');
var fieldLevel = require('./fieldLevel');
var leafLevel = require('./leafLevel');
var sectionLevel = require('./sectionLevel');
var contentModifier = require("./contentModifier");
var condition = require("./condition");

var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

exports.ccd = {
    key: "ClinicalDocument",
    attributes: {
        "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "xmlns": "urn:hl7-org:v3",
        "xmlns:cda": "urn:hl7-org:v3",
        "xmlns:sdtc": "urn:hl7-org:sdtc"
    },
    content: [{
            key: "realmCode",
            attributes: {
                code: "US"
            }
        }, {
            key: "typeId",
            attributes: {
                root: "2.16.840.1.113883.1.3",
                extension: "POCD_HD000040"
            }
        },
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.1.1"),
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.1.2"), [fieldLevel.id, dataKey("meta.identifiers")], {
            key: "code",
            attributes: {
                codeSystem: "2.16.840.1.113883.6.1",
                codeSystemName: "LOINC",
                code: "34133-9",
                displayName: "Summarization of Episode Note"
            }
        }, {
            key: "title",
            text: "Community Health and Hospitals: Health Summary"
        },
        [fieldLevel.effectiveTime, required], {
            key: "confidentialityCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.5.25"),
            dataKey: "meta.confidentiality"
        }, {
            key: "languageCode",
            attributes: {
                code: "en-US"
            }
        }, {
            key: "setId",
            attributes: {
                root: leafLevel.inputProperty("identifier"),
                extension: leafLevel.inputProperty("extension")
            },
            dataKey: 'meta.set_id',
            existsWhen: condition.keyExists('identifier')
        }, {
            key: "versionNumber",
            attributes: {
                value: "1"
            }
        },
        headerLevel.recordTarget,
        headerLevel.providers, {
            key: "component",
            content: {
                key: "structuredBody",
                content: [
                    [sectionLevel.allergiesSectionEntriesRequired, required],
                    [sectionLevel.medicationsSectionEntriesRequired, required],
                    [sectionLevel.problemsSectionEntriesRequired, required],
                    [sectionLevel.proceduresSectionEntriesRequired, required],
                    [sectionLevel.resultsSectionEntriesRequired, required],
                    sectionLevel.encountersSectionEntriesOptional,
                    sectionLevel.immunizationsSectionEntriesOptional,
                    sectionLevel.payersSection,
                    sectionLevel.planOfCareSection,
                    sectionLevel.socialHistorySection,
                    sectionLevel.vitalSignsSectionEntriesOptional
                ],
                notImplemented: [
                    "advanceDirectivesSectionEntriesOptional",
                    "familyHistorySection",
                    "functionalStatusSection",
                    "medicalEquipmentSection",
                ]
            },
            dataKey: 'data'
        }
    ]
};

},{"./condition":3,"./contentModifier":4,"./fieldLevel":20,"./headerLevel":21,"./leafLevel":22,"./sectionLevel":23}],6:[function(require,module,exports){
"use strict";

var xmlutil = require('./xmlutil');

var expandText = function (input, template) {
    var text = template.text;
    if (text) {
        if (typeof text === 'function') {
            text = text(input);
        }
        if ((text !== null) && (text !== undefined)) {
            return text;
        }
    }
    return null;
};

var expandAttributes = function expandAttributes(input, context, attrObj, attrs) {
    if (Array.isArray(attrObj)) {
        attrObj.forEach(function (attrObjElem) {
            expandAttributes(input, context, attrObjElem, attrs);
        });
    } else if (typeof attrObj === 'function') {
        expandAttributes(input, context, attrObj(input, context), attrs);
    } else {
        Object.keys(attrObj).forEach(function (attrKey) {
            var attrVal = attrObj[attrKey];
            if (typeof attrVal === 'function') {
                attrVal = attrVal(input, context);
            }
            if ((attrVal !== null) && (attrVal !== undefined)) {
                attrs[attrKey] = attrVal;
            }
        });
    }
};

var fillAttributes = function (node, input, context, template) {
    var attrObj = template.attributes;
    if (attrObj) {
        var inputAttrKey = template.attributeKey;
        if (inputAttrKey) {
            input = input[inputAttrKey];
        }
        if (input) {
            var attrs = {};
            expandAttributes(input, context, attrObj, attrs);
            xmlutil.nodeAttr(node, attrs);
        }
    }
};

var update;

var fillContent = function (node, input, context, template) {
    var content = template.content;
    if (content) {
        if (!Array.isArray(content)) {
            content = [content];
        }
        content.forEach(function (element) {
            if (Array.isArray(element)) {
                var actualElement = Object.create(element[0]);
                for (var i = 1; i < element.length; ++i) {
                    element[i](actualElement);
                }
                update(node, input, context, actualElement);
            } else {
                update(node, input, context, element);
            }
        });
    }
};

var updateUsingTemplate = function updateUsingTemplate(xmlDoc, input, context, template) {
    var condition = template.existsWhen;
    if ((!condition) || condition(input, context)) {
        var name = template.key;
        var text = expandText(input, template);
        if (((text !== null) && (text !== undefined)) || template.content || template.attributes) {
            var node = xmlutil.newNode(xmlDoc, name, text);

            fillAttributes(node, input, context, template);
            fillContent(node, input, context, template);
            return true;
        }
    }
    return false;
};

var transformInput = function (input, template) {
    var inputKey = template.dataKey;
    if (inputKey) {
        var pieces = inputKey.split('.');
        pieces.forEach(function (piece) {
            if (Array.isArray(input) && (piece !== "0")) {
                var nextInputs = [];
                input.forEach(function (inputElement) {
                    var nextInput = inputElement[piece];
                    if (nextInput) {
                        if (Array.isArray(nextInput)) {
                            nextInput.forEach(function (nextInputElement) {
                                if (nextInputElement) {
                                    nextInputs.push(nextInputElement);
                                }
                            });
                        } else {
                            nextInputs.push(nextInput);
                        }
                    }
                });
                if (nextInputs.length === 0) {
                    input = null;
                } else {
                    input = nextInputs;
                }
            } else {
                input = input && input[piece];
            }
        });
    }
    if (input) {
        var transform = template.dataTransform;
        if (transform) {
            input = transform(input);
        }
    }
    return input;
};

update = exports.update = function (xmlDoc, input, context, template) {
    var filled = false;
    if (input) {
        input = transformInput(input, template);
        if (input) {
            if (Array.isArray(input)) {
                input.forEach(function (element) {
                    filled = updateUsingTemplate(xmlDoc, element, context, template) || filled;
                });
            } else {
                filled = updateUsingTemplate(xmlDoc, input, context, template);
            }
        }
    }
    if ((!filled) && template.required) {
        var node = xmlutil.newNode(xmlDoc, template.key);
        xmlutil.nodeAttr(node, {
            nullFlavor: 'UNK'
        });
    }
};

exports.create = function (template, input, context) {
    var doc = new xmlutil.newDocument();
    update(doc, input, context, template);
    var result = xmlutil.serializeToString(doc);
    return result;
};

},{"./xmlutil":1}],7:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require('../condition');
var contentModifier = require("../contentModifier");

var sel = require("./sharedEntryLevel");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

var allergyStatusObservation = {
    key: "observation",
    attributes: {
        "classCode": "OBS",
        "moodCode": "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.28"),
        fieldLevel.templateCode("AllergyStatusObservation"),
        fieldLevel.statusCodeCompleted, {
            key: "value",
            attributes: [
                leafLevel.typeCE,
                leafLevel.code
            ],
            existsWhen: condition.codeOrDisplayname,
            required: true
        }
    ],
    dataKey: "status"
};

var allergyIntoleranceObservation = exports.allergyIntoleranceObservation = {
    key: "observation",
    attributes: {
        "classCode": "OBS",
        "moodCode": "EVN",
        "negationInd": leafLevel.boolInputProperty("negation_indicator")
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.7"),
        fieldLevel.id,
        fieldLevel.templateCode("AllergyObservation"),
        fieldLevel.statusCodeCompleted, [fieldLevel.effectiveTime, required], {
            key: "value",
            attributes: [
                leafLevel.typeCD,
                leafLevel.code
            ],
            content: {
                key: "originalText",
                content: {
                    key: "reference",
                    attributes: {
                        "value": leafLevel.nextReference("reaction")
                    }
                }
            },
            dataKey: 'intolerance',
            existsWhen: condition.codeOrDisplayname,
            required: true
        }, {
            key: "participant",
            attributes: {
                "typeCode": "CSM"
            },
            content: [{
                key: "participantRole",
                attributes: {
                    "classCode": "MANU"
                },
                content: [{
                    key: "playingEntity",
                    attributes: {
                        classCode: "MMAT"
                    },
                    content: [{
                        key: "code",
                        attributes: leafLevel.code,
                        content: [{
                            key: "originalText",
                            content: [{
                                key: "reference",
                                attributes: {
                                    "value": leafLevel.sameReference("reaction")
                                }
                            }]
                        }, {
                            key: "translation",
                            attributes: leafLevel.code,
                            dataKey: "translations"
                        }],
                        require: true
                    }]
                }],
                required: true
            }],
            dataKey: 'allergen'
        }, {
            key: "entryRelationship",
            attributes: {
                "typeCode": "SUBJ",
                "inversionInd": "true"
            },
            content: [
                [allergyStatusObservation, required]
            ],
            existsWhen: condition.keyExists("status")
        }, {
            key: "entryRelationship",
            attributes: {
                "typeCode": "MFST",
                "inversionInd": "true"
            },
            content: [
                [sel.reactionObservation, required]
            ],
            dataKey: 'reactions',
            existsWhen: condition.keyExists('reaction')
        }, {
            key: "entryRelationship",
            attributes: {
                "typeCode": "SUBJ",
                "inversionInd": "true"
            },
            content: [
                [sel.severityObservation, required]
            ],
            existsWhen: condition.keyExists('severity')
        }
    ],
    dataKey: "observation",
    warning: [
        "negationInd attribute is not specified in specification"
    ]
};

var allergyProblemAct = exports.allergyProblemAct = {
    key: "act",
    attributes: {
        classCode: "ACT",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.30"),
        fieldLevel.uniqueId,
        fieldLevel.id,
        fieldLevel.templateCode("AllergyProblemAct"),
        fieldLevel.statusCodeActive, [fieldLevel.effectiveTime, required], {
            key: "entryRelationship",
            attributes: {
                typeCode: "SUBJ",
                inversionInd: "true"
            },
            content: [allergyIntoleranceObservation, required],
            existsWhen: condition.keyExists('observation'),
            required: true,
            warning: "inversionInd is not in spec"
        }
    ],
    warning: "statusCode is not constant in spec"
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22,"./sharedEntryLevel":17}],8:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var contentModifier = require("../contentModifier");

var sharedEntryLevel = require("./sharedEntryLevel");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

exports.encounterActivities = {
    key: "encounter",
    attributes: {
        classCode: "ENC",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.49"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            content: [{
                key: "originalText",
                content: [{
                    key: "reference",
                    attributes: {
                        "value": leafLevel.nextReference("Encounter")
                    }
                }]
            }, {
                key: "translation",
                attributes: leafLevel.code,
                dataKey: "translations"
            }],
            dataKey: "encounter"
        },
        [fieldLevel.effectiveTime, required],
        [fieldLevel.performer, dataKey("performers")], {
            key: "participant",
            attributes: {
                typeCode: "LOC"
            },
            content: [
                [sharedEntryLevel.serviceDeliveryLocation, required]
            ],
            dataKey: "locations"
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "RSON"
            },
            content: [
                [sharedEntryLevel.indication, required]
            ],
            dataKey: "findings",
            dataTransform: function (input) {
                input = input.map(function (e) {
                    e.code = {
                        code: "404684003",
                        name: "Finding",
                        code_system: "2.16.840.1.113883.6.96",
                        code_system_name: "SNOMED CT"
                    };
                    return e;
                });
                return input;
            },
            toDo: "move dataTransform to blue-button-meta"
        }
    ],
    notImplemented: [
        "entryRelationship:encounterDiagnosis",
        "dishargeDispositionCode"
    ]
};

},{"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22,"./sharedEntryLevel":17}],9:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");
var contentModifier = require("../contentModifier");

var sharedEntryLevel = require("./sharedEntryLevel");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

var immunizationMedicationInformation = {
    key: "manufacturedProduct",
    attributes: {
        classCode: "MANU"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.54"),
        fieldLevel.id, {
            key: "manufacturedMaterial",
            content: [{
                key: "code",
                attributes: leafLevel.code,
                content: [{
                    key: "originalText",
                    text: leafLevel.inputProperty("unencoded_name"),
                    content: {
                        key: "reference",
                        attributes: {
                            "value": leafLevel.nextReference("imminfo")
                        }
                    }
                }, {
                    key: "translation",
                    attributes: leafLevel.code,
                    dataKey: "translations"
                }]
            }, {
                key: "lotNumberText",
                text: leafLevel.input,
                dataKey: "lot_number"
            }],
            dataKey: "product",
            required: true
        }, {
            key: "manufacturerOrganization",
            content: {
                key: "name",
                text: leafLevel.input,
            },
            dataKey: "manufacturer"
        }
    ],
    dataTransform: function (input) {
        if (input.product) {
            input.product.lot_number = input.lot_number;
        }
        return input;
    }
};

var immunizationRefusalReason = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.53"),
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.5.8"),
            required: true
        },
        fieldLevel.statusCodeCompleted
    ]
};

var immunizationActivityAttributes = function (input) {
    if (input.status) {
        if (input.status === "refused") {
            return {
                moodCode: "EVN",
                negationInd: "true"
            };
        }
        if (input.status === "pending") {
            return {
                moodCode: "INT",
                negationInd: "false"
            };
        }
        if (input.status === "complete") {
            return {
                moodCode: "EVN",
                negationInd: "false"
            };
        }
    }
    return null;
};

exports.immunizationActivity = {
    key: "substanceAdministration",
    attributes: [{
        classCode: "SBADM"
    }, immunizationActivityAttributes],
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.52"),
        fieldLevel.uniqueId,
        fieldLevel.id,
        fieldLevel.text(leafLevel.nextReference("immunization")),
        fieldLevel.statusCodeCompleted, [fieldLevel.effectiveTime, required], {
            key: "repeatNumber",
            attributes: {
                value: leafLevel.inputProperty("sequence_number")
            },
            existsWhen: function (input) {
                return input.sequence_number || (input.sequence_number === "");
            }
        }, {
            key: "routeCode",
            attributes: leafLevel.code,
            dataKey: "administration.route"
        }, {
            key: "approachSiteCode",
            attributes: leafLevel.code,
            dataKey: "administration.body_site"
        }, {
            key: "doseQuantity",
            attributes: {
                value: leafLevel.inputProperty("value"),
                unit: leafLevel.inputProperty("unit")
            },
            dataKey: "administration.dose"
        }, {
            key: "consumable",
            content: [
                [immunizationMedicationInformation, required]
            ],
            dataKey: "product",
            required: true
        },
        fieldLevel.performer, {
            key: "entryRelationship",
            attributes: {
                typeCode: "SUBJ",
                inversionInd: "true"
            },
            content: [sharedEntryLevel.instructions, required],
            dataKey: "instructions"
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "RSON"
            },
            content: [immunizationRefusalReason, required],
            dataKey: "refusal_reason"
        }
    ],
    notImplemented: [
        "code",
        "administrationUnitCode",
        "participant:drugVehicle",
        "entryRelationship:indication",
        "entryRelationship:medicationSupplyOrder",
        "entryRelationship:medicationDispense",
        "entryRelationship:reactionObservation",
        "entryRelationship:preconditionForSubstanceAdministration"
    ]
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22,"./sharedEntryLevel":17}],10:[function(require,module,exports){
"use strict";

var allergyEntryLevel = require("./allergyEntryLevel");
var resultEntryLevel = require("./resultEntryLevel");
var socialHistoryEntryLevel = require('./socialHistoryEntryLevel');
var payerEntryLevel = require('./payerEntryLevel');
var vitalSignEntryLevel = require('./vitalSignEntryLevel');
var planOfCareEntryLevel = require('./planOfCareEntryLevel');
var procedureEntryLevel = require("./procedureEntryLevel");
var problemEntryLevel = require("./problemEntryLevel");
var encounterEntryLevel = require("./encounterEntryLevel");
var immunizationEntryLevel = require("./immunizationEntryLevel");
var medicationEntryLevel = require("./medicationEntryLevel");

exports.allergyProblemAct = allergyEntryLevel.allergyProblemAct;

exports.medicationActivity = medicationEntryLevel.medicationActivity;

exports.immunizationActivity = immunizationEntryLevel.immunizationActivity;

exports.problemConcernAct = problemEntryLevel.problemConcernAct;

exports.encounterActivities = encounterEntryLevel.encounterActivities;

exports.procedureActivityAct = procedureEntryLevel.procedureActivityAct;
exports.procedureActivityProcedure = procedureEntryLevel.procedureActivityProcedure;
exports.procedureActivityObservation = procedureEntryLevel.procedureActivityObservation;

exports.planOfCareActivityAct = planOfCareEntryLevel.planOfCareActivityAct;
exports.planOfCareActivityObservation = planOfCareEntryLevel.planOfCareActivityObservation;
exports.planOfCareActivityProcedure = planOfCareEntryLevel.planOfCareActivityProcedure;
exports.planOfCareActivityEncounter = planOfCareEntryLevel.planOfCareActivityEncounter;
exports.planOfCareActivitySubstanceAdministration = planOfCareEntryLevel.planOfCareActivitySubstanceAdministration;
exports.planOfCareActivitySupply = planOfCareEntryLevel.planOfCareActivitySupply;
exports.planOfCareActivityInstructions = planOfCareEntryLevel.planOfCareActivityInstructions;

exports.coverageActivity = payerEntryLevel.coverageActivity;

exports.vitalSignsOrganizer = vitalSignEntryLevel.vitalSignsOrganizer;

exports.resultOrganizer = resultEntryLevel.resultOrganizer;

exports.socialHistoryObservation = socialHistoryEntryLevel.socialHistoryObservation;
exports.smokingStatusObservation = socialHistoryEntryLevel.smokingStatusObservation;

},{"./allergyEntryLevel":7,"./encounterEntryLevel":8,"./immunizationEntryLevel":9,"./medicationEntryLevel":11,"./payerEntryLevel":12,"./planOfCareEntryLevel":13,"./problemEntryLevel":14,"./procedureEntryLevel":15,"./resultEntryLevel":16,"./socialHistoryEntryLevel":18,"./vitalSignEntryLevel":19}],11:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");
var contentModifier = require("../contentModifier");

var sharedEntryLevel = require("./sharedEntryLevel");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

var medicationInformation = {
    key: "manufacturedProduct",
    attributes: {
        classCode: "MANU"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.23"),
        fieldLevel.id, {
            key: "manufacturedMaterial",
            content: [{
                key: "code",
                attributes: leafLevel.code,
                content: [{
                    key: "originalText",
                    text: leafLevel.inputProperty("unencoded_name"),
                    content: [{
                        key: "reference",
                        attributes: {
                            "value": leafLevel.nextReference("medinfo")
                        }
                    }]
                }, {
                    key: "translation",
                    attributes: leafLevel.code,
                    dataKey: "translations"
                }]
            }],
            dataKey: "product",
            required: true
        }, {
            key: "manufacturerOrganization",
            content: {
                key: "name",
                text: leafLevel.input,
            },
            dataKey: "manufacturer"
        }
    ],
    dataTransform: function (input) {
        if (input.product) {
            input.product.unencoded_name = input.unencoded_name;
        }
        return input;
    }
};

var medicationSupplyOrder = {
    key: "supply",
    attributes: {
        classCode: "SPLY",
        moodCode: "INT"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.17"),
        fieldLevel.id,
        fieldLevel.statusCodeCompleted,
        fieldLevel.effectiveTime, {
            key: "repeatNumber",
            attributes: {
                value: leafLevel.input
            },
            dataKey: "repeatNumber"
        }, {
            key: "quantity",
            attributes: {
                value: leafLevel.input
            },
            dataKey: "quantity"
        }, {
            key: "product",
            content: medicationInformation,
            dataKey: "product"
        },
        fieldLevel.author, {
            key: "entryRelationship",
            attributes: {
                typeCode: "SUBJ",
                inversionInd: "true"
            },
            content: [
                [sharedEntryLevel.instructions, required]
            ],
            dataKey: "instructions"
        }
    ],
    toDo: "statusCode needs to allow values other than completed",
    notImplemented: [
        "product:immunizationMedicationInformation"
    ]
};

var medicationDispense = {
    key: "supply",
    attributes: {
        classCode: "SPLY",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.18"),
        fieldLevel.id,
        fieldLevel.statusCodeCompleted,
        fieldLevel.effectiveTime, {
            key: "product",
            content: medicationInformation,
            dataKey: "product"
        },
        fieldLevel.performer
    ],
    toDo: "statusCode needs to allow different values than completed",
    notImplemented: [
        "repeatNumber",
        "quantity",
        "product:ImmunizationMedicationInformation",
        "entryRelationship:medicationSupplyOrder",
    ]
};

exports.medicationActivity = {
    key: "substanceAdministration",
    attributes: {
        classCode: "SBADM",
        moodCode: function (input) {
            var status = input.status;
            if (status) {
                if (status === 'Prescribed') {
                    return 'INT';
                }
                if (status === 'Completed') {
                    return 'EVN';
                }
            }
            return null;
        }
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.16"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "text",
            text: leafLevel.input,
            dataKey: "sig"
        },
        fieldLevel.statusCodeCompleted, [fieldLevel.effectiveTime, required], {
            key: "effectiveTime",
            attributes: {
                "xsi:type": "PIVL_TS",
                "institutionSpecified": "true",
                "operator": "A"
            },
            content: {
                key: "period",
                attributes: {
                    value: leafLevel.inputProperty("value"),
                    unit: leafLevel.inputProperty("unit")
                },
            },
            dataKey: "administration.interval.period",
        }, {
            key: "routeCode",
            attributes: leafLevel.code,
            dataKey: "administration.route"
        }, {
            key: "doseQuantity",
            attributes: {
                value: leafLevel.inputProperty("value"),
                unit: leafLevel.inputProperty("unit")
            },
            dataKey: "administration.dose"
        }, {
            key: "rateQuantity",
            attributes: {
                value: leafLevel.inputProperty("value"),
                unit: leafLevel.inputProperty("unit")
            },
            dataKey: "administration.rate"
        }, {
            key: "administrationUnitCode",
            attributes: leafLevel.code,
            dataKey: "administration.form"
        }, {
            key: "consumable",
            content: medicationInformation,
            dataKey: "product"
        },
        fieldLevel.performer, {
            key: "participant",
            attributes: {
                typeCode: "CSM"
            },
            content: [
                [sharedEntryLevel.drugVehicle, required]
            ],
            dataKey: "drug_vehicle"
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "RSON"
            },
            content: [
                [sharedEntryLevel.indication, required]
            ],
            dataKey: "indication"
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "REFR"
            },
            content: [
                [medicationSupplyOrder, required]
            ],
            dataKey: "supply"
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "REFR"
            },
            content: [
                [medicationDispense, required]
            ],
            dataKey: "dispense"
        }, {
            key: "precondition",
            attributes: {
                typeCode: "PRCN"
            },
            content: [
                fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.25"), [sharedEntryLevel.preconditionForSubstanceAdministration, required]
            ],
            dataKey: "precondition",
            warning: "templateId needs to be in preconditionForSubstanceAdministration but CCD_1.xml contradicts"
        }
    ],
    notImplemented: [
        "code",
        "text:reference",
        "repeatNumber",
        "approachSiteCode",
        "maxDoseQuantity",
        "entryRelationship:instructions",
        "reactionObservation"
    ]
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22,"./sharedEntryLevel":17}],12:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");
var contentModifier = require("../contentModifier");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

var policyActivity = {
    key: "act",
    attributes: {
        classCode: "ACT",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.61"),
        fieldLevel.statusCodeCompleted, {
            key: "id",
            attributes: {
                root: leafLevel.inputProperty("identifier"),
                extension: leafLevel.inputProperty("extension")
            },
            dataKey: 'policy.identifiers',
            existsWhen: condition.keyExists('identifier'),
            required: true
        }, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "policy.code"
        }, {
            key: "performer",
            attributes: {
                typeCode: "PRF"
            },
            content: [
                fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.87"),
                fieldLevel.assignedEntity
            ],
            dataKey: "policy.insurance.performer"
        }, {
            key: "performer",
            attributes: {
                typeCode: "PRF"
            },
            content: [
                fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.88"),
                fieldLevel.assignedEntity
            ],
            dataKey: "guarantor"
        }, {
            key: "participant",
            attributes: {
                typeCode: "COV"
            },
            content: [
                fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.89"), [fieldLevel.effectiveTime, key("time")], {
                    key: "participantRole",
                    attributes: {
                        classCode: "PAT"
                    },
                    content: [
                        fieldLevel.id,
                        fieldLevel.usRealmAddress,
                        fieldLevel.telecom, {
                            key: "code",
                            attributes: leafLevel.code,
                            dataKey: "code"
                        }, {
                            key: "playingEntity",
                            content: fieldLevel.usRealmName
                        }
                    ]
                }
            ],
            dataKey: "participant",
            dataTransform: function (input) {
                if (input.performer) {
                    input.identifiers = input.performer.identifiers;
                    input.address = input.performer.address;
                    input.phone = input.performer.phone;
                }
                return input;
            }
        }, {
            key: "participant",
            attributes: {
                typeCode: "HLD"
            },
            content: [
                fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.90"), {
                    key: "participantRole",
                    content: [
                        fieldLevel.id,
                        fieldLevel.usRealmAddress
                    ],
                    dataKey: "performer"
                }
            ],
            dataKey: "policy_holder"
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "REFR"
            },
            content: {
                key: "act",
                attributes: {
                    classCode: "ACT",
                    moodCode: "EVN"
                },
                content: [
                    fieldLevel.templateId("2.16.840.1.113883.10.20.1.19"),
                    fieldLevel.id, {
                        key: "entryRelationship",
                        attributes: {
                            typeCode: "SUBJ"
                        },
                        content: {
                            key: "procedure",
                            attributes: {
                                classCode: "PROC",
                                moodCode: "PRMS"
                            },
                            content: {
                                key: "code",
                                attributes: leafLevel.code,
                                dataKey: "code"
                            }
                        },
                        dataKey: "procedure"
                    }
                ]
            },
            dataKey: "authorization"
        }
    ]
};

exports.coverageActivity = {
    key: "act",
    attributes: {
        classCode: "ACT",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.60"),
        fieldLevel.uniqueId,
        fieldLevel.id,
        fieldLevel.templateCode("CoverageActivity"),
        fieldLevel.statusCodeCompleted, {
            key: "entryRelationship",
            attributes: {
                typeCode: "COMP"
            },
            content: [
                [policyActivity, required]
            ],
            required: true
        }
    ]
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22}],13:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");
var contentModifier = require("../contentModifier");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

exports.planOfCareActivityAct = {
    key: "act",
    attributes: {
        classCode: "ACT",
        moodCode: "RQO"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.39"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "plan"
        },
        fieldLevel.statusCodeNew,
        fieldLevel.effectiveTime
    ],
    existsWhen: function (input) {
        return input.type === "act";
    }
};

exports.planOfCareActivityObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "RQO"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.44"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "plan"
        },
        fieldLevel.statusCodeNew,
        fieldLevel.effectiveTime
    ],
    existsWhen: function (input) {
        return input.type === "observation";
    }
};

exports.planOfCareActivityProcedure = {
    key: "procedure",
    attributes: {
        classCode: "PROC",
        moodCode: "RQO"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.41"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "plan"
        },
        fieldLevel.statusCodeNew,
        fieldLevel.effectiveTime
    ],
    existsWhen: function (input) {
        return input.type === "procedure";
    }
};

exports.planOfCareActivityEncounter = {
    key: "encounter",
    attributes: {
        classCode: "ENC",
        moodCode: "INT"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.40"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "plan"
        },
        fieldLevel.statusCodeNew,
        fieldLevel.effectiveTime
    ],
    existsWhen: function (input) {
        return input.type === "encounter";
    }
};

exports.planOfCareActivitySubstanceAdministration = {
    key: "substanceAdministration",
    attributes: {
        classCode: "SBADM",
        moodCode: "RQO"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.42"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "plan"
        },
        fieldLevel.statusCodeNew,
        fieldLevel.effectiveTime
    ],
    existsWhen: function (input) {
        return input.type === "substanceAdministration";
    }
};

exports.planOfCareActivitySupply = {
    key: "supply",
    attributes: {
        classCode: "SPLY",
        moodCode: "INT"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.43"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "plan"
        },
        fieldLevel.statusCodeNew,
        fieldLevel.effectiveTime
    ],
    existsWhen: function (input) {
        return input.type === "supply";
    }
};

exports.planOfCareActivityInstructions = {
    key: "instructions",
    attributes: {
        classCode: "ACT",
        moodCode: "INT"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.20"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "plan"
        },
        fieldLevel.statusCodeNew,
        fieldLevel.effectiveTime
    ],
    existsWhen: function (input) {
        return input.type === "instructions";
    }
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22}],14:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");
var contentModifier = require("../contentModifier");

var sharedEntryLevel = require("./sharedEntryLevel");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

var problemStatus = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.6"),
        fieldLevel.id,
        fieldLevel.templateCode("ProblemStatus"),
        fieldLevel.statusCodeCompleted,
        fieldLevel.effectiveTime, {
            key: "value",
            attributes: [{
                    "xsi:type": "CD"
                },
                leafLevel.codeFromName("2.16.840.1.113883.3.88.12.80.68")
            ],
            dataKey: "name",
            required: true
        }
    ],
    warning: "effectiveTime does not exist in the specification"
};

var healthStatusObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.5"),
        fieldLevel.templateCode("HealthStatusObservation"),
        fieldLevel.text(leafLevel.nextReference("healthStatus")),
        fieldLevel.statusCodeCompleted, {
            key: "value",
            attributes: {
                "xsi:type": "CD",
                code: "81323004",
                codeSystem: "2.16.840.1.113883.6.96",
                codeSystemName: "SNOMED CT",
                displayName: leafLevel.inputProperty("patient_status")
            },
            required: true,
            toDo: "The attribute should not be constant"
        }
    ]
};

var problemObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN",
        negationInd: leafLevel.boolInputProperty("negation_indicator")
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.4"),
        fieldLevel.id,
        fieldLevel.text(leafLevel.nextReference("problem")),
        fieldLevel.statusCodeCompleted, [fieldLevel.effectiveTime, dataKey("problem.date_time")], {
            key: "value",
            attributes: [{
                    "xsi:type": "CD"
                },
                leafLevel.code
            ],
            content: [{
                key: "translation",
                attributes: leafLevel.code,
                dataKey: "translations"
            }],
            dataKey: "problem.code",
            existsWhen: condition.codeOrDisplayname,
            required: true
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "REFR"
            },
            content: [
                [problemStatus, required]
            ],
            dataTransform: function (input) {
                if (input && input.status) {
                    var result = input.status;
                    result.identifiers = input.identifiers;
                    return result;
                }
                return null;
            }
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "SUBJ",
                inversionInd: "true"
            },
            content: [
                [sharedEntryLevel.ageObservation, required]
            ],
            existsWhen: condition.keyExists("onset_age")
        }, {
            key: "entryRelationship",
            attributes: {
                typeCode: "REFR"
            },
            content: [
                [healthStatusObservation, required]
            ],
            existsWhen: condition.keyExists("patient_status")
        }
    ],
    notImplemented: [
        "code"
    ]
};

exports.problemConcernAct = {
    key: "act",
    attributes: {
        classCode: "ACT",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.3"),
        fieldLevel.templateCode("ProblemConcernAct"),
        fieldLevel.uniqueId, {
            key: "id",
            attributes: {
                root: leafLevel.inputProperty("identifier"),
                extension: leafLevel.inputProperty("extension")
            },
            dataKey: 'source_list_identifiers',
            existsWhen: condition.keyExists('identifier'),
            required: true
        },
        fieldLevel.statusCodeCompleted, [fieldLevel.effectiveTime, required], {
            key: "entryRelationship",
            attributes: {
                typeCode: "SUBJ"
            },
            content: [
                [problemObservation, required]
            ],
            required: true
        }
    ]
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22,"./sharedEntryLevel":17}],15:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");
var contentModifier = require("../contentModifier");

var sharedEntryLevel = require("./sharedEntryLevel");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

exports.procedureActivityAct = {
    key: "act",
    attributes: {
        classCode: "ACT",
        moodCode: "INT" // not constant in the specification
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.12"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            content: [{
                key: "originalText",
                content: [{
                    key: "reference",
                    attributes: {
                        "value": leafLevel.nextReference("procedure")
                    }
                }]
            }],
            dataKey: "procedure",
            required: true
        }, {
            key: "statusCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.11.20.9.22"),
            dataKey: "status",
            required: true
        },
        fieldLevel.effectiveTime, {
            key: "priorityCode",
            attributes: leafLevel.code,
            dataKey: "priority"
        }, {
            key: "targetSiteCode",
            attributes: leafLevel.code,
            dataKey: "body_sites"
        },
        fieldLevel.performer, {
            key: "participant",
            attributes: {
                typeCode: "LOC"
            },
            content: [
                [sharedEntryLevel.serviceDeliveryLocation, required]
            ],
            dataKey: "locations"
        }
    ],
    existsWhen: condition.propertyEquals("procedure_type", "act"),
    toDo: ["moodCode should be variable"],
    notImplemented: [
        "entryRelationship:encounter",
        "entryRelationship:indication",
        "entryRelationship:medicationActivity"
    ]
};

exports.procedureActivityProcedure = {
    key: "procedure",
    attributes: {
        classCode: "PROC",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.14"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            content: [{
                key: "originalText",
                content: [{
                    key: "reference",
                    attributes: {
                        "value": leafLevel.nextReference("procedure")
                    }
                }]
            }],
            dataKey: "procedure",
            required: true
        }, {
            key: "statusCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.11.20.9.22"),
            dataKey: "status",
            required: true
        },
        fieldLevel.effectiveTime, {
            key: "priorityCode",
            attributes: leafLevel.code,
            dataKey: "priority"
        }, {
            key: "targetSiteCode",
            attributes: leafLevel.code,
            dataKey: "body_sites"
        }, {
            key: "specimen",
            attributes: {
                typeCode: "SPC"
            },
            content: {
                key: "specimenRole",
                attributes: {
                    classCode: "SPEC"
                },
                content: [
                    fieldLevel.id, {
                        key: "specimenPlayingEntity",
                        content: {
                            key: "code",
                            attributes: leafLevel.code,
                            dataKey: "code"
                        },
                        existsWhen: condition.keyExists("code")
                    }
                ],
                required: true
            },
            dataKey: "specimen"
        },
        fieldLevel.performer, {
            key: "participant",
            attributes: {
                typeCode: "LOC"
            },
            content: [
                [sharedEntryLevel.serviceDeliveryLocation, required]
            ],
            dataKey: "locations"
        }
    ],
    existsWhen: condition.propertyEquals("procedure_type", "procedure"),
    toDo: ["moodCode should be variable"],
    notImplemented: [
        "methodCode",
        "participant:productInstance",
        "entryRelationship:encounter",
        "entryRelationship:instructions",
        "entryRelationship:indication",
        "entryRelationship:medicationActivity"
    ]
};

exports.procedureActivityObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN" // not constant in the specification
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.13"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            content: [{
                key: "originalText",
                content: [{
                    key: "reference",
                    attributes: {
                        "value": leafLevel.nextReference("procedure")
                    }
                }]
            }],
            dataKey: "procedure",
            required: true
        }, {
            key: "statusCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.11.20.9.22"),
            dataKey: "status",
            required: true
        },
        fieldLevel.effectiveTime, {
            key: "priorityCode",
            attributes: leafLevel.code,
            dataKey: "priority"
        }, {
            key: "value",
            attributes: {
                "xsi:type": "CD"
            }
        }, {
            key: "targetSiteCode",
            attributes: leafLevel.code,
            dataKey: "body_sites"
        },
        fieldLevel.performer, {
            key: "participant",
            attributes: {
                typeCode: "LOC"
            },
            content: [
                [sharedEntryLevel.serviceDeliveryLocation, required]
            ],
            dataKey: "locations"
        }
    ],
    existsWhen: condition.propertyEquals("procedure_type", "observation"),
    toDo: ["moodCode should be variable"],
    notImplemented: [
        "entryRelationship:encounter",
        "entryRelationship:instructions",
        "entryRelationship:indication",
        "entryRelationship:medicationActivity"
    ]
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22,"./sharedEntryLevel":17}],16:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");

var contentModifier = require("../contentModifier");

var required = contentModifier.required;

var resultObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.2"),
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "result",
            required: true
        },
        fieldLevel.text(leafLevel.nextReference("result")),
        fieldLevel.statusCodeCompleted, [fieldLevel.effectiveTime, required], {
            key: "value",
            attributes: {
                "xsi:type": function (input) {
                    return input.text ? "ST" : "PQ";
                },
                value: leafLevel.inputProperty("value"),
                unit: leafLevel.inputProperty("unit")
            },
            text: leafLevel.inputProperty("text"),
            existsWhen: condition.eitherKeyExists("value", "text"),
            required: true
        }, {
            key: "interpretationCode",
            attributes: {
                code: function (input) {
                    return input.substr(0, 1);
                },
                codeSystem: "2.16.840.1.113883.5.83",
                displayName: leafLevel.input,
                codeSystemName: "ObservationInterpretation"
            },
            dataKey: "interpretations"
        }, {
            key: "referenceRange",
            content: {
                key: "observationRange",
                content: [{
                    key: "text",
                    text: leafLevel.input,
                    dataKey: "range"
                }, {
                    key: "value",
                    attributes: {
                        "xsi:type": "IVL_PQ"
                    },
                    content: [{
                        key: "low",
                        attributes: {
                            value: leafLevel.inputProperty("low"),
                            unit: leafLevel.inputProperty("unit")
                        },
                        existsWhen: condition.keyExists("low")
                    }, {
                        key: "high",
                        attributes: {
                            value: leafLevel.inputProperty("high"),
                            unit: leafLevel.inputProperty("unit")
                        },
                        existsWhen: condition.keyExists("high")
                    }],
                    existsWhen: condition.eitherKeyExists("low", "high")
                }],
                required: true
            },
            dataKey: "reference_range"
        }
    ],
    notIplemented: [
        "variable statusCode",
        "methodCode",
        "targetSiteCode",
        "author"
    ]
};

exports.resultOrganizer = {
    key: "organizer",
    attributes: {
        classCode: "BATTERY",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.1"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            content: {
                key: "translation",
                attributes: leafLevel.code,
                dataKey: "translations"
            },
            dataKey: "result_set",
            required: true
        },
        fieldLevel.statusCodeCompleted, {
            key: "component",
            content: [
                [resultObservation, required]
            ],
            dataKey: "results",
            required: true
        }
    ],
    notIplemented: [
        "variable @classCode",
        "variable statusCode"
    ]
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22}],17:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require('../condition');

var severityObservation = exports.severityObservation = {
    key: "observation",
    attributes: {
        "classCode": "OBS",
        "moodCode": "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.8"),
        fieldLevel.templateCode("SeverityObservation"),
        fieldLevel.text(leafLevel.nextReference("severity")),
        fieldLevel.statusCodeCompleted, {
            key: "value",
            attributes: [
                leafLevel.typeCD,
                leafLevel.code
            ],
            dataKey: "code",
            existsWhen: condition.codeOrDisplayname,
            required: true
        }, {
            key: "interpretationCode",
            attributes: leafLevel.code,
            dataKey: "interpretation",
            existsWhen: condition.codeOrDisplayname
        }
    ],
    dataKey: "severity",
    existsWhen: condition.keyExists("code")
};

var reactionObservation = exports.reactionObservation = {
    key: "observation",
    attributes: {
        "classCode": "OBS",
        "moodCode": "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.9"),
        fieldLevel.id,
        fieldLevel.nullFlavor("code"),
        fieldLevel.text(leafLevel.sameReference("reaction")),
        fieldLevel.statusCodeCompleted,
        fieldLevel.effectiveTime, {
            key: "value",
            attributes: [
                leafLevel.typeCD,
                leafLevel.code
            ],
            dataKey: 'reaction',
            existsWhen: condition.codeOrDisplayname,
            required: true
        }, {
            key: "entryRelationship",
            attributes: {
                "typeCode": "SUBJ",
                "inversionInd": "true"
            },
            content: severityObservation,
            existsWhen: condition.keyExists('severity')
        }
    ],
    notImplemented: [
        "Procedure Activity Procedure",
        "Medication Activity"
    ]
};

exports.serviceDeliveryLocation = {
    key: "participantRole",
    attributes: {
        classCode: "SDLOC"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.32"), {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "location_type",
            required: true
        },
        fieldLevel.usRealmAddress,
        fieldLevel.telecom, {
            key: "playingEntity",
            attributes: {
                classCode: "PLC"
            },
            content: {
                key: "name",
                text: leafLevel.inputProperty("name"),
            },
            existsWhen: condition.keyExists("name")
        }
    ]
};

exports.ageObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.31"),
        fieldLevel.templateCode("AgeObservation"),
        fieldLevel.statusCodeCompleted, {
            key: "value",
            attributes: {
                "xsi:type": "PQ",
                value: leafLevel.inputProperty("onset_age"),
                unit: leafLevel.codeOnlyFromName("2.16.840.1.113883.11.20.9.21", "onset_age_unit")
            },
            required: true
        }
    ]
};

exports.indication = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.19"),
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            dataKey: "code",
            required: true
        },
        fieldLevel.statusCodeCompleted,
        fieldLevel.effectiveTime, {
            key: "value",
            attributes: [
                leafLevel.typeCD,
                leafLevel.code
            ],
            dataKey: "value",
            existsWhen: condition.codeOrDisplayname
        }
    ],
    notImplemented: [
        "value should handle nullFlavor=OTH and translation"
    ]
};

exports.preconditionForSubstanceAdministration = {
    key: "criterion",
    content: [{
        key: "code",
        attributes: {
            code: leafLevel.inputProperty("code"),
            codeSystem: "2.16.840.1.113883.5.4"
        },
        dataKey: "code"
    }, {
        key: "value",
        attributes: [
            leafLevel.typeCE, // TODO: spec has CD, spec example has CE
            leafLevel.code
        ],
        dataKey: "value",
        existsWhen: condition.codeOrDisplayname
    }],
    warning: [
        "value type is CE is example but CD in spec",
        "templateId should be here according to spec but per CCD_1 is put in the parent"
    ]
};

exports.drugVehicle = {
    key: "participantRole",
    attributes: {
        classCode: "MANU"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.24"), {
            key: "code",
            attributes: {
                code: "412307009",
                displayName: "drug vehicle",
                codeSystem: "2.16.840.1.113883.6.96",
                codeSystemName: "SNOMED CT"
            }
        }, {
            key: "playingEntity",
            attributes: {
                classCode: "MMAT"
            },
            content: [{
                key: "code",
                attributes: leafLevel.code,
                required: true
            }, {
                key: "name",
                text: leafLevel.inputProperty("name")
            }],
            required: true
        }
    ]
};

exports.instructions = {
    key: "act",
    attributes: {
        classCode: "ACT",
        moodCode: "INT"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.20"), {
            key: "code",
            attributes: [
                leafLevel.code
            ],
            dataKey: "code",
            required: true
        },
        fieldLevel.text(leafLevel.nextReference("instruction")),
        fieldLevel.statusCodeCompleted
    ]
};

},{"../condition":3,"../fieldLevel":20,"../leafLevel":22}],18:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');

var contentModifier = require("../contentModifier");

var required = contentModifier.required;

exports.socialHistoryObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.38"),
        fieldLevel.uniqueId,
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            content: [{
                key: "originalText",
                text: leafLevel.inputProperty("unencoded_name"),
                content: {
                    key: "reference",
                    attributes: {
                        "value": leafLevel.nextReference("social")
                    }
                }
            }, {
                key: "translation",
                attributes: leafLevel.code,
                dataKey: "translations"
            }],
            dataKey: "code",
        },
        fieldLevel.statusCodeCompleted,
        fieldLevel.effectiveTime, {
            key: "value",
            attributes: {
                "xsi:type": "ST"
            },
            text: leafLevel.inputProperty("value")
        }
    ],
    existsWhen: function (input) {
        return (!input.value) || input.value.indexOf("smoke") < 0;
    }
};

exports.smokingStatusObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.78"),
        fieldLevel.uniqueId,
        fieldLevel.id,
        fieldLevel.templateCode("SmokingStatusObservation"),
        fieldLevel.statusCodeCompleted, [fieldLevel.effectiveTime, required], {
            key: "value",
            attributes: [{
                    "xsi:type": "CD"
                },
                leafLevel.codeFromName("2.16.840.1.113883.11.20.9.38")
            ],
            required: true,
            dataKey: "value"
        }
    ],
    existsWhen: function (input) {
        return input.value && input.value.indexOf("smoke") > -1;
    }
};

},{"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22}],19:[function(require,module,exports){
"use strict";

var fieldLevel = require('../fieldLevel');
var leafLevel = require('../leafLevel');
var condition = require("../condition");

var contentModifier = require("../contentModifier");

var required = contentModifier.required;

var vitalSignObservation = {
    key: "observation",
    attributes: {
        classCode: "OBS",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.27"),
        fieldLevel.id, {
            key: "code",
            attributes: leafLevel.code,
            content: [{
                key: "originalText",
                content: {
                    key: "reference",
                    attributes: {
                        "value": leafLevel.nextReference("vital")
                    }
                }
            }, {
                key: "translation",
                attributes: leafLevel.code,
                dataKey: "translations"
            }],
            dataKey: "vital",
            required: true
        }, {
            key: "statusCode",
            attributes: {
                code: leafLevel.inputProperty("status")
            }
        },
        [fieldLevel.effectiveTime, required], {
            key: "value",
            attributes: {
                "xsi:type": "PQ",
                value: leafLevel.inputProperty("value"),
                unit: leafLevel.inputProperty("unit")
            },
            existsWhen: condition.keyExists("value"),
            required: true
        }, {
            key: "interpretationCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.5.83"),
            dataKey: "interpretations"
        }
    ],
    notImplemented: [
        "constant statusCode",
        "methodCode",
        "targetSiteCode",
        "author"
    ]
};

exports.vitalSignsOrganizer = {
    key: "organizer",
    attributes: {
        classCode: "CLUSTER",
        moodCode: "EVN"
    },
    content: [
        fieldLevel.templateId("2.16.840.1.113883.10.20.22.4.26"),
        fieldLevel.uniqueId,
        fieldLevel.id,
        fieldLevel.templateCode("VitalSignsOrganizer"), {
            key: "statusCode",
            attributes: {
                code: leafLevel.inputProperty("status")
            }
        },
        [fieldLevel.effectiveTime, required], {
            key: "component",
            content: vitalSignObservation,
            required: true
        }
    ],
    notImplemented: [
        "constant statusCode"
    ]
};

},{"../condition":3,"../contentModifier":4,"../fieldLevel":20,"../leafLevel":22}],20:[function(require,module,exports){
"use strict";

var bbm = require("blue-button-meta");
var uuid = require('uuid');

var condition = require("./condition");
var leafLevel = require("./leafLevel");
var translate = require("./translate");
var contentModifier = require("./contentModifier");

var templateCodes = bbm.CCDA.sections_entries_codes.codes;

var key = contentModifier.key;
var required = contentModifier.required;

exports.templateId = function (id) {
    return {
        key: "templateId",
        attributes: {
            "root": id
        }
    };
};

exports.templateCode = function (name) {
    var raw = templateCodes[name];
    var result = {
        key: "code",
        attributes: {
            code: raw.code,
            displayName: raw.name,
            codeSystem: raw.code_system,
            codeSystemName: raw.code_system_name
        }
    };
    return result;
};

exports.templateTitle = function (name) {
    var raw = templateCodes[name];
    var result = {
        key: "title",
        text: raw.name,
    };
    return result;
};

var id = exports.id = {
    key: "id",
    attributes: {
        root: leafLevel.inputProperty("identifier"),
        extension: leafLevel.inputProperty("extension")
    },
    dataKey: 'identifiers',
    existsWhen: condition.keyExists('identifier'),
    required: true
};

exports.uniqueId = {
    key: "id",
    attributes: {
        root: function (input, context) {
            return context.rootId;
        },
        extension: function () {
            return uuid.v4();
        }
    },
    existsWhen: function (input, context) {
        return context.rootId;
    }
};

exports.statusCodeCompleted = {
    key: "statusCode",
    attributes: {
        code: 'completed'
    }
};

exports.statusCodeActive = {
    key: "statusCode",
    attributes: {
        code: 'active'
    }
};

exports.statusCodeNew = {
    key: "statusCode",
    attributes: {
        code: 'new'
    }
};

var effectiveTime = exports.effectiveTime = {
    key: "effectiveTime",
    attributes: {
        "value": leafLevel.time,
    },
    attributeKey: 'point',
    content: [{
        key: "low",
        attributes: {
            "value": leafLevel.time
        },
        dataKey: 'low',
    }, {
        key: "high",
        attributes: {
            "value": leafLevel.time
        },
        dataKey: 'high',
    }, {
        key: "center",
        attributes: {
            "value": leafLevel.time
        },
        dataKey: 'center',
    }],
    dataKey: 'date_time',
    existsWhen: condition.eitherKeyExists('point', 'low', 'high', 'center')
};

exports.text = function (referenceMethod) {
    return {
        key: "text",
        text: leafLevel.inputProperty("free_text"),
        content: {
            key: "reference",
            attributes: {
                "value": referenceMethod
            },
        }
    };
};

exports.nullFlavor = function (name) {
    return {
        key: name,
        attributes: {
            nullFlavor: "UNK"
        }
    };
};

var usRealmAddress = exports.usRealmAddress = {
    key: "addr",
    attributes: {
        use: leafLevel.use("use")
    },
    content: [{
        key: "country",
        text: leafLevel.inputProperty("country")
    }, {
        key: "state",
        text: leafLevel.inputProperty("state")
    }, {
        key: "city",
        text: leafLevel.inputProperty("city")
    }, {
        key: "postalCode",
        text: leafLevel.inputProperty("zip")
    }, {
        key: "streetAddressLine",
        text: leafLevel.input,
        dataKey: "street_lines"
    }],
    dataKey: "address"
};

var usRealmName = exports.usRealmName = {
    key: "name",
    content: [{
        key: "family",
        text: leafLevel.inputProperty("family")
    }, {
        key: "given",
        text: leafLevel.input,
        dataKey: "given"
    }, {
        key: "prefix",
        text: leafLevel.inputProperty("prefix")
    }, {
        key: "suffix",
        text: leafLevel.inputProperty("suffix")
    }],
    dataKey: "name",
    dataTransform: translate.name
};

var telecom = exports.telecom = {
    key: "telecom",
    attributes: {
        value: leafLevel.inputProperty("value"),
        use: leafLevel.inputProperty("use")
    },
    dataTransform: translate.telecom
};

var representedOrganization = {
    key: "representedOrganization",
    content: [
        id, {
            key: "name",
            text: leafLevel.input,
            dataKey: "name"
        },
        usRealmAddress,
        telecom
    ],
    dataKey: "organization"
};

var assignedEntity = exports.assignedEntity = {
    key: "assignedEntity",
    content: [{
            key: "code",
            attributes: leafLevel.code,
            dataKey: "code"
        },
        id,
        usRealmAddress,
        telecom, {
            key: "assignedPerson",
            content: usRealmName,
            existsWhen: condition.keyExists("name")
        },
        representedOrganization
    ],
    existsWhen: condition.eitherKeyExists("address", "identifiers", "organization", "name")
};

exports.author = {
    key: "author",
    content: [
        [effectiveTime, required, key("time")], {
            key: "assignedAuthor",
            content: [
                id, {
                    key: "assignedPerson",
                    content: usRealmName
                },
                representedOrganization
            ]
        }
    ],
    dataKey: "author"
};

exports.performer = {
    key: "performer",
    content: [
        [assignedEntity, required]
    ],
    dataKey: "performer"
};

},{"./condition":3,"./contentModifier":4,"./leafLevel":22,"./translate":24,"blue-button-meta":25,"uuid":82}],21:[function(require,module,exports){
"use strict";

var fieldLevel = require('./fieldLevel');
var leafLevel = require('./leafLevel');
var condition = require('./condition');
var contentModifier = require("./contentModifier");

var key = contentModifier.key;
var required = contentModifier.required;
var dataKey = contentModifier.dataKey;

var patientName = Object.create(fieldLevel.usRealmName);
patientName.attributes = {
    use: "L"
};

var patient = exports.patient = {
    key: "patient",
    content: [
        patientName, {
            key: "administrativeGenderCode",
            attributes: {
                code: function (input) {
                    return input.substring(0, 1);
                },
                codeSystem: "2.16.840.1.113883.5.1",
                codeSystemName: "HL7 AdministrativeGender",
                displayName: leafLevel.input
            },
            dataKey: "gender"
        },
        [fieldLevel.effectiveTime, key("birthTime"), dataKey("dob")], {
            key: "maritalStatusCode",
            attributes: {
                code: function (input) {
                    return input.substring(0, 1);
                },
                displayName: leafLevel.input,
                codeSystem: "2.16.840.1.113883.5.2",
                codeSystemName: "HL7 Marital Status"
            },
            dataKey: "marital_status"
        }, {
            key: "religiousAffiliationCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.5.1076"),
            dataKey: "religion"
        }, {
            key: "ethnicGroupCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.6.238"),
            dataKey: "ethnicity"
        }, {
            key: "raceCode",
            attributes: leafLevel.codeFromName("2.16.840.1.113883.6.238"),
            dataKey: "race"
        }, {
            key: "guardian",
            content: [{
                    key: "code",
                    attributes: leafLevel.codeFromName("2.16.840.1.113883.5.111"),
                    dataKey: "relation"
                },
                [fieldLevel.usRealmAddress, dataKey("addresses")],
                fieldLevel.telecom, {
                    key: "guardianPerson",
                    content: {
                        key: "name",
                        content: [{
                            key: "given",
                            text: leafLevel.inputProperty("first")
                        }, {
                            key: "family",
                            text: leafLevel.inputProperty("last")
                        }],
                        dataKey: "names"
                    }
                }
            ],
            dataKey: "guardians"
        }, {
            key: "birthplace",
            content: {
                key: "place",
                content: [
                    [fieldLevel.usRealmAddress, dataKey("birthplace")]
                ]
            },
            existsWhen: condition.keyExists("birthplace")
        }, {
            key: "languageCommunication",
            content: [{
                key: "languageCode",
                attributes: {
                    code: leafLevel.input
                },
                dataKey: "language"
            }, {
                key: "modeCode",
                attributes: leafLevel.codeFromName("2.16.840.1.113883.5.60"),
                dataKey: "mode"
            }, {
                key: "proficiencyLevelCode",
                attributes: {
                    code: function (input) {
                        return input.substring(0, 1);
                    },
                    displayName: leafLevel.input,
                    codeSystem: "2.16.840.1.113883.5.61",
                    codeSystemName: "LanguageAbilityProficiency"
                },
                dataKey: "proficiency"
            }, {
                key: "preferenceInd",
                attributes: {
                    value: function (input) {
                        return input.toString();
                    }
                },
                dataKey: "preferred"
            }],
            dataKey: "languages"
        }
    ]
};

var provider = exports.provider = {
    key: "performer",
    attributes: {
        typeCode: "PRF"
    },
    content: {
        key: "assignedEntity",
        content: [{
                key: "code",
                attributes: leafLevel.code,
                dataKey: "type"
            },
            [fieldLevel.effectiveTime, key("time"), dataKey("date_time")], {
                key: "assignedPerson",
                content: [{
                    key: "name",
                    content: [{
                        key: "given",
                        text: leafLevel.inputProperty("first")
                    }, {
                        key: "family",
                        text: leafLevel.inputProperty("last")
                    }],
                    dataKey: "name"
                }, {
                    key: "telecom",
                    attributes: [{
                        use: "WP",
                        value: function (input) {
                            return input.value.number;
                        }
                    }],
                    dataKey: "phone"
                }]
            }
        ]
    },
    dataKey: "providers"
};

var recordTarget = exports.recordTarget = {
    key: "recordTarget",
    content: {
        key: "patientRole",
        content: [
            fieldLevel.id, [fieldLevel.usRealmAddress, dataKey("addresses")],
            fieldLevel.telecom,
            patient
        ]
    },
    dataKey: "data.demographics"
};

var providers = exports.providers = {
    key: "documentationOf",
    attributes: {
        typeCode: "DOC"
    },
    content: {
        key: "serviceEvent",
        attributes: {
            classCode: "PCPR"
        },
        content: [
            provider
        ]
    },
    dataKey: "data.demographics"
};

},{"./condition":3,"./contentModifier":4,"./fieldLevel":20,"./leafLevel":22}],22:[function(require,module,exports){
"use strict";

var bbu = require("blue-button-util");

var translate = require('./translate');

var bbuo = bbu.object;
var bbud = bbu.datetime;

exports.input = function (input) {
    return input;
};

exports.inputProperty = function (key) {
    return function (input) {
        return input && input[key];
    };
};

exports.boolInputProperty = function (key) {
    return function (input) {
        if (input && input.hasOwnProperty(key)) {
            return input[key].toString();
        } else {
            return null;
        }
    };
};

exports.code = translate.code;

exports.codeFromName = translate.codeFromName;

exports.codeOnlyFromName = function (OID, key) {
    var f = translate.codeFromName(OID);
    return function (input) {
        if (input && input[key]) {
            return f(input[key]).code;
        } else {
            return null;
        }
    };
};

exports.time = translate.time;

exports.use = function (key) {
    return function (input) {
        var value = input && input[key];
        if (value) {
            return translate.acronymize(value);
        } else {
            return null;
        }
    };
};

exports.typeCD = {
    "xsi:type": "CD"
};

exports.typeCE = {
    "xsi:type": "CE"
};

exports.nextReference = function (referenceKey) {
    return function (input, context) {
        return context.nextReference(referenceKey);
    };
};

exports.sameReference = function (referenceKey) {
    return function (input, context) {
        return context.sameReference(referenceKey);
    };
};

exports.deepInputProperty = function (deepProperty, defaultValue) {
    return function (input) {
        var value = bbuo.deepValue(input, deepProperty);
        value = bbuo.exists(value) ? value : defaultValue;
        if (typeof value !== 'string') {
            value = value.toString();
        }
        return value;
    };
};

exports.deepInputDate = function (deepProperty, defaultValue) {
    return function (input) {
        var value = bbuo.deepValue(input, deepProperty);
        if (!bbuo.exists(value)) {
            return defaultValue;
        } else {
            value = bbud.modelToDate({
                date: value.date,
                precision: value.precision // workaround a bug in bbud.  Changes precision.
            });
            if (bbuo.exists(value)) {
                return value;
            } else {
                return defaultValue;
            }
        }
    };
};

},{"./translate":24,"blue-button-util":35}],23:[function(require,module,exports){
"use strict";

var bbu = require("blue-button-util");

var fieldLevel = require("./fieldLevel");
var entryLevel = require("./entryLevel");
var leafLevel = require('./leafLevel');
var contentModifier = require("./contentModifier");

var required = contentModifier.required;
var bbud = bbu.datetime;
var bbuo = bbu.object;

var nda = "No Data Available";

var getText = function (topArrayKey, headers, values) {
    var result = {
        key: "text",
        content: [{
            key: "table",
            attributes: {
                border: "1",
                width: "100%"
            },
            content: [{
                key: "thead",
                content: [{
                    key: "tr",
                    content: []
                }]
            }, {
                key: "tbody",
                content: [{
                    key: "tr",
                    content: [],
                    dataKey: topArrayKey
                }]
            }]
        }]
    };
    var headerTarget = result.content[0].content[0].content[0].content;
    headers.forEach(function (header) {
        var element = {
            key: "th",
            text: header
        };
        headerTarget.push(element);
    });
    var valueTarget = result.content[0].content[1].content[0].content;
    values.forEach(function (value) {
        var data;
        if (typeof value !== 'function') {
            data = leafLevel.deepInputProperty(value, "");
        } else {
            data = value;
        }

        var element = {
            key: "td",
            text: data
        };
        valueTarget.push(element);
    });
    return result;
};

var alllergiesTextHeaders = ["Substance", "Overall Severity", "Reaction", "Reaction Severity", "Status"];
var allergiesTextRow = [
    leafLevel.deepInputProperty("observation.allergen.name", ""),
    leafLevel.deepInputProperty("observation.severity.code.name", ""),
    leafLevel.deepInputProperty("observation.reactions.0.reaction.name", ""),
    leafLevel.deepInputProperty("observation.reactions.0.severity.code.name", ""),
    leafLevel.deepInputProperty("observation.status.name", "")
];

exports.allergiesSectionEntriesRequired = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.6"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.6.1"),
            fieldLevel.templateCode("AllergiesSection"),
            fieldLevel.templateTitle("AllergiesSection"),
            getText('allergies', alllergiesTextHeaders, allergiesTextRow), {
                key: "entry",
                attributes: {
                    "typeCode": "DRIV"
                },
                content: [
                    [entryLevel.allergyProblemAct, required]
                ],
                dataKey: "allergies",
                required: true
            }
        ]
    }]
};

var medicationsTextHeaders = ["Medication Class", "# fills", "Last fill date"];
var medicationsTextRow = [ // Name, did not find class in the medication blue-button-data
    function (input) {
        var value = bbuo.deepValue(input, 'product.product.name');
        if (!bbuo.exists(value)) {
            value = bbuo.deepValue(input, 'product.unencoded_name');
        }
        if (!bbuo.exists(value)) {
            return "";
        } else {
            return value;
        }
    },
    leafLevel.deepInputProperty("supply.repeatNumber", ""),
    function () {
        return nda;
    }
];

exports.medicationsSectionEntriesRequired = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.1"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.1.1"),
            fieldLevel.templateCode("MedicationsSection"),
            fieldLevel.templateTitle("MedicationsSection"),
            getText('medications', medicationsTextHeaders, medicationsTextRow), {
                key: "entry",
                attributes: {
                    "typeCode": "DRIV"
                },
                content: [
                    [entryLevel.medicationActivity, required]
                ],
                dataKey: "medications",
                required: true
            }
        ]
    }]
};

exports.problemsSectionEntriesRequired = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.5"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.5.1"),
            fieldLevel.templateCode("ProblemSection"),
            fieldLevel.templateTitle("ProblemSection"), {
                key: "text",
                text: ""
            }, {
                key: "entry",
                attributes: {
                    "typeCode": "DRIV"
                },
                content: [
                    [entryLevel.problemConcernAct, required]
                ],
                dataKey: "problems",
                required: true
            }
        ]
    }]
};

exports.proceduresSectionEntriesRequired = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.7"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.7.1"),
            fieldLevel.templateCode("ProceduresSection"),
            fieldLevel.templateTitle("ProceduresSection"), {
                key: "text",
                text: ""
            }, {
                key: "entry",
                attributes: {
                    "typeCode": function (input) {
                        return input.procedure_type === "procedure" ? "DRIV" : null;
                    }
                },
                content: [
                    entryLevel.procedureActivityAct,
                    entryLevel.procedureActivityProcedure,
                    entryLevel.procedureActivityObservation
                ],
                dataKey: "procedures"
            }
        ]
    }],
    notImplemented: [
        "entry required"
    ]
};

exports.resultsSectionEntriesRequired = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.3"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.3.1"),
            fieldLevel.templateCode("ResultsSection"),
            fieldLevel.templateTitle("ResultsSection"), {
                key: "text",
                content: [{
                    key: "table",
                    content: [{
                        key: "thead",
                        content: [{
                            key: "th",
                            attributes: {
                                colspan: "7"
                            },
                            text: "Laboratory Results"
                        }, {
                            key: "tr",
                            content: [{
                                key: "th",
                                text: leafLevel.input,
                                dataTransform: function () {
                                    return ['Test', 'Result', 'Units', 'Ref low', 'Ref high', 'Date', 'Source'];
                                }
                            }]
                        }]
                    }, {
                        key: "tbody",
                        content: [{
                            key: "tr",
                            content: [{
                                key: "td",
                                attributes: {
                                    colspan: "7"
                                },
                                text: leafLevel.deepInputProperty('result_set.name', nda),
                            }]
                        }, {
                            key: "tr",
                            content: [{
                                key: "td",
                                text: leafLevel.deepInputProperty("result.name", nda)
                            }, {
                                key: "td",
                                text: leafLevel.deepInputProperty("value", nda)
                            }, {
                                key: "td",
                                text: leafLevel.deepInputProperty("unit", nda)
                            }, {
                                key: "td",
                                text: leafLevel.deepInputProperty("reference_range.low", nda)
                            }, {
                                key: "td",
                                text: leafLevel.deepInputProperty("reference_range.high", nda)
                            }, {
                                key: "td",
                                text: leafLevel.deepInputDate("date_time.point", nda),
                            }, {
                                key: "td",
                                text: nda
                            }],
                            dataKey: 'results'
                        }],
                        dataKey: 'results'
                    }]
                }]
            }, {
                key: "entry",
                attributes: {
                    typeCode: "DRIV"
                },
                content: [
                    [entryLevel.resultOrganizer, required]
                ],
                dataKey: "results",
                required: true
            }
        ]
    }]
};

exports.encountersSectionEntriesOptional = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.22"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.22.1"),
            fieldLevel.templateCode("EncountersSection"),
            fieldLevel.templateTitle("EncountersSection"), {
                key: "text",
                content: [{
                    key: "table",
                    content: [{
                        key: "caption",
                        text: "Emergency Room Visits"
                    }, {
                        key: "thead",
                        content: [{
                            key: "tr",
                            content: [{
                                key: "th",
                                text: leafLevel.input,
                                dataTransform: function () {
                                    return ['Facility', 'Date of Service', 'Diagnosis/Complaint'];
                                }
                            }]
                        }]
                    }, {
                        key: "tbody",
                        content: [{
                            key: "tr",
                            content: [{
                                key: "td",
                                text: leafLevel.deepInputProperty("locations.0.name", nda)
                            }, {
                                key: "td",
                                text: function (input) {
                                    var value = bbuo.deepValue(input, "date_time.point");
                                    if (value) {
                                        value = bbud.modelToDate({
                                            date: value.date,
                                            precision: value.precision // workaround a bug in bbud.  Changes precision.
                                        });
                                        if (value) {
                                            var vps = value.split('-');
                                            if (vps.length === 3) {
                                                return [vps[1], vps[2], vps[0]].join('/');
                                            }
                                        }
                                    }
                                    return nda;
                                }
                            }, {
                                key: "td",
                                text: leafLevel.deepInputProperty("findings.0.value.name", nda)
                            }],
                        }],
                        dataKey: 'encounters'
                    }]
                }]
            }, {
                key: "entry",
                attributes: {
                    "typeCode": "DRIV"
                },
                content: [
                    [entryLevel.encounterActivities, required]
                ],
                dataKey: "encounters"
            }
        ]
    }]
};

exports.immunizationsSectionEntriesOptional = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.2"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.2.1"),
            fieldLevel.templateCode("ImmunizationsSection"),
            fieldLevel.templateTitle("ImmunizationsSection"), {
                key: "text",
                text: ""
            }, {
                key: "entry",
                attributes: {
                    "typeCode": "DRIV"
                },
                content: [
                    [entryLevel.immunizationActivity, required]
                ],
                dataKey: "immunizations"
            }
        ]
    }]
};

exports.payersSection = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.18"),
            fieldLevel.templateCode("PayersSection"),
            fieldLevel.templateTitle("PayersSection"), {
                key: "text",
                text: ""
            }, {
                key: "entry",
                attributes: {
                    typeCode: "DRIV"
                },
                content: [
                    [entryLevel.coverageActivity, required]
                ],
                dataKey: "payers"
            }
        ]
    }]
};

exports.planOfCareSection = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.10"),
            fieldLevel.templateCode("PlanOfCareSection"),
            fieldLevel.templateTitle("PlanOfCareSection"), {
                key: "text",
                text: ""
            }, {
                key: "entry",
                attributes: {
                    "typeCode": function (input) {
                        return input.type === "observation" ? "DRIV" : null;
                    }
                },
                content: [
                    entryLevel.planOfCareActivityAct,
                    entryLevel.planOfCareActivityObservation,
                    entryLevel.planOfCareActivityProcedure,
                    entryLevel.planOfCareActivityEncounter,
                    entryLevel.planOfCareActivitySubstanceAdministration,
                    entryLevel.planOfCareActivitySupply,
                    entryLevel.planOfCareActivityInstructions
                ],
                dataKey: "plan_of_care"
            }
        ]
    }]
};

exports.socialHistorySection = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.17"),
            fieldLevel.templateCode("SocialHistorySection"),
            fieldLevel.templateTitle("SocialHistorySection"), {
                key: "text",
                text: ""
            }, {
                key: "entry",
                attributes: {
                    typeCode: "DRIV"
                },
                content: [
                    entryLevel.smokingStatusObservation,
                    entryLevel.socialHistoryObservation
                ],
                dataKey: "social_history"
            }
        ]
    }],
    notImplemented: [
        "pregnancyObservation",
        "tobaccoUse"
    ]
};

exports.vitalSignsSectionEntriesOptional = {
    key: "component",
    content: [{
        key: "section",
        content: [
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.4"),
            fieldLevel.templateId("2.16.840.1.113883.10.20.22.2.4.1"),
            fieldLevel.templateCode("VitalSignsSection"),
            fieldLevel.templateTitle("VitalSignsSection"), {
                key: "text",
                text: ""
            }, {
                key: "entry",
                attributes: {
                    typeCode: "DRIV"
                },
                content: [
                    [entryLevel.vitalSignsOrganizer, required]
                ],
                dataKey: "vitals"
            }
        ]
    }]
};

},{"./contentModifier":4,"./entryLevel":10,"./fieldLevel":20,"./leafLevel":22,"blue-button-util":35}],24:[function(require,module,exports){
"use strict";

var moment = require("moment");
var bbm = require("blue-button-meta");

var css = bbm.code_systems;

exports.codeFromName = function (OID) {
    return function (input) {
        var cs = css.find(OID);
        var code = cs ? cs.displayNameCode(input) : undefined;
        var systemInfo = cs.systemId(OID);
        return {
            "displayName": input,
            "code": code,
            "codeSystem": systemInfo.codeSystem,
            "codeSystemName": systemInfo.codeSystemName
        };
    };
};

exports.code = function (input) {
    var result = {};
    if (input.code) {
        result.code = input.code;
    }

    if (input.name) {
        result.displayName = input.name;
    }

    var code_system = input.code_system || (input.code_system_name && css.findFromName(input.code_system_name));
    if (code_system) {
        result.codeSystem = code_system;
    }

    if (input.code_system_name) {
        result.codeSystemName = input.code_system_name;
    }

    return result;
};

var precisionToFormat = {
    year: 'YYYY',
    month: 'YYYYMM',
    day: 'YYYYMMDD',
    hour: 'YYYYMMDDHH',
    minute: 'YYYYMMDDHHMM',
    second: 'YYYYMMDDHHmmssZZ',
    subsecond: 'YYYYMMDDHHmmss.SSSZZ'
};

exports.time = function (input) {
    var m = moment.parseZone(input.date);
    var formatSpec = precisionToFormat[input.precision];
    var result = m.format(formatSpec);
    return result;
};

var acronymize = exports.acronymize = function (string) {
    var ret = string.split(" ");
    var fL = ret[0].slice(0, 1);
    var lL = ret[1].slice(0, 1);
    fL = fL.toUpperCase();
    lL = lL.toUpperCase();
    ret = fL + lL;
    if (ret === "PH") {
        ret = "HP";
    }
    if (ret === "HA") {
        ret = "H";
    }
    return ret;
};

exports.telecom = function (input) {
    var transformPhones = function (input) {
        var phones = input.phone;
        if (phones) {
            return phones.reduce(function (r, phone) {
                if (phone && phone.number) {
                    var attrs = {
                        value: "tel:" + phone.number
                    };
                    if (phone.type) {
                        attrs.use = acronymize(phone.type);
                    }
                    r.push(attrs);
                }
                return r;
            }, []);
        } else {
            return [];
        }
    };

    var transformEmails = function (input) {
        var emails = input.email;
        if (emails) {
            return emails.reduce(function (r, email) {
                if (email && email.address) {
                    var attrs = {
                        value: "mailto:" + email.address
                    };
                    if (email.type) {
                        attrs.use = acronymize(email.type);
                    }
                    r.push(attrs);
                }
                return r;
            }, []);
        } else {
            return [];
        }
    };

    var result = [].concat(transformPhones(input), transformEmails(input));
    return result.length === 0 ? null : result;
};

var nameSingle = function (input) {
    var given = null;
    if (input.first) {
        given = [input.first];
        if (input.middle && input.middle[0]) {
            given.push(input.middle[0]);
        }
    }
    return {
        prefix: input.prefix,
        given: given,
        family: input.last,
        suffix: input.suffix
    };
};

exports.name = function (input) {
    if (Array.isArray(input)) {
        return input.map(function (e) {
            return nameSingle(e);
        });
    } else {
        return nameSingle(input);
    }
};

},{"blue-button-meta":25,"moment":80}],25:[function(require,module,exports){
var CCDA = require("./lib/CCDA/index.js");

//CCDA metadata stuff
var meta = {};
meta.CCDA = CCDA;

meta.supported_sections = [
    'allergies',
    'procedures',
    'immunizations',
    'medications',
    'encounters',
    'vitals',
    'results',
    'social_history',
    'demographics',
    'problems',
    'insurance',
    'claims',
    'plan_of_care',
    'payers',
    'providers'
];

meta.code_systems = require("./lib/code-systems");

module.exports = exports = meta;

},{"./lib/CCDA/index.js":28,"./lib/code-systems":33}],26:[function(require,module,exports){
var clinicalstatements = {
    "AdmissionMedication": "2.16.840.1.113883.10.20.22.4.36",
    "AdvanceDirectiveObservation": "2.16.840.1.113883.10.20.22.4.48",
    "AgeObservation": "2.16.840.1.113883.10.20.22.4.31",
    "AllergyObservation": "2.16.840.1.113883.10.20.22.4.7",
    "AllergyProblemAct": "2.16.840.1.113883.10.20.22.4.30",
    "AllergyStatusObservation": "2.16.840.1.113883.10.20.22.4.28",
    "AssessmentScaleObservation": "2.16.840.1.113883.10.20.22.4.69",
    "AssessmentScaleSupportingObservation": "2.16.840.1.113883.10.20.22.4.86",
    "AuthorizationActivity": "2.16.840.1.113883.10.20.1.19",
    "BoundaryObservation": "2.16.840.1.113883.10.20.6.2.11",
    "CaregiverCharacteristics": "2.16.840.1.113883.10.20.22.4.72",
    "CodeObservations": "2.16.840.1.113883.10.20.6.2.13",
    "CognitiveStatusProblemObservation": "2.16.840.1.113883.10.20.22.4.73",
    "CognitiveStatusResultObservation": "2.16.840.1.113883.10.20.22.4.74",
    "CognitiveStatusResultOrganizer": "2.16.840.1.113883.10.20.22.4.75",
    "CommentActivity": "2.16.840.1.113883.10.20.22.4.64",
    "CoverageActivity": "2.16.840.1.113883.10.20.22.4.60",
    "DeceasedObservation": "2.16.840.1.113883.10.20.22.4.79",
    "DischargeMedication": "2.16.840.1.113883.10.20.22.4.35",
    "EncounterActivities": "2.16.840.1.113883.10.20.22.4.49",
    "EncounterDiagnosis": "2.16.840.1.113883.10.20.22.4.80",
    "EstimatedDateOfDelivery": "2.16.840.1.113883.10.20.15.3.1",
    "FamilyHistoryDeathObservation": "2.16.840.1.113883.10.20.22.4.47",
    "FamilyHistoryObservation": "2.16.840.1.113883.10.20.22.4.46",
    "FamilyHistoryOrganizer": "2.16.840.1.113883.10.20.22.4.45",
    "FunctionalStatusProblemObservation": "2.16.840.1.113883.10.20.22.4.68",
    "FunctionalStatusResultObservation": "2.16.840.1.113883.10.20.22.4.67",
    "FunctionalStatusResultOrganizer": "2.16.840.1.113883.10.20.22.4.66",
    "HealthStatusObservation": "2.16.840.1.113883.10.20.22.4.5",
    "HighestPressureUlcerStage": "2.16.840.1.113883.10.20.22.4.77",
    "HospitalAdmissionDiagnosis": "2.16.840.1.113883.10.20.22.4.34",
    "HospitalDischargeDiagnosis": "2.16.840.1.113883.10.20.22.4.33",
    "ImmunizationActivity": "2.16.840.1.113883.10.20.22.4.52",
    "ImmunizationRefusalReason": "2.16.840.1.113883.10.20.22.4.53",
    "Indication": "2.16.840.1.113883.10.20.22.4.19",
    "Instructions": "2.16.840.1.113883.10.20.22.4.20",
    "MedicationActivity": "2.16.840.1.113883.10.20.22.4.16",
    "MedicationDispense": "2.16.840.1.113883.10.20.22.4.18",
    "MedicationSupplyOrder": "2.16.840.1.113883.10.20.22.4.17",
    "MedicationUseNoneKnown": "2.16.840.1.113883.10.20.22.4.29",
    "NonMedicinalSupplyActivity": "2.16.840.1.113883.10.20.22.4.50",
    "NumberOfPressureUlcersObservation": "2.16.840.1.113883.10.20.22.4.76",
    "PlanOfCareActivityAct": "2.16.840.1.113883.10.20.22.4.39",
    "PlanOfCareActivityEncounter": "2.16.840.1.113883.10.20.22.4.40",
    "PlanOfCareActivityObservation": "2.16.840.1.113883.10.20.22.4.44",
    "PlanOfCareActivityProcedure": "2.16.840.1.113883.10.20.22.4.41",
    "PlanOfCareActivitySubstanceAdministration": "2.16.840.1.113883.10.20.22.4.42",
    "PlanOfCareActivitySupply": "2.16.840.1.113883.10.20.22.4.43",
    "PolicyActivity": "2.16.840.1.113883.10.20.22.4.61",
    "PostprocedureDiagnosis": "2.16.840.1.113883.10.20.22.4.51",
    "PregnancyObservation": "2.16.840.1.113883.10.20.15.3.8",
    "PreoperativeDiagnosis": "2.16.840.1.113883.10.20.22.4.65",
    "PressureUlcerObservation": "2.16.840.1.113883.10.20.22.4.70",
    "ProblemConcernAct": "2.16.840.1.113883.10.20.22.4.3",
    "ProblemObservation": "2.16.840.1.113883.10.20.22.4.4",
    "ProblemStatus": "2.16.840.1.113883.10.20.22.4.6",
    "ProcedureActivityAct": "2.16.840.1.113883.10.20.22.4.12",
    "ProcedureActivityObservation": "2.16.840.1.113883.10.20.22.4.13",
    "ProcedureActivityProcedure": "2.16.840.1.113883.10.20.22.4.14",
    "ProcedureContext": "2.16.840.1.113883.10.20.6.2.5",
    "PurposeofReferenceObservation": "2.16.840.1.113883.10.20.6.2.9",
    "QuantityMeasurementObservation": "2.16.840.1.113883.10.20.6.2.14",
    "ReactionObservation": "2.16.840.1.113883.10.20.22.4.9",
    "ReferencedFramesObservation": "2.16.840.1.113883.10.20.6.2.10",
    "ResultObservation": "2.16.840.1.113883.10.20.22.4.2",
    "ResultOrganizer": "2.16.840.1.113883.10.20.22.4.1",
    "SeriesAct": "2.16.840.1.113883.10.20.22.4.63",
    "SeverityObservation": "2.16.840.1.113883.10.20.22.4.8",
    "SmokingStatusObservation": "2.16.840.1.113883.10.20.22.4.78",
    "SocialHistoryObservation": "2.16.840.1.113883.10.20.22.4.38",
    "SOPInstanceObservation": "2.16.840.1.113883.10.20.6.2.8",
    "StudyAct": "2.16.840.1.113883.10.20.6.2.6",
    "TextObservation": "2.16.840.1.113883.10.20.6.2.12",
    "TobaccoUse": "2.16.840.1.113883.10.20.22.4.85",
    "VitalSignObservation": "2.16.840.1.113883.10.20.22.4.27",
    "VitalSignsOrganizer": "2.16.840.1.113883.10.20.22.4.26"
};

var clinicalstatements_r1 = {
    "AdvanceDirectiveObservation": "2.16.840.1.113883.10.20.1.17",
    "AlertObservation": "2.16.840.1.113883.10.20.1.18",
    "AuthorizationActivity": "2.16.840.1.113883.10.20.1.19",
    "CoverageActivity": "2.16.840.1.113883.10.20.1.20",
    "EncounterActivity": "2.16.840.1.113883.10.20.1.21",
    "FamilyHistoryObservation": "2.16.840.1.113883.10.20.1.22",
    "FamilyHistoryOrganizer": "2.16.840.1.113883.10.20.1.23",
    "MedicationActivity": "2.16.840.1.113883.10.20.1.24",
    "PlanOfCareActivity": "2.16.840.1.113883.10.20.1.25",
    "PolicyActivity": "2.16.840.1.113883.10.20.1.26",
    "ProblemAct": "2.16.840.1.113883.10.20.1.27",
    "ProblemObservation": "2.16.840.1.113883.10.20.1.28",
    "ProcedureActivity": "2.16.840.1.113883.10.20.1.29",
    "PurposeActivity": "2.16.840.1.113883.10.20.1.30",
    "ResultObservation": "2.16.840.1.113883.10.20.1.31",
    "ResultOrganizer": "2.16.840.1.113883.10.20.1.32",
    "SocialHistoryObservation": "2.16.840.1.113883.10.20.1.33",
    "SupplyActivity": "2.16.840.1.113883.10.20.1.34",
    "VitalSignObservation": "2.16.840.1.113883.10.20.1.31",
    "Indication": "2.16.840.1.113883.10.20.22.4.19",
    "VitalSignsOrganizer": "2.16.840.1.113883.10.20.1.35",
    "AdvanceDirectiveReference": "2.16.840.1.113883.10.20.1.36",
    "AdvanceDirectiveStatusObservation": "2.16.840.1.113883.10.20.1.37",
    "AgeObservation": "2.16.840.1.113883.10.20.1.38",
    "AlertStatusObservation": "2.16.840.1.113883.10.20.1.39",
    "Comment": "2.16.840.1.113883.10.20.1.40",
    "EpisodeObservation": "2.16.840.1.113883.10.20.1.41",
    "FamilyHistoryCauseOfDeathObservation": "2.16.840.1.113883.10.20.1.42",
    "FulfillmentInstruction": "2.16.840.1.113883.10.20.1.43",
    "LocationParticipation": "2.16.840.1.113883.10.20.1.45",
    "MedicationSeriesNumberObservation": "2.16.840.1.113883.10.20.1.46",
    "MedicationStatusObservation": "2.16.840.1.113883.10.20.1.47",
    "PatientAwareness": "2.16.840.1.113883.10.20.1.48",
    "PatientInstruction": "2.16.840.1.113883.10.20.1.49",
    "ProblemHealthstatusObservation": "2.16.840.1.113883.10.20.1.51",
    "ProblemStatusObservation": "2.16.840.1.113883.10.20.1.50",
    "Product": "2.16.840.1.113883.10.20.1.53",
    "ProductInstance": "2.16.840.1.113883.10.20.1.52",
    "ReactionObservation": "2.16.840.1.113883.10.20.1.54",
    "SeverityObservation": "2.16.840.1.113883.10.20.1.55",
    "SocialHistoryStatusObservation": "2.16.840.1.113883.10.20.1.56",
    "StatusObservation": "2.16.840.1.113883.10.20.1.57",
    "StatusOfFunctionalStatusObservation": "2.16.840.1.113883.10.20.1.44",
    "VerificationOfAnAdvanceDirectiveObservation": "2.16.840.1.113883.10.20.1.58"
};

module.exports.clinicalstatements = clinicalstatements;
module.exports.clinicalstatements_r1 = clinicalstatements_r1;

},{}],27:[function(require,module,exports){
var codeSystems = {
    "LOINC": ["2.16.840.1.113883.6.1", "8716-3"],
    "SNOMED CT": ["2.16.840.1.113883.6.96", "46680005"],
    "RXNORM": ["2.16.840.1.113883.6.88"],
    "ActCode": ["2.16.840.1.113883.5.4"],
    "CPT-4": ["2.16.840.1.113883.6.12"],
    "CVX": ["2.16.840.1.113883.12.292"],
    "HL7 Role": ["2.16.840.1.113883.5.111"],
    "HL7 RoleCode": ["2.16.840.1.113883.5.110"],
    "UNII": ["2.16.840.1.113883.4.9"],
    "Observation Interpretation": ["2.16.840.1.113883.1.11.78"],
    "CPT": ["2.16.840.1.113883.6.12"],
    "HealthcareServiceLocation": ["2.16.840.1.113883.6.259"],
    "HL7 Result Interpretation": ["2.16.840.1.113883.5.83"],
    "Act Reason": ["2.16.840.1.113883.5.8"],
    "Medication Route FDA": ["2.16.840.1.113883.3.26.1.1"],
    "Body Site Value Set": ["2.16.840.1.113883.3.88.12.3221.8.9"],
    "MediSpan DDID": ["2.16.840.1.113883.6.253"],
    "ActPriority": ["2.16.840.1.113883.5.7"],
    "InsuranceType Code": ["2.16.840.1.113883.6.255.1336"],
    "ICD-9-CM": ["2.16.840.1.113883.6.103"]
};

var sections_entries_codes = {
    "codes": {
        "AdvanceDirectivesSectionEntriesOptional": {
            "code": "42348-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Advance Directives"
        },
        "AdvanceDirectivesSection": {
            "code": "42348-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Advance Directives"
        },
        "AllergiesSectionEntriesOptional": {
            "code": "48765-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Allergies, adverse reactions, alerts"
        },
        "AllergiesSection": {
            "code": "48765-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Allergies, adverse reactions, alerts"
        },
        "AnesthesiaSection": {
            "code": "59774-0",
            "code_system": "",
            "code_system_name": "",
            "name": "Anesthesia"
        },
        "AssessmentAndPlanSection": {
            "code": "51847-2",
            "code_system": "",
            "code_system_name": "",
            "name": "Assessment and Plan"
        },
        "AssessmentSection": {
            "code": "51848-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Assessments"
        },
        "ChiefComplaintAndReasonForVisitSection": {
            "code": "46239-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Chief Complaint and Reason for Visit"
        },
        "ChiefComplaintSection": {
            "code": "10154-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Chief Complaint"
        },
        "undefined": "",
        "ComplicationsSection": {
            "code": "55109-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Complications"
        },
        "DICOMObjectCatalogSection": {
            "code": "121181",
            "code_system": "1.2.840.10008.2.16.4",
            "code_system_name": "DCM",
            "name": "Dicom Object Catalog"
        },
        "DischargeDietSection": {
            "code": "42344-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Discharge Diet"
        },
        "EncountersSectionEntriesOptional": {
            "code": "46240-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Encounters"
        },
        "EncountersSection": {
            "code": "46240-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Encounters"
        },
        "FamilyHistorySection": {
            "code": "10157-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Family History"
        },
        "FindingsSection": "",
        "FunctionalStatusSection": {
            "code": "47420-5",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Functional Status"
        },
        "GeneralStatusSection": {
            "code": "10210-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "General Status"
        },
        "HistoryOfPastIllnessSection": {
            "code": "11348-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "History of Past Illness"
        },
        "HistoryOfPresentIllnessSection": {
            "code": "10164-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "History Of Present Illness Section"
        },
        "HospitalAdmissionDiagnosisSection": {
            "code": "46241-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Admission Diagnosis"
        },
        "HospitalAdmissionMedicationsSectionEntriesOptional": {
            "code": "42346-7",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Medications on Admission"
        },
        "HospitalConsultationsSection": {
            "code": "18841-7",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Consultations Section"
        },
        "HospitalCourseSection": {
            "code": "8648-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Course"
        },
        "HospitalDischargeDiagnosisSection": {
            "code": "11535-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Discharge Diagnosis"
        },
        "HospitalDischargeInstructionsSection": {
            "code": "8653-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Discharge Instructions"
        },
        "HospitalDischargeMedicationsSectionEntriesOptional": {
            "code": "10183-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Discharge Medications"
        },
        "HospitalDischargePhysicalSection": {
            "code": "10184-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Discharge Physical"
        },
        "HospitalDischargeStudiesSummarySection": {
            "code": "11493-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital Discharge Studies Summary"
        },
        "ImmunizationsSectionEntriesOptional": {
            "code": "11369-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Immunizations"
        },
        "ImmunizationsSection": {
            "code": "11369-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Immunizations"
        },
        "InstructionsSection": {
            "code": "69730-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Instructions"
        },
        "InterventionsSection": {
            "code": "62387-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Interventions Provided"
        },
        "MedicalHistorySection": {
            "code": "11329-0",
            "code_system": "",
            "code_system_name": "",
            "name": "Medical"
        },
        "MedicalEquipmentSection": {
            "code": "46264-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Medical Equipment"
        },
        "MedicationsAdministeredSection": {
            "code": "29549-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Medications Administered"
        },
        "MedicationsSectionEntriesOptional": {
            "code": "10160-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "History of medication use"
        },
        "MedicationsSection": {
            "code": "10160-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "History of medication use"
        },
        "ObjectiveSection": {
            "code": "61149-1",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Objective"
        },
        "OperativeNoteFluidSection": {
            "code": "10216-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Operative Note Fluids"
        },
        "OperativeNoteSurgicalProcedureSection": {
            "code": "10223-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Operative Note Surgical Procedure"
        },
        "PayersSection": {
            "code": "48768-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Payers"
        },
        "PhysicalExamSection": {
            "code": "29545-1",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Physical Findings"
        },
        "PlanOfCareSection": {
            "code": "18776-5",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Plan of Care"
        },
        "PlannedProcedureSection": {
            "code": "59772-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Planned Procedure"
        },
        "PostoperativeDiagnosisSection": {
            "code": "10218-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Postoperative Diagnosis"
        },
        "PostprocedureDiagnosisSection": {
            "code": "59769-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Postprocedure Diagnosis"
        },
        "PreoperativeDiagnosisSection": {
            "code": "10219-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Preoperative Diagnosis"
        },
        "ProblemSectionEntriesOptional": {
            "code": "11450-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Problem List"
        },
        "ProblemSection": {
            "code": "11450-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Problem List"
        },
        "ProcedureDescriptionSection": {
            "code": "29554-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Procedure Description"
        },
        "ProcedureDispositionSection": {
            "code": "59775-7",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Procedure Disposition"
        },
        "ProcedureEstimatedBloodLossSection": {
            "code": "59770-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Procedure Estimated Blood Loss"
        },
        "ProcedureFindingsSection": {
            "code": "59776-5",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Procedure Findings"
        },
        "ProcedureImplantsSection": {
            "code": "59771-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Procedure Implants"
        },
        "ProcedureIndicationsSection": {
            "code": "59768-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Procedure Indications"
        },
        "ProcedureSpecimensTakenSection": {
            "code": "59773-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Procedure Specimens Taken"
        },
        "ProceduresSectionEntriesOptional": {
            "code": "47519-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "History of Procedures"
        },
        "ProceduresSection": {
            "code": "47519-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "History of Procedures"
        },
        "ReasonForReferralSection": {
            "code": "42349-1",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Reason for Referral"
        },
        "ReasonForVisitSection": {
            "code": "29299-5",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Reason for Visit"
        },
        "ResultsSectionEntriesOptional": {
            "code": "30954-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Relevant diagnostic tests and/or laboratory data"
        },
        "ResultsSection": {
            "code": "30954-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Relevant diagnostic tests and/or laboratory data"
        },
        "ReviewOfSystemsSection": {
            "code": "10187-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Review of Systems"
        },
        "SocialHistorySection": {
            "code": "29762-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Social History"
        },
        "SubjectiveSection": {
            "code": "61150-9",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Subjective"
        },
        "SurgicalDrainsSection": {
            "code": "11537-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Surgical Drains"
        },
        "VitalSignsSectionEntriesOptional": {
            "code": "8716-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Vital Signs"
        },
        "VitalSignsSection": {
            "code": "8716-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Vital Signs"
        },
        "AdmissionMedication": {
            "code": "42346-7",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Medications on Admission"
        },
        "AdvanceDirectiveObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "AgeObservation": {
            "code": "445518008",
            "code_system": "2.16.840.1.113883.6.96",
            "code_system_name": "SNOMED-CT",
            "name": "Age At Onset"
        },
        "AllergyObservation": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "AllergyProblemAct": {
            "code": "48765-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Allergies, adverse reactions, alerts"
        },
        "AllergyStatusObservation": {
            "code": "33999-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Status"
        },
        "AssessmentScaleObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "AssessmentScaleSupportingObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "AuthorizationActivity": "",
        "BoundaryObservation": {
            "code": "113036",
            "code_system": "1.2.840.10008.2.16.4",
            "code_system_name": "DCM",
            "name": "Frames for Display"
        },
        "CaregiverCharacteristics": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "CodeObservations": "",
        "CognitiveStatusProblemObservation": {
            "code": "373930000",
            "code_system": "2.16.840.1.113883.6.96",
            "code_system_name": "SNOMED-CT",
            "name": "Cognitive function finding"
        },
        "CognitiveStatusResultObservation": {
            "code": "373930000",
            "code_system": "2.16.840.1.113883.6.96",
            "code_system_name": "SNOMED-CT",
            "name": "Cognitive function finding"
        },
        "CognitiveStatusResultOrganizer": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "CommentActivity": {
            "code": "48767-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Annotation Comment"
        },
        "CoverageActivity": {
            "code": "48768-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Payment sources"
        },
        "DeceasedObservation": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "DischargeMedication": {
            "code": "10183-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Discharge medication"
        },
        "EncounterActivities": "",
        "EncounterDiagnosis": {
            "code": "29308-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Diagnosis"
        },
        "EstimatedDateOfDelivery": {
            "code": "11778-8",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Estimated date of delivery"
        },
        "FamilyHistoryDeathObservation": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "FamilyHistoryObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "FamilyHistoryOrganizer": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "FunctionalStatusProblemObservation": {
            "code": "248536006",
            "code_system": "2.16.840.1.113883.6.96",
            "code_system_name": "SNOMED-CT",
            "name": "finding of functional performance and activity"
        },
        "FunctionalStatusResultObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "FunctionalStatusResultOrganizer": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "HealthStatusObservation": {
            "code": "11323-3",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Health status"
        },
        "HighestPressureUlcerStage": {
            "code": "420905001",
            "code_system": "2.16.840.1.113883.6.96",
            "code_system_name": "SNOMED-CT",
            "name": "Highest Pressure Ulcer Stage"
        },
        "HospitalAdmissionDiagnosis": {
            "code": "46241-6",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Admission diagnosis"
        },
        "HospitalDischargeDiagnosis": {
            "code": "11535-2",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Hospital discharge diagnosis"
        },
        "ImmunizationActivity": "",
        "ImmunizationRefusalReason": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "Indication": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "Instructions": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "MedicationActivity": "",
        "MedicationDispense": "",
        "MedicationSupplyOrder": "",
        "MedicationUseNoneKnown": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "NonMedicinalSupplyActivity": "",
        "NumberOfPressureUlcersObservation": {
            "code": "2264892003",
            "code_system": "",
            "code_system_name": "",
            "name": "number of pressure ulcers"
        },
        "PlanOfCareActivityAct": "",
        "PlanOfCareActivityEncounter": "",
        "PlanOfCareActivityObservation": "",
        "PlanOfCareActivityProcedure": "",
        "PlanOfCareActivitySubstanceAdministration": "",
        "PlanOfCareActivitySupply": "",
        "PolicyActivity": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "PostprocedureDiagnosis": {
            "code": "59769-0",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Postprocedure diagnosis"
        },
        "PregnancyObservation": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "PreoperativeDiagnosis": {
            "code": "10219-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Preoperative Diagnosis"
        },
        "PressureUlcerObservation": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "ProblemConcernAct": {
            "code": "CONC",
            "code_system": "2.16.840.1.113883.5.6",
            "code_system_name": "HL7ActClass",
            "name": "Concern"
        },
        "ProblemObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "ProblemStatus": {
            "code": "33999-4",
            "code_system": "2.16.840.1.113883.6.1",
            "code_system_name": "LOINC",
            "name": "Status"
        },
        "ProcedureActivityAct": "",
        "ProcedureActivityObservation": "",
        "ProcedureActivityProcedure": "",
        "ProcedureContext": "",
        "PurposeofReferenceObservation": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "QuantityMeasurementObservation": "",
        "ReactionObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "ReferencedFramesObservation": {
            "code": "121190",
            "code_system": "1.2.840.10008.2.16.4",
            "code_system_name": "DCM",
            "name": "Referenced Frames"
        },
        "ResultObservation": "",
        "ResultOrganizer": "",
        "SeriesAct": {
            "code": "113015",
            "code_system": "1.2.840.10008.2.16.4",
            "code_system_name": "DCM",
            "name": "Series Act"
        },
        "SeverityObservation": {
            "code": "SEV",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Severity Observation"
        },
        "SmokingStatusObservation": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "SocialHistoryObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "SOPInstanceObservation": "",
        "StudyAct": {
            "code": "113014",
            "code_system": "1.2.840.10008.2.16.4",
            "code_system_name": "DCM",
            "name": "Study Act"
        },
        "TextObservation": "",
        "TobaccoUse": {
            "code": "ASSERTION",
            "code_system": "2.16.840.1.113883.5.4",
            "code_system_name": "ActCode",
            "name": "Assertion"
        },
        "VitalSignObservation": {
            "code": "completed",
            "code_system": "2.16.840.1.113883.5.14",
            "code_system_name": "ActStatus",
            "name": "Completed"
        },
        "VitalSignsOrganizer": {
            "code": "46680005",
            "code_system": "2.16.840.1.113883.6.96",
            "code_system_name": "SNOMED-CT",
            "name": "Vital signs"
        }
    }
};
module.exports.codeSystems = codeSystems;
module.exports.sections_entries_codes = sections_entries_codes;

},{}],28:[function(require,module,exports){
var templates = require("./templates.js");
var sections = require("./sections.js");
var statements = require("./clinicalstatements.js");

var templatesconstraints = require("./templates-constraints.js");
var sectionsconstraints = require("./sections-constraints.js");
var codeSystems = require("./code-systems.js");

//General Header Constraints
var CCDA = {
    "document": {
        "name": "CCDA",
        "templateId": "2.16.840.1.113883.10.20.22.1.1"
    },
    "templates": templates,
    "sections": sections.sections,
    "sections_r1": sections.sections_r1,
    "statements": statements.clinicalstatements,
    "statements_r1": statements.clinicalstatements_r1,
    "constraints": {
        "sections": sectionsconstraints,
        "templates": templatesconstraints
    },
    "codeSystems": codeSystems.codeSystems,
    "sections_entries_codes": codeSystems.sections_entries_codes

    /*
		,
    //DOCUMENT-LEVEL TEMPLATES
    "templates":[
		{
			"name":"Consultation Note",
			"templateId":"2.16.840.1.113883.10.20.22.1.4"
		},
		{
			"name":"Continuity Of Care Document",
			"templateId":"2.16.840.1.113883.10.20.22.1.2"
		},
		{
			"name":"Diagnostic Imaging Report",
			"templateId":"2.16.840.1.113883.10.20.22.1.5"
		},
		{
			"name":"Discharge Summary",
			"templateId":"2.16.840.1.113883.10.20.22.1.8"
		},
		{
			"name":"History And Physical Note",
			"templateId":"2.16.840.1.113883.10.20.22.1.3"
		},
		{
			"name":"Operative Note",
			"templateId":"2.16.840.1.113883.10.20.22.1.7"
		},
		{
			"name":"Procedure Note",
			"templateId":"2.16.840.1.113883.10.20.22.1.6"
		},
		{
			"name":"Progress Note",
			"templateId":"2.16.840.1.113883.10.20.22.1.9"
		},
		{
			"name":"Unstructured Document",
			"templateId":"2.16.840.1.113883.10.20.21.1.10"
		},
    ],
    //Sections
    "sections":[
		{"name": "Allergies",
			"templateIds": ['2.16.840.1.113883.10.20.22.2.6', '2.16.840.1.113883.10.20.22.2.6.1']
		},
		{"name": "Encounters",
			"templateIds": ['2.16.840.1.113883.10.20.22.2.22', '2.16.840.1.113883.10.20.22.2.22.1']
		},
		{"name": "Immunizations",
			"templateIds": ["2.16.840.1.113883.10.20.22.2.2", "2.16.840.1.113883.10.20.22.2.2.1"]
		},
		{"name": "Medications",
			"templateIds": ["2.16.840.1.113883.10.20.22.2.1", "2.16.840.1.113883.10.20.22.2.1.1"]
		},
		{"name": "Problems",
			"templateIds": ["2.16.840.1.113883.10.20.22.2.5.1"]
		},
		{"name": "Procedures",
			"templateIds": ['2.16.840.1.113883.10.20.22.2.7', '2.16.840.1.113883.10.20.22.2.7.1']
		},
		{"name": "Results",
			"templateIds": ['2.16.840.1.113883.10.20.22.2.3', '2.16.840.1.113883.10.20.22.2.3.1']
		},
		{"name": "Vital Signs",
			"templateIds": ["2.16.840.1.113883.10.20.22.2.4","2.16.840.1.113883.10.20.22.2.4.1"]
		},
		{"name": "Social History",
			"templateIds": ["2.16.840.1.113883.10.20.22.2.17"]
		}		
    ]
    */
};

//Good source http://cdatools.org/SectionMatrix.html
//and http://cdatools.org/ClinicalStatementMatrix.html

module.exports = exports = CCDA;

},{"./clinicalstatements.js":26,"./code-systems.js":27,"./sections-constraints.js":29,"./sections.js":30,"./templates-constraints.js":31,"./templates.js":32}],29:[function(require,module,exports){
var sectionsconstraints = {
    "VitalSignsSection": {
        "full": {
            "VitalSignsOrganizer": {
                "id": [
                    "7276",
                    "7277"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "VitalSignsOrganizer": [
                "7276",
                "7277"
            ]
        }
    },
    "DICOMObjectCatalogSection": {
        "full": {
            "StudyAct": {
                "id": [
                    "8530",
                    "15458"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "StudyAct": [
                "8530",
                "15458"
            ]
        }
    },
    "PayersSection": {
        "full": {
            "CoverageActivity": {
                "id": [
                    "7959",
                    "8905"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "CoverageActivity": [
                "7959",
                "8905"
            ]
        }
    },
    "HospitalDischargeDiagnosisSection": {
        "full": {
            "HospitalDischargeDiagnosis": {
                "id": [
                    "7984"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "HospitalDischargeDiagnosis": [
                "7984"
            ]
        }
    },
    "SocialHistorySection": {
        "may": {
            "TobaccoUse": [
                "16816",
                "16817"
            ],
            "PregnancyObservation": [
                "9133",
                "9132"
            ],
            "SocialHistoryObservation": [
                "7954",
                "7953"
            ]
        },
        "full": {
            "SmokingStatusObservation": {
                "id": [
                    "14824",
                    "14823"
                ],
                "constraint": "should"
            },
            "TobaccoUse": {
                "id": [
                    "16816",
                    "16817"
                ],
                "constraint": "may"
            },
            "PregnancyObservation": {
                "id": [
                    "9133",
                    "9132"
                ],
                "constraint": "may"
            },
            "SocialHistoryObservation": {
                "id": [
                    "7954",
                    "7953"
                ],
                "constraint": "may"
            }
        },
        "should": {
            "SmokingStatusObservation": [
                "14824",
                "14823"
            ]
        }
    },
    "AssessmentAndPlanSection": {
        "may": {
            "PlanOfCareActivityAct": [
                "8798"
            ]
        },
        "full": {
            "PlanOfCareActivityAct": {
                "id": [
                    "8798"
                ],
                "constraint": "may"
            }
        }
    },
    "ResultsSection": {
        "full": {
            "ResultOrganizer": {
                "id": [
                    "7113",
                    "7112"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "ResultOrganizer": [
                "7113",
                "7112"
            ]
        }
    },
    "HospitalAdmissionMedicationsSectionEntriesOptional": {
        "full": {
            "AdmissionMedication": {
                "id": [
                    "10110",
                    "10102"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "AdmissionMedication": [
                "10110",
                "10102"
            ]
        }
    },
    "AllergiesSection": {
        "full": {
            "AllergyProblemAct": {
                "id": [
                    "7531",
                    "7532"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "AllergyProblemAct": [
                "7531",
                "7532"
            ]
        }
    },
    "ComplicationsSection": {
        "may": {
            "ProblemObservation": [
                "8796",
                "8795"
            ]
        },
        "full": {
            "ProblemObservation": {
                "id": [
                    "8796",
                    "8795"
                ],
                "constraint": "may"
            }
        }
    },
    "AdvanceDirectivesSection": {
        "full": {
            "AdvanceDirectiveObservation": {
                "id": [
                    "8801",
                    "8647"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "AdvanceDirectiveObservation": [
                "8801",
                "8647"
            ]
        }
    },
    "MedicationsSectionEntriesOptional": {
        "full": {
            "MedicationActivity": {
                "id": [
                    "7795",
                    "7573"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "MedicationActivity": [
                "7795",
                "7573"
            ]
        }
    },
    "MedicationsAdministeredSection": {
        "may": {
            "MedicationActivity": [
                "8156"
            ]
        },
        "full": {
            "MedicationActivity": {
                "id": [
                    "8156"
                ],
                "constraint": "may"
            }
        }
    },
    "MedicalEquipmentSection": {
        "full": {
            "NonMedicinalSupplyActivity": {
                "id": [
                    "7948.",
                    "8755"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "NonMedicinalSupplyActivity": [
                "7948.",
                "8755"
            ]
        }
    },
    "MedicationsSection": {
        "full": {
            "MedicationActivity": {
                "id": [
                    "7573",
                    "7572"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "MedicationActivity": [
                "7573",
                "7572"
            ]
        }
    },
    "ImmunizationsSection": {
        "full": {
            "ImmunizationActivity": {
                "id": [
                    "9019",
                    "9020"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "ImmunizationActivity": [
                "9019",
                "9020"
            ]
        }
    },
    "AdvanceDirectivesSectionEntriesOptional": {
        "may": {
            "AdvanceDirectiveObservation": [
                "8800",
                "7957"
            ]
        },
        "full": {
            "AdvanceDirectiveObservation": {
                "id": [
                    "8800",
                    "7957"
                ],
                "constraint": "may"
            }
        }
    },
    "ResultsSectionEntriesOptional": {
        "full": {
            "ResultOrganizer": {
                "id": [
                    "7119",
                    "7120"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "ResultOrganizer": [
                "7119",
                "7120"
            ]
        }
    },
    "AnesthesiaSection": {
        "may": {
            "ProcedureActivityProcedure": [
                "8092"
            ],
            "MedicationActivity": [
                "8094"
            ]
        },
        "full": {
            "ProcedureActivityProcedure": {
                "id": [
                    "8092"
                ],
                "constraint": "may"
            },
            "MedicationActivity": {
                "id": [
                    "8094"
                ],
                "constraint": "may"
            }
        }
    },
    "VitalSignsSectionEntriesOptional": {
        "full": {
            "VitalSignsOrganizer": {
                "id": [
                    "7271",
                    "7272"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "VitalSignsOrganizer": [
                "7271",
                "7272"
            ]
        }
    },
    "ImmunizationsSectionEntriesOptional": {
        "full": {
            "ImmunizationActivity": {
                "id": [
                    "7969",
                    "7970"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "ImmunizationActivity": [
                "7969",
                "7970"
            ]
        }
    },
    "FunctionalStatusSection": {
        "may": {
            "PressureUlcerObservation": [
                "16778",
                "16777"
            ],
            "FunctionalStatusProblemObservation": [
                "14422",
                "14423"
            ],
            "CognitiveStatusResultObservation": [
                "14421",
                "14420"
            ],
            "NumberOfPressureUlcersObservation": [
                "16779",
                "16780"
            ],
            "HighestPressureUlcerStage": [
                "16781",
                "16782"
            ],
            "AssessmentScaleObservation": [
                "14581",
                "14580"
            ],
            "FunctionalStatusResultObservation": [
                "14418",
                "14419"
            ],
            "CognitiveStatusProblemObservation": [
                "14425",
                "14424"
            ],
            "FunctionalStatusResultOrganizer": [
                "14414",
                "14415"
            ],
            "CaregiverCharacteristics": [
                "14426",
                "14427"
            ],
            "CognitiveStatusResultOrganizer": [
                "14416",
                "14417"
            ],
            "NonMedicinalSupplyActivity": [
                "14583",
                "14582"
            ]
        },
        "full": {
            "PressureUlcerObservation": {
                "id": [
                    "16778",
                    "16777"
                ],
                "constraint": "may"
            },
            "FunctionalStatusProblemObservation": {
                "id": [
                    "14422",
                    "14423"
                ],
                "constraint": "may"
            },
            "CognitiveStatusResultObservation": {
                "id": [
                    "14421",
                    "14420"
                ],
                "constraint": "may"
            },
            "NumberOfPressureUlcersObservation": {
                "id": [
                    "16779",
                    "16780"
                ],
                "constraint": "may"
            },
            "HighestPressureUlcerStage": {
                "id": [
                    "16781",
                    "16782"
                ],
                "constraint": "may"
            },
            "AssessmentScaleObservation": {
                "id": [
                    "14581",
                    "14580"
                ],
                "constraint": "may"
            },
            "FunctionalStatusResultObservation": {
                "id": [
                    "14418",
                    "14419"
                ],
                "constraint": "may"
            },
            "CognitiveStatusProblemObservation": {
                "id": [
                    "14425",
                    "14424"
                ],
                "constraint": "may"
            },
            "FunctionalStatusResultOrganizer": {
                "id": [
                    "14414",
                    "14415"
                ],
                "constraint": "may"
            },
            "CaregiverCharacteristics": {
                "id": [
                    "14426",
                    "14427"
                ],
                "constraint": "may"
            },
            "CognitiveStatusResultOrganizer": {
                "id": [
                    "14416",
                    "14417"
                ],
                "constraint": "may"
            },
            "NonMedicinalSupplyActivity": {
                "id": [
                    "14583",
                    "14582"
                ],
                "constraint": "may"
            }
        }
    },
    "PreoperativeDiagnosisSection": {
        "full": {
            "PreoperativeDiagnosis": {
                "id": [
                    "10097",
                    "10096"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "PreoperativeDiagnosis": [
                "10097",
                "10096"
            ]
        }
    },
    "HospitalAdmissionDiagnosisSection": {
        "full": {
            "HospitalAdmissionDiagnosis": {
                "id": [
                    "9935",
                    "9934"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "HospitalAdmissionDiagnosis": [
                "9935",
                "9934"
            ]
        }
    },
    "AllergiesSectionEntriesOptional": {
        "full": {
            "AllergyProblemAct": {
                "id": [
                    "7805",
                    "7804"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "AllergyProblemAct": [
                "7805",
                "7804"
            ]
        }
    },
    "PlannedProcedureSection": {
        "may": {
            "PlanOfCareActivityProcedure": [
                "8766",
                "8744"
            ]
        },
        "full": {
            "PlanOfCareActivityProcedure": {
                "id": [
                    "8766",
                    "8744"
                ],
                "constraint": "may"
            }
        }
    },
    "ProblemSection": {
        "full": {
            "ProblemConcernAct": {
                "id": [
                    "9183"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "ProblemConcernAct": [
                "9183"
            ]
        }
    },
    "EncountersSectionEntriesOptional": {
        "full": {
            "EncounterActivities": {
                "id": [
                    "7951",
                    "8802"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "EncounterActivities": [
                "7951",
                "8802"
            ]
        }
    },
    "HospitalDischargeMedicationsSectionEntriesOptional": {
        "full": {
            "DischargeMedication": {
                "id": [
                    "7883"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "DischargeMedication": [
                "7883"
            ]
        }
    },
    "ProcedureFindingsSection": {
        "may": {
            "ProblemObservation": [
                "8090",
                "8091"
            ]
        },
        "full": {
            "ProblemObservation": {
                "id": [
                    "8090",
                    "8091"
                ],
                "constraint": "may"
            }
        }
    },
    "PlanOfCareSection": {
        "may": {
            "PlanOfCareActivityAct": [
                "7726.",
                "8804"
            ],
            "PlanOfCareActivityProcedure": [
                "8810",
                "8809"
            ],
            "PlanOfCareActivitySubstanceAdministration": [
                "8811",
                "8812"
            ],
            "PlanOfCareActivitySupply": [
                "14756",
                "8813"
            ],
            "PlanOfCareActivityEncounter": [
                "8806",
                "8805"
            ],
            "PlanOfCareActivityObservation": [
                "8808",
                "8807"
            ],
            "Instructions": [
                "14695",
                "16751"
            ]
        },
        "full": {
            "PlanOfCareActivityAct": {
                "id": [
                    "7726.",
                    "8804"
                ],
                "constraint": "may"
            },
            "PlanOfCareActivityProcedure": {
                "id": [
                    "8810",
                    "8809"
                ],
                "constraint": "may"
            },
            "PlanOfCareActivitySubstanceAdministration": {
                "id": [
                    "8811",
                    "8812"
                ],
                "constraint": "may"
            },
            "PlanOfCareActivitySupply": {
                "id": [
                    "14756",
                    "8813"
                ],
                "constraint": "may"
            },
            "PlanOfCareActivityEncounter": {
                "id": [
                    "8806",
                    "8805"
                ],
                "constraint": "may"
            },
            "PlanOfCareActivityObservation": {
                "id": [
                    "8808",
                    "8807"
                ],
                "constraint": "may"
            },
            "Instructions": {
                "id": [
                    "14695",
                    "16751"
                ],
                "constraint": "may"
            }
        }
    },
    "InstructionsSection": {
        "full": {
            "Instructions": {
                "id": [
                    "10116",
                    "10117"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "Instructions": [
                "10116",
                "10117"
            ]
        }
    },
    "ProceduresSection": {
        "may": {
            "ProcedureActivityProcedure": [
                "7896",
                "7895"
            ],
            "ProcedureActivityAct": [
                "8020",
                "8019"
            ],
            "ProcedureActivityObservation": [
                "8018",
                "8017"
            ]
        },
        "full": {
            "ProcedureActivityProcedure": {
                "id": [
                    "7896",
                    "7895"
                ],
                "constraint": "may"
            },
            "ProcedureActivityAct": {
                "id": [
                    "8020",
                    "8019"
                ],
                "constraint": "may"
            },
            "ProcedureActivityObservation": {
                "id": [
                    "8018",
                    "8017"
                ],
                "constraint": "may"
            }
        }
    },
    "HospitalDischargeMedicationsSection": {
        "full": {
            "DischargeMedication": {
                "id": [
                    "7827"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "DischargeMedication": [
                "7827"
            ]
        }
    },
    "PostprocedureDiagnosisSection": {
        "full": {
            "PostprocedureDiagnosis": {
                "id": [
                    "8762",
                    "8764"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "PostprocedureDiagnosis": [
                "8762",
                "8764"
            ]
        }
    },
    "HistoryOfPastIllnessSection": {
        "may": {
            "ProblemObservation": [
                "8792"
            ]
        },
        "full": {
            "ProblemObservation": {
                "id": [
                    "8792"
                ],
                "constraint": "may"
            }
        }
    },
    "ProblemSectionEntriesOptional": {
        "full": {
            "ProblemConcernAct": {
                "id": [
                    "7882"
                ],
                "constraint": "should"
            }
        },
        "should": {
            "ProblemConcernAct": [
                "7882"
            ]
        }
    },
    "FamilyHistorySection": {
        "may": {
            "FamilyHistoryOrganizer": [
                "7955"
            ]
        },
        "full": {
            "FamilyHistoryOrganizer": {
                "id": [
                    "7955"
                ],
                "constraint": "may"
            }
        }
    },
    "ProcedureIndicationsSection": {
        "may": {
            "Indication": [
                "8765",
                "8743"
            ]
        },
        "full": {
            "Indication": {
                "id": [
                    "8765",
                    "8743"
                ],
                "constraint": "may"
            }
        }
    },
    "ProceduresSectionEntriesOptional": {
        "may": {
            "ProcedureActivityProcedure": [
                "15509",
                "6274"
            ],
            "ProcedureActivityAct": [
                "8533",
                "15511"
            ],
            "ProcedureActivityObservation": [
                "6278",
                "15510"
            ]
        },
        "full": {
            "ProcedureActivityProcedure": {
                "id": [
                    "15509",
                    "6274"
                ],
                "constraint": "may"
            },
            "ProcedureActivityAct": {
                "id": [
                    "8533",
                    "15511"
                ],
                "constraint": "may"
            },
            "ProcedureActivityObservation": {
                "id": [
                    "6278",
                    "15510"
                ],
                "constraint": "may"
            }
        }
    },
    "PhysicalExamSection": {
        "may": {
            "PressureUlcerObservation": [
                "17094",
                "17095"
            ],
            "NumberOfPressureUlcersObservation": [
                "17096",
                "17097"
            ],
            "HighestPressureUlcerStage": [
                "17098",
                "17099"
            ]
        },
        "full": {
            "PressureUlcerObservation": {
                "id": [
                    "17094",
                    "17095"
                ],
                "constraint": "may"
            },
            "NumberOfPressureUlcersObservation": {
                "id": [
                    "17096",
                    "17097"
                ],
                "constraint": "may"
            },
            "HighestPressureUlcerStage": {
                "id": [
                    "17098",
                    "17099"
                ],
                "constraint": "may"
            }
        }
    },
    "EncountersSection": {
        "full": {
            "EncounterActivities": {
                "id": [
                    "8709",
                    "8803"
                ],
                "constraint": "shall"
            }
        },
        "shall": {
            "EncounterActivities": [
                "8709",
                "8803"
            ]
        }
    }
};

module.exports = exports = sectionsconstraints;

},{}],30:[function(require,module,exports){
var sections = {
    "AdvanceDirectivesSection": "2.16.840.1.113883.10.20.22.2.21.1",
    "AdvanceDirectivesSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.21",
    "AllergiesSection": "2.16.840.1.113883.10.20.22.2.6.1",
    "AllergiesSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.6",
    "AnesthesiaSection": "2.16.840.1.113883.10.20.22.2.25",
    "AssessmentAndPlanSection": "2.16.840.1.113883.10.20.22.2.9",
    "AssessmentSection": "2.16.840.1.113883.10.20.22.2.8",
    "ChiefComplaintAndReasonForVisitSection": "2.16.840.1.113883.10.20.22.2.13",
    "ChiefComplaintSection": "1.3.6.1.4.1.19376.1.5.3.1.1.13.2.1",
    "ComplicationsSection": "2.16.840.1.113883.10.20.22.2.37",
    "DICOMObjectCatalogSection": "2.16.840.1.113883.10.20.6.1.1",
    "DischargeDietSection": "1.3.6.1.4.1.19376.1.5.3.1.3.33",
    "EncountersSection": "2.16.840.1.113883.10.20.22.2.22.1",
    "EncountersSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.22",
    "FamilyHistorySection": "2.16.840.1.113883.10.20.22.2.15",
    "FindingsSection": "2.16.840.1.113883.10.20.6.1.2",
    "FunctionalStatusSection": "2.16.840.1.113883.10.20.22.2.14",
    "GeneralStatusSection": "2.16.840.1.113883.10.20.2.5",
    "HistoryOfPastIllnessSection": "2.16.840.1.113883.10.20.22.2.20",
    "HistoryOfPresentIllnessSection": "1.3.6.1.4.1.19376.1.5.3.1.3.4",
    "HospitalAdmissionDiagnosisSection": "2.16.840.1.113883.10.20.22.2.43",
    "HospitalAdmissionMedicationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.44",
    "HospitalConsultationsSection": "2.16.840.1.113883.10.20.22.2.42",
    "HospitalCourseSection": "1.3.6.1.4.1.19376.1.5.3.1.3.5",
    "HospitalDischargeDiagnosisSection": "2.16.840.1.113883.10.20.22.2.24",
    "HospitalDischargeInstructionsSection": "2.16.840.1.113883.10.20.22.2.41",
    "HospitalDischargeMedicationsSection": "2.16.840.1.113883.10.20.22.2.11.1",
    "HospitalDischargeMedicationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.11",
    "HospitalDischargePhysicalSection": "1.3.6.1.4.1.19376.1.5.3.1.3.26",
    "HospitalDischargeStudiesSummarySection": "2.16.840.1.113883.10.20.22.2.16",
    "ImmunizationsSection": "2.16.840.1.113883.10.20.22.2.2.1",
    "ImmunizationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.2",
    "InstructionsSection": "2.16.840.1.113883.10.20.22.2.45",
    "InterventionsSection": "2.16.840.1.113883.10.20.21.2.3",
    "MedicalEquipmentSection": "2.16.840.1.113883.10.20.22.2.23",
    "MedicalHistorySection": "2.16.840.1.113883.10.20.22.2.39",
    "MedicationsAdministeredSection": "2.16.840.1.113883.10.20.22.2.38",
    "MedicationsSection": "2.16.840.1.113883.10.20.22.2.1.1",
    "MedicationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.1",
    "ObjectiveSection": "2.16.840.1.113883.10.20.21.2.1",
    "OperativeNoteFluidSection": "2.16.840.1.113883.10.20.7.12",
    "OperativeNoteSurgicalProcedureSection": "2.16.840.1.113883.10.20.7.14",
    "PayersSection": "2.16.840.1.113883.10.20.22.2.18",
    "PhysicalExamSection": "2.16.840.1.113883.10.20.2.10",
    "PlannedProcedureSection": "2.16.840.1.113883.10.20.22.2.30",
    "PlanOfCareSection": "2.16.840.1.113883.10.20.22.2.10",
    "PostoperativeDiagnosisSection": "2.16.840.1.113883.10.20.22.2.35",
    "PostprocedureDiagnosisSection": "2.16.840.1.113883.10.20.22.2.36",
    "PreoperativeDiagnosisSection": "2.16.840.1.113883.10.20.22.2.34",
    "ProblemSection": "2.16.840.1.113883.10.20.22.2.5.1",
    "ProblemSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.5",
    "ProcedureDescriptionSection": "2.16.840.1.113883.10.20.22.2.27",
    "ProcedureDispositionSection": "2.16.840.1.113883.10.20.18.2.12",
    "ProcedureEstimatedBloodLossSection": "2.16.840.1.113883.10.20.18.2.9",
    "ProcedureFindingsSection": "2.16.840.1.113883.10.20.22.2.28",
    "ProcedureImplantsSection": "2.16.840.1.113883.10.20.22.2.40",
    "ProcedureIndicationsSection": "2.16.840.1.113883.10.20.22.2.29",
    "ProcedureSpecimensTakenSection": "2.16.840.1.113883.10.20.22.2.31",
    "ProceduresSection": "2.16.840.1.113883.10.20.22.2.7.1",
    "ProceduresSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.7",
    "ReasonForReferralSection": "1.3.6.1.4.1.19376.1.5.3.1.3.1",
    "ReasonForVisitSection": "2.16.840.1.113883.10.20.22.2.12",
    "ResultsSection": "2.16.840.1.113883.10.20.22.2.3.1",
    "ResultsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.3",
    "ReviewOfSystemsSection": "1.3.6.1.4.1.19376.1.5.3.1.3.18",
    "SocialHistorySection": "2.16.840.1.113883.10.20.22.2.17",
    "SubjectiveSection": "2.16.840.1.113883.10.20.21.2.2",
    "SurgicalDrainsSection": "2.16.840.1.113883.10.20.7.13",
    "VitalSignsSection": "2.16.840.1.113883.10.20.22.2.4.1",
    "VitalSignsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.4"
};

var sections_r1 = {
    "AdvanceDirectivesSection": "2.16.840.1.113883.10.20.1.1",
    "AlertsSection": "2.16.840.1.113883.10.20.1.2",
    "EncountersSection": "2.16.840.1.113883.10.20.1.3",
    "FamilyHistorySection": "2.16.840.1.113883.10.20.1.4",
    "FunctionalStatusSection": "2.16.840.1.113883.10.20.1.5",
    "ImmunizationsSection": "2.16.840.1.113883.10.20.1.6",
    "MedicalEquipmentSection": "2.16.840.1.113883.10.20.1.7",
    "MedicationsSection": "2.16.840.1.113883.10.20.1.8",
    "PayersSection": "2.16.840.1.113883.10.20.1.9",
    "PlanOfCareSection": "2.16.840.1.113883.10.20.1.10",
    "ProblemSection": "2.16.840.1.113883.10.20.1.11",
    "ProceduresSection": "2.16.840.1.113883.10.20.1.12",
    "PurposeSection": "2.16.840.1.113883.10.20.1.13",
    "ResultsSection": "2.16.840.1.113883.10.20.1.14",
    "SocialHistorySection": "2.16.840.1.113883.10.20.1.15",
    "VitalSignsSection": "2.16.840.1.113883.10.20.1.16"
};

module.exports.sections = sections;
module.exports.sections_r1 = sections_r1;

},{}],31:[function(require,module,exports){
var templatesconstraints = {
    "ContinuityOfCareDocument": {
        "may": {
            "AdvanceDirectivesSection": "9455",
            "PayersSection": "9468",
            "SocialHistorySection": "9472",
            "ImmunizationsSectionEntriesOptional": "9463",
            "MedicalEquipmentSection": "9466",
            "FamilyHistorySection": "9459",
            "PlanOfCareSection": "9470",
            "FunctionalStatusSection": "9461",
            "VitalSignsSectionEntriesOptional": "9474",
            "EncountersSection": "9457"
        },
        "full": {
            "AdvanceDirectivesSection": {
                "id": "9455",
                "constraint": "may"
            },
            "PayersSection": {
                "id": "9468",
                "constraint": "may"
            },
            "MedicationsSection": {
                "id": "9447",
                "constraint": "shall"
            },
            "ProblemSection": {
                "id": "9449",
                "constraint": "shall"
            },
            "ImmunizationsSectionEntriesOptional": {
                "id": "9463",
                "constraint": "may"
            },
            "SocialHistorySection": {
                "id": "9472",
                "constraint": "may"
            },
            "MedicalEquipmentSection": {
                "id": "9466",
                "constraint": "may"
            },
            "FamilyHistorySection": {
                "id": "9459",
                "constraint": "may"
            },
            "ProceduresSection": {
                "id": "9451",
                "constraint": "shall"
            },
            "PlanOfCareSection": {
                "id": "9470",
                "constraint": "may"
            },
            "FunctionalStatusSection": {
                "id": "9461",
                "constraint": "may"
            },
            "VitalSignsSectionEntriesOptional": {
                "id": "9474",
                "constraint": "may"
            },
            "AllergiesSection": {
                "id": "9445",
                "constraint": "shall"
            },
            "EncountersSection": {
                "id": "9457",
                "constraint": "may"
            },
            "ResultsSection": {
                "id": "9453",
                "constraint": "shall"
            }
        },
        "shall": {
            "ProblemSection": "9449",
            "ResultsSection": "9453",
            "AllergiesSection": "9445",
            "ProceduresSection": "9451",
            "MedicationsSection": "9447"
        }
    },
    "HistoryAndPhysicalNote": {
        "may": {
            "ChiefComplaintSection": "9611",
            "ImmunizationsSectionEntriesOptional": "9637",
            "ProblemSectionEntriesOptional": "9639",
            "ReasonForVisitSection": "9627",
            "ProceduresSectionEntriesOptional": "9641",
            "AssessmentAndPlanSection": "9987",
            "ChiefComplaintAndReasonForVisitSection": "9613",
            "PlanOfCareSection": "9607",
            "InstructionsSection": "16807",
            "AssessmentSection": "9605"
        },
        "should": {
            "HistoryOfPresentIllnessSection": "9621"
        },
        "full": {
            "ChiefComplaintSection": {
                "id": "9611",
                "constraint": "may"
            },
            "ProblemSectionEntriesOptional": {
                "id": "9639",
                "constraint": "may"
            },
            "AllergiesSectionEntriesOptional": {
                "id": "9602",
                "constraint": "shall"
            },
            "FamilyHistorySection": {
                "id": "9615",
                "constraint": "shall"
            },
            "ResultsSectionEntriesOptional": {
                "id": "9629",
                "constraint": "shall"
            },
            "HistoryOfPastIllnessSection": {
                "id": "9619",
                "constraint": "shall"
            },
            "SocialHistorySection": {
                "id": "9633",
                "constraint": "shall"
            },
            "PlanOfCareSection": {
                "id": "9607",
                "constraint": "may"
            },
            "MedicationsSectionEntriesOptional": {
                "id": "9623",
                "constraint": "shall"
            },
            "ReasonForVisitSection": {
                "id": "9627",
                "constraint": "may"
            },
            "ProceduresSectionEntriesOptional": {
                "id": "9641",
                "constraint": "may"
            },
            "AssessmentAndPlanSection": {
                "id": "9987",
                "constraint": "may"
            },
            "GeneralStatusSection": {
                "id": "9617",
                "constraint": "shall"
            },
            "ChiefComplaintAndReasonForVisitSection": {
                "id": "9613",
                "constraint": "may"
            },
            "ImmunizationsSectionEntriesOptional": {
                "id": "9637",
                "constraint": "may"
            },
            "ReviewOfSystemsSection": {
                "id": "9631",
                "constraint": "shall"
            },
            "InstructionsSection": {
                "id": "16807",
                "constraint": "may"
            },
            "PhysicalExamSection": {
                "id": "9625",
                "constraint": "shall"
            },
            "VitalSignsSectionEntriesOptional": {
                "id": "9635",
                "constraint": "shall"
            },
            "AssessmentSection": {
                "id": "9605",
                "constraint": "may"
            },
            "HistoryOfPresentIllnessSection": {
                "id": "9621",
                "constraint": "should"
            }
        },
        "shall": {
            "MedicationsSectionEntriesOptional": "9623",
            "AllergiesSectionEntriesOptional": "9602",
            "ResultsSectionEntriesOptional": "9629",
            "HistoryOfPastIllnessSection": "9619",
            "VitalSignsSectionEntriesOptional": "9635",
            "FamilyHistorySection": "9615",
            "GeneralStatusSection": "9617",
            "ReviewOfSystemsSection": "9631",
            "PhysicalExamSection": "9625",
            "SocialHistorySection": "9633"
        }
    },
    "DischargeSummary": {
        "may": {
            "VitalSignsSectionEntriesOptional": "9584",
            "ChiefComplaintSection": "9554",
            "HospitalDischargePhysicalSection": "9568",
            "HospitalConsultationsSection": "9924",
            "SocialHistorySection": "9582",
            "HistoryOfPastIllnessSection": "9564",
            "HospitalDischargeInstructionsSection": "9926",
            "ProblemSectionEntriesOptional": "9574",
            "HospitalDischargeStudiesSummarySection": "9570",
            "ProceduresSectionEntriesOptional": "9576",
            "FamilyHistorySection": "9560",
            "ReasonForVisitSection": "9578",
            "ChiefComplaintAndReasonForVisitSection": "9556",
            "ImmunizationsSectionEntriesOptional": "9572",
            "FunctionalStatusSection": "9562",
            "HospitalAdmissionMedicationsSectionEntriesOptional": "10111",
            "HistoryOfPresentIllnessSection": "9566",
            "ReviewOfSystemsSection": "9580",
            "DischargeDietSection": "9558"
        },
        "full": {
            "HospitalDischargeDiagnosisSection": {
                "id": "9546",
                "constraint": "shall"
            },
            "SocialHistorySection": {
                "id": "9582",
                "constraint": "may"
            },
            "HospitalDischargeStudiesSummarySection": {
                "id": "9570",
                "constraint": "may"
            },
            "ChiefComplaintAndReasonForVisitSection": {
                "id": "9556",
                "constraint": "may"
            },
            "HospitalAdmissionMedicationsSectionEntriesOptional": {
                "id": "10111",
                "constraint": "may"
            },
            "HistoryOfPresentIllnessSection": {
                "id": "9566",
                "constraint": "may"
            },
            "HospitalConsultationsSection": {
                "id": "9924",
                "constraint": "may"
            },
            "FunctionalStatusSection": {
                "id": "9562",
                "constraint": "may"
            },
            "DischargeDietSection": {
                "id": "9558",
                "constraint": "may"
            },
            "HospitalAdmissionDiagnosisSection": {
                "id": "9928",
                "constraint": "shall"
            },
            "AllergiesSectionEntriesOptional": {
                "id": "9542",
                "constraint": "shall"
            },
            "HospitalDischargePhysicalSection": {
                "id": "9568",
                "constraint": "may"
            },
            "ImmunizationsSectionEntriesOptional": {
                "id": "9572",
                "constraint": "may"
            },
            "ReasonForVisitSection": {
                "id": "9578",
                "constraint": "may"
            },
            "HospitalDischargeMedicationsSectionEntriesOptional": {
                "id": "9548",
                "constraint": "shall"
            },
            "PlanOfCareSection": {
                "id": "9550",
                "constraint": "shall"
            },
            "VitalSignsSectionEntriesOptional": {
                "id": "9584",
                "constraint": "may"
            },
            "HospitalCourseSection": {
                "id": "9544",
                "constraint": "shall"
            },
            "ChiefComplaintSection": {
                "id": "9554",
                "constraint": "may"
            },
            "ProceduresSectionEntriesOptional": {
                "id": "9576",
                "constraint": "may"
            },
            "HospitalDischargeInstructionsSection": {
                "id": "9926",
                "constraint": "may"
            },
            "ProblemSectionEntriesOptional": {
                "id": "9574",
                "constraint": "may"
            },
            "FamilyHistorySection": {
                "id": "9560",
                "constraint": "may"
            },
            "HistoryOfPastIllnessSection": {
                "id": "9564",
                "constraint": "may"
            },
            "ReviewOfSystemsSection": {
                "id": "9580",
                "constraint": "may"
            }
        },
        "shall": {
            "HospitalAdmissionDiagnosisSection": "9928",
            "AllergiesSectionEntriesOptional": "9542",
            "HospitalDischargeDiagnosisSection": "9546",
            "HospitalDischargeMedicationsSectionEntriesOptional": "9548",
            "PlanOfCareSection": "9550",
            "HospitalCourseSection": "9544"
        }
    },
    "OperativeNote": {
        "may": {
            "PlannedProcedureSection": "9906",
            "OperativeNoteFluidSection": "9900",
            "OperativeNoteSurgicalProcedureSection": "9902",
            "SurgicalDrainsSection": "9912",
            "ProcedureDispositionSection": "9908",
            "ProcedureImplantsSection": "9898",
            "ProcedureIndicationsSection": "9910",
            "PlanOfCareSection": "9904"
        },
        "full": {
            "ProcedureSpecimensTakenSection": {
                "id": "9894",
                "constraint": "shall"
            },
            "PlannedProcedureSection": {
                "id": "9906",
                "constraint": "may"
            },
            "OperativeNoteFluidSection": {
                "id": "9900",
                "constraint": "may"
            },
            "OperativeNoteSurgicalProcedureSection": {
                "id": "9902",
                "constraint": "may"
            },
            "ProcedureIndicationsSection": {
                "id": "9910",
                "constraint": "may"
            },
            "SurgicalDrainsSection": {
                "id": "9912",
                "constraint": "may"
            },
            "PostoperativeDiagnosisSection": {
                "id": "9913",
                "constraint": "shall"
            },
            "ProcedureDispositionSection": {
                "id": "9908",
                "constraint": "may"
            },
            "ProcedureEstimatedBloodLossSection": {
                "id": "9890",
                "constraint": "shall"
            },
            "ProcedureImplantsSection": {
                "id": "9898",
                "constraint": "may"
            },
            "ProcedureDescriptionSection": {
                "id": "9896",
                "constraint": "shall"
            },
            "AnesthesiaSection": {
                "id": "9883",
                "constraint": "shall"
            },
            "ProcedureFindingsSection": {
                "id": "9892",
                "constraint": "shall"
            },
            "PlanOfCareSection": {
                "id": "9904",
                "constraint": "may"
            },
            "PreoperativeDiagnosisSection": {
                "id": "9888",
                "constraint": "shall"
            },
            "ComplicationsSection": {
                "id": "9885",
                "constraint": "shall"
            }
        },
        "shall": {
            "ProcedureSpecimensTakenSection": "9894",
            "ProcedureEstimatedBloodLossSection": "9890",
            "PostoperativeDiagnosisSection": "9913",
            "ProcedureDescriptionSection": "9896",
            "AnesthesiaSection": "9883",
            "ProcedureFindingsSection": "9892",
            "PreoperativeDiagnosisSection": "9888",
            "ComplicationsSection": "9885"
        }
    },
    "ProcedureNote": {
        "may": {
            "SocialHistorySection": "9849",
            "ProcedureDispositionSection": "9833",
            "AssessmentAndPlanSection": "9649",
            "ChiefComplaintAndReasonForVisitSection": "9815",
            "HistoryOfPresentIllnessSection": "9821",
            "ProcedureSpecimensTakenSection": "9841",
            "PlannedProcedureSection": "9831",
            "MedicationsSectionEntriesOptional": "9825",
            "MedicationsAdministeredSection": "9827",
            "ProcedureImplantsSection": "9839",
            "AnesthesiaSection": "9811",
            "MedicalHistorySection": "9823",
            "AllergiesSectionEntriesOptional": "9809",
            "ReasonForVisitSection": "9845",
            "ProcedureFindingsSection": "9837",
            "PlanOfCareSection": "9647",
            "ChiefComplaintSection": "9813",
            "ProcedureEstimatedBloodLossSection": "9835",
            "HistoryOfPastIllnessSection": "9819",
            "FamilyHistorySection": "9817",
            "ProceduresSectionEntriesOptional": "9843",
            "ReviewOfSystemsSection": "9847",
            "PhysicalExamSection": "9829",
            "AssessmentSection": "9645"
        },
        "full": {
            "SocialHistorySection": {
                "id": "9849",
                "constraint": "may"
            },
            "ProcedureDispositionSection": {
                "id": "9833",
                "constraint": "may"
            },
            "AssessmentAndPlanSection": {
                "id": "9649",
                "constraint": "may"
            },
            "ChiefComplaintAndReasonForVisitSection": {
                "id": "9815",
                "constraint": "may"
            },
            "ComplicationsSection": {
                "id": "9802",
                "constraint": "shall"
            },
            "HistoryOfPresentIllnessSection": {
                "id": "9821",
                "constraint": "may"
            },
            "ProcedureSpecimensTakenSection": {
                "id": "9841",
                "constraint": "may"
            },
            "PlannedProcedureSection": {
                "id": "9831",
                "constraint": "may"
            },
            "MedicationsSectionEntriesOptional": {
                "id": "9825",
                "constraint": "may"
            },
            "MedicationsAdministeredSection": {
                "id": "9827",
                "constraint": "may"
            },
            "ProcedureImplantsSection": {
                "id": "9839",
                "constraint": "may"
            },
            "ProcedureDescriptionSection": {
                "id": "9805",
                "constraint": "shall"
            },
            "AnesthesiaSection": {
                "id": "9811",
                "constraint": "may"
            },
            "MedicalHistorySection": {
                "id": "9823",
                "constraint": "may"
            },
            "AllergiesSectionEntriesOptional": {
                "id": "9809",
                "constraint": "may"
            },
            "ReasonForVisitSection": {
                "id": "9845",
                "constraint": "may"
            },
            "ProcedureFindingsSection": {
                "id": "9837",
                "constraint": "may"
            },
            "PlanOfCareSection": {
                "id": "9647",
                "constraint": "may"
            },
            "ChiefComplaintSection": {
                "id": "9813",
                "constraint": "may"
            },
            "ProcedureEstimatedBloodLossSection": {
                "id": "9835",
                "constraint": "may"
            },
            "PostprocedureDiagnosisSection": {
                "id": "9850",
                "constraint": "shall"
            },
            "HistoryOfPastIllnessSection": {
                "id": "9819",
                "constraint": "may"
            },
            "FamilyHistorySection": {
                "id": "9817",
                "constraint": "may"
            },
            "ProcedureIndicationsSection": {
                "id": "9807",
                "constraint": "shall"
            },
            "ProceduresSectionEntriesOptional": {
                "id": "9843",
                "constraint": "may"
            },
            "ReviewOfSystemsSection": {
                "id": "9847",
                "constraint": "may"
            },
            "PhysicalExamSection": {
                "id": "9829",
                "constraint": "may"
            },
            "AssessmentSection": {
                "id": "9645",
                "constraint": "may"
            }
        },
        "shall": {
            "ProcedureDescriptionSection": "9805",
            "PostprocedureDiagnosisSection": "9850",
            "ProcedureIndicationsSection": "9807",
            "ComplicationsSection": "9802"
        }
    },
    "DiagnosticImagingReport": {
        "full": {
            "FindingsSection": {
                "id": "8776",
                "constraint": "shall"
            },
            "DICOMObjectCatalogSection": {
                "id": "15141",
                "constraint": "should"
            }
        },
        "shall": {
            "FindingsSection": "8776"
        },
        "should": {
            "DICOMObjectCatalogSection": "15141"
        }
    },
    "ConsultationNote": {
        "may": {
            "ChiefComplaintSection": "9509",
            "AllergiesSectionEntriesOptional": "9507",
            "FamilyHistorySection": "9513",
            "ResultsSectionEntriesOptional": "9527",
            "HistoryOfPastIllnessSection": "9517",
            "SocialHistorySection": "9531",
            "ProblemSectionEntriesOptional": "9523",
            "MedicationsSectionEntriesOptional": "9521)",
            "ImmunizationsSection": "9519",
            "ProceduresSectionEntriesOptional": "9525",
            "AssessmentAndPlanSection": "9491",
            "GeneralStatusSection": "9515",
            "ReasonForVisitSection": "9500",
            "ChiefComplaintAndReasonForVisitSection": "10029",
            "PlanOfCareSection": "9489",
            "ReviewOfSystemsSection": "9529",
            "ReasonForReferralSection": "9498",
            "VitalSignsSectionEntriesOptional": "9533",
            "AssessmentSection": "9487"
        },
        "should": {
            "PhysicalExamSection": "9495"
        },
        "full": {
            "ChiefComplaintSection": {
                "id": "9509",
                "constraint": "may"
            },
            "AllergiesSectionEntriesOptional": {
                "id": "9507",
                "constraint": "may"
            },
            "FamilyHistorySection": {
                "id": "9513",
                "constraint": "may"
            },
            "ResultsSectionEntriesOptional": {
                "id": "9527",
                "constraint": "may"
            },
            "HistoryOfPastIllnessSection": {
                "id": "9517",
                "constraint": "may"
            },
            "SocialHistorySection": {
                "id": "9531",
                "constraint": "may"
            },
            "ProblemSectionEntriesOptional": {
                "id": "9523",
                "constraint": "may"
            },
            "MedicationsSectionEntriesOptional": {
                "id": "9521)",
                "constraint": "may"
            },
            "ImmunizationsSection": {
                "id": "9519",
                "constraint": "may"
            },
            "ProceduresSectionEntriesOptional": {
                "id": "9525",
                "constraint": "may"
            },
            "AssessmentAndPlanSection": {
                "id": "9491",
                "constraint": "may"
            },
            "GeneralStatusSection": {
                "id": "9515",
                "constraint": "may"
            },
            "ReasonForVisitSection": {
                "id": "9500",
                "constraint": "may"
            },
            "ChiefComplaintAndReasonForVisitSection": {
                "id": "10029",
                "constraint": "may"
            },
            "PlanOfCareSection": {
                "id": "9489",
                "constraint": "may"
            },
            "ReviewOfSystemsSection": {
                "id": "9529",
                "constraint": "may"
            },
            "ReasonForReferralSection": {
                "id": "9498",
                "constraint": "may"
            },
            "PhysicalExamSection": {
                "id": "9495",
                "constraint": "should"
            },
            "VitalSignsSectionEntriesOptional": {
                "id": "9533",
                "constraint": "may"
            },
            "AssessmentSection": {
                "id": "9487",
                "constraint": "may"
            },
            "HistoryOfPresentIllnessSection": {
                "id": "9493",
                "constraint": "shall"
            }
        },
        "shall": {
            "HistoryOfPresentIllnessSection": "9493"
        }
    },
    "ProgressNote": {
        "may": {
            "ChiefComplaintSection": "8772",
            "AllergiesSectionEntriesOptional": "8773",
            "ResultsSectionEntriesOptional": "8782",
            "ProblemSectionEntriesOptional": "8786",
            "MedicationsSectionEntriesOptional": "8771",
            "InterventionsSection": "8778",
            "AssessmentAndPlanSection": "8774",
            "ObjectiveSection": "8770",
            "VitalSignsSectionEntriesOptional": "8784",
            "PlanOfCareSection": "8775",
            "ReviewOfSystemsSection": "8788",
            "InstructionsSection": "16806",
            "PhysicalExamSection": "8780",
            "SubjectiveSection": "8790",
            "AssessmentSection": "8776"
        },
        "full": {
            "ChiefComplaintSection": {
                "id": "8772",
                "constraint": "may"
            },
            "AllergiesSectionEntriesOptional": {
                "id": "8773",
                "constraint": "may"
            },
            "ResultsSectionEntriesOptional": {
                "id": "8782",
                "constraint": "may"
            },
            "ProblemSectionEntriesOptional": {
                "id": "8786",
                "constraint": "may"
            },
            "MedicationsSectionEntriesOptional": {
                "id": "8771",
                "constraint": "may"
            },
            "InterventionsSection": {
                "id": "8778",
                "constraint": "may"
            },
            "AssessmentAndPlanSection": {
                "id": "8774",
                "constraint": "may"
            },
            "ObjectiveSection": {
                "id": "8770",
                "constraint": "may"
            },
            "VitalSignsSectionEntriesOptional": {
                "id": "8784",
                "constraint": "may"
            },
            "PlanOfCareSection": {
                "id": "8775",
                "constraint": "may"
            },
            "ReviewOfSystemsSection": {
                "id": "8788",
                "constraint": "may"
            },
            "InstructionsSection": {
                "id": "16806",
                "constraint": "may"
            },
            "PhysicalExamSection": {
                "id": "8780",
                "constraint": "may"
            },
            "SubjectiveSection": {
                "id": "8790",
                "constraint": "may"
            },
            "AssessmentSection": {
                "id": "8776",
                "constraint": "may"
            }
        }
    }
};

module.exports = exports = templatesconstraints;

},{}],32:[function(require,module,exports){
var templates = {
    "ConsultationNote": "2.16.840.1.113883.10.20.22.1.4",
    "ContinuityOfCareDocument": "2.16.840.1.113883.10.20.22.1.2",
    "DiagnosticImagingReport": "2.16.840.1.113883.10.20.22.1.5",
    "DischargeSummary": "2.16.840.1.113883.10.20.22.1.8",
    "HistoryAndPhysicalNote": "2.16.840.1.113883.10.20.22.1.3",
    "OperativeNote": "2.16.840.1.113883.10.20.22.1.7",
    "ProcedureNote": "2.16.840.1.113883.10.20.22.1.6",
    "ProgressNote": "2.16.840.1.113883.10.20.22.1.9",
    "UnstructuredDocument": "2.16.840.1.113883.10.20.21.1.10"
};

module.exports = exports = templates;

},{}],33:[function(require,module,exports){
"use strict";

var oids = require("./oids");

var codeSystem = {
    codeDisplayName: function (code) {
        return this.cs.table && this.cs.table[code];
    },
    displayNameCode: (function () {
        var reverseTables = {};

        return function (name) {
            var oid = this.oid;
            var reverseTable = reverseTables[oid];
            if (!reverseTable) {
                var table = this.cs.table || {};
                reverseTable = Object.keys(table).reduce(function (r, code) {
                    var name = table[code];
                    r[name] = code;
                    return r;
                }, {});
                reverseTables[oid] = reverseTable;
            }
            return reverseTable[name];
        };
    })(),
    name: function () {
        return this.cs.name;
    },
    systemId: function () {
        var systemOID = this.cs.code_system;
        if (systemOID) {
            return {
                codeSystem: systemOID,
                codeSystemName: oids[systemOID].name
            };
        } else {
            return {
                codeSystem: this.oid,
                codeSystemName: this.cs.name
            };
        }
    }
};

exports.find = function (oid) {
    var cs = oids[oid];
    if (cs) {
        var result = Object.create(codeSystem);
        result.oid = oid;
        result.cs = cs;
        return result;
    } else {
        return null;
    }
};

exports.findFromName = (function () {
    var nameIndex;

    return function (name) {
        if (!nameIndex) {
            nameIndex = Object.keys(oids).reduce(function (r, oid) {
                var n = oids[oid].name;
                r[n] = oid;
                return r;
            }, {});
        }
        return nameIndex[name];
    };
})();

},{"./oids":34}],34:[function(require,module,exports){
module.exports = OIDs = {
    "2.16.840.1.113883.11.20.9.19": {
        name: "Problem Status",
        table: {
            "active": "active",
            "suspended": "suspended",
            "aborted": "aborted",
            "completed": "completed"
        }
    },
    "2.16.840.1.113883.5.8": {
        name: "Act Reason",
        table: {
            "IMMUNE": "Immunity",
            "MEDPREC": "Medical precaution",
            "OSTOCK": "Out of stock",
            "PATOBJ": "Patient objection",
            "PHILISOP": "Philosophical objection",
            "RELIG": "Religious objection",
            "VACEFF": "Vaccine efficacy concerns",
            "VACSAF": "Vaccine safety concerns"
        }
    },
    "2.16.840.1.113883.6.103": {
        name: "ICD-9-CM",
        uri: "http://www.cms.gov/medicare-coverage-database/staticpages/icd-9-code-lookup.aspx"
    },
    "2.16.840.1.113883.6.233": {
        name: "US Department of Veterans Affairs",
        uri: "http://www.hl7.org/documentcenter/public_temp_36CB0CDC-1C23-BA17-0C356EB233D41682/standards/vocabulary/vocabulary_tables/infrastructure/vocabulary/voc_ExternalSystems.html"
    },
    "2.16.840.1.113883.6.69": {
        name: "NDC-FDA Drug Registration",
        uri: "http://phinvads.cdc.gov/vads/ViewCodeSystem.action?id=2.16.840.1.113883.6.69"
    },
    "2.16.840.1.113883.6.253": {
        name: "MediSpan DDID"
    },
    "2.16.840.1.113883.6.27": {
        name: "Multum",
        uri: "http://multum-look-me-up#"
    },
    "2.16.840.1.113883.6.312": {
        name: "multum-drug-synonym-id",
        uri: "http://multum-drug-synonym-id-look-me-up#"
    },
    "2.16.840.1.113883.6.314": {
        name: "multum-drug-id",
        uri: "http://multum-drug-id-look-me-up#"
    },
    "2.16.840.1.113883.6.59": {
        name: "CVX Vaccine",
        uri: "http://www2a.cdc.gov/vaccines/iis/iisstandards/vaccines.asp?rpt=cvx&code="
    },
    "2.16.840.1.113883.5.112": {
        name: "Route Code",
        uri: "http://hl7.org/codes/RouteCode#"
    },
    "2.16.840.1.113883.6.255.1336": {
        name: "InsuranceType Code"
    },
    "2.16.840.1.113883.6.1": {
        name: "LOINC",
        uri: "http://purl.bioontology.org/ontology/LNC/"
    },
    "2.16.840.1.113883.6.88": {
        name: "RXNORM",
        uri: "http://purl.bioontology.org/ontology/RXNORM/"
    },
    "2.16.840.1.113883.6.96": {
        name: "SNOMED CT",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        table: {
            "55561003": "Active",
            "421139008": "On Hold",
            "392521001": "Prior History",
            "73425007": "No Longer Active"
        }
    },
    "2.16.840.1.113883.6.12": {
        name: "CPT",
        uri: "http://purl.bioontology.org/ontology/CPT/"
    },
    "2.16.840.1.113883.5.4": {
        name: "ActCode",
        uri: "http://hl7.org/actcode/"
    },
    "2.16.840.1.113883.4.9": {
        name: "UNII",
    },
    "2.16.840.1.113883.1.11.78": {
        name: "Observation Interpretation"
    },
    "2.16.840.1.113883.19": {
        name: "Good Health Clinic",
        uri: "http://hl7.org/goodhealth/"
    },
    "2.16.840.1.113883.6.259": {
        name: "HealthcareServiceLocation",
        uri: "http://hl7.org/healthcareservice/"
    },
    "2.16.840.1.113883.1.11.19185": {
        name: "HL7 Religion",
        uri: "http://hl7.org/codes/ReligiousAffiliation#"
    },
    "2.16.840.1.113883.5.60": {
        name: "LanguageAbilityMode",
        uri: "http://hl7.org/codes/LanguageAbility#",
        table: {
            ESGN: "Expressed signed",
            ESP: "Expressed spoken",
            EWR: "Expressed written",
            RSGN: "Received signed",
            RSP: "Received spoken",
            RWR: "Received written"
        }
    },
    "2.16.840.1.113883.5.2": {
        name: "HL7 Marital Status",
        uri: "http://hl7.org/codes/MaritalStatus#"
    },
    "2.16.840.1.113883.5.25": {
        name: "Confidentiality Code",
        table: {
            "N": "Normal",
            "R": "Restricted",
            "V": "Very Restricted",
            "U": "Unrestricted"
        }
    },
    "2.16.840.1.113883.5.83": {
        name: "HL7 Result Interpretation",
        uri: "http://hl7.org/codes/ResultInterpretation#",
        table: {
            "B": "better",
            "D": "decreased",
            "U": "increased",
            "W": "worse",
            "<": "low off scale",
            ">": "high off scale",
            "A": "Abnormal",
            "AA": "abnormal alert",
            "H": "High",
            "HH": "high alert",
            "L": "Low",
            "LL": "low alert",
            "N": "Normal",
            "I": "intermediate",
            "MS": "moderately susceptible",
            "R": "resistent",
            "S": "susceptible",
            "VS": "very susceptible",
            "EX": "outside threshold",
            "HX": "above high threshold",
            "LX": "below low threshold",

        }
    },
    "2.16.840.1.113883.5.111": {
        name: "HL7 Role",
        uri: "http://hl7.org/codes/PersonalRelationship#",
        table: {
            "PRN": "Parent"
        }
    },
    "2.16.840.1.113883.5.110": {
        name: "HL7 RoleCode"
    },
    "2.16.840.1.113883.5.1119": {
        name: "HL7 Address",
        uri: "http://hl7.org/codes/Address#",
        table: {
            "BAD": "bad address",
            "CONF": "confidential",
            "DIR": "direct",
            "H": "home address",
            "HP": "primary home",
            "HV": "vacation home",
            "PHYS": "physical visit address",
            "PST": "postal address",
            "PUB": "public",
            "TMP": "temporary",
            "WP": "work place",
            "MC": "mobile contact",
            "PG": "pager",
            "EC": "emergency contact",
            "AS": "answering service"
        }
    },
    "2.16.840.1.113883.5.45": {
        name: "HL7 EntityName",
        uri: "http://hl7.org/codes/EntityName#",
        table: {
            "A": "Artist/Stage",
            "ABC": "Alphabetic",
            "ASGN": "Assigned",
            "C": "License",
            "I": "Indigenous/Tribal",
            "IDE": "Ideographic",
            "L": "Legal",
            "P": "Pseudonym",
            "PHON": "Phonetic",
            "R": "Religious",
            "SNDX": "Soundex",
            "SRCH": "Search",
            "SYL": "Syllabic"
        }
    },
    "2.16.840.1.113883.5.1": {
        name: "HL7 AdministrativeGender",
        uri: "http://hl7.org/codes/AdministrativeGender#",
        table: {
            "F": "Female",
            "M": "Male",
            "UN": "Undifferentiated"
        }
    },
    "2.16.840.1.113883.3.88.12.3221.6.8": {
        name: "Problem Severity",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        code_system: "2.16.840.1.113883.6.96",
        table: {
            "255604002": "Mild",
            "371923003": "Mild to moderate",
            "6736007": "Moderate",
            "371924009": "Moderate to severe",
            "24484000": "Severe",
            "399166001": "Fatal"
        }
    },
    "2.16.840.1.113883.3.88.12.80.68": {
        name: "HITSP Problem Status",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        code_system: "2.16.840.1.113883.6.96",
        table: {
            "55561003": "Active",
            "73425007": "Inactive",
            "413322009": "Resolved"
        }
    },
    "2.16.840.1.113883.11.20.9.38": {
        name: "Smoking Status/Social History Observation",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        code_system: "2.16.840.1.113883.6.96",
        table: {
            "449868002": "Current every day smoker",
            "428041000124106": "Current some day smoker",
            "8517006": "Former smoker",
            "266919005": "Never smoker",
            "77176002": "Smoker, current status unknown",
            "266927001": "Unknown if ever smoked",
            "230056004": "Smoker, current status unknown",
            "229819007": "Tobacco use and exposure",
            "256235009": "Exercise",
            "160573003": "Alcohol intake",
            "364393001": "Nutritional observable",
            "364703007": "Employment detail",
            "425400000": "Toxic exposure status",
            "363908000": "Details of drug misuse behavior",
            "228272008": "Health-related behavior",
            "105421008": "Educational Achievement"
        }
    },
    "2.16.840.1.113883.11.20.9.21": {
        name: "Age Unified Code for Units of Measure",
        uri: "http://phinvads.cdc.gov/vads/ViewValueSet.action?oid=2.16.840.1.114222.4.11.878",
        table: {
            "min": "Minute",
            "h": "Hour",
            "d": "Day",
            "wk": "Week",
            "mo": "Month",
            "a": "Year"
        }
    },
    "2.16.840.1.113883.12.292": {
        name: "CVX",
        uri: "http://phinvads.cdc.gov/vads/ViewCodeSystem.action?id=2.16.840.1.113883.12.292"
    },
    "2.16.840.1.113883.5.1076": {
        name: "HL7 Religious Affiliation",
        uri: "http://ushik.ahrq.gov/ViewItemDetails?system=mdr&itemKey=83154000",
        table: {
            "1008": "Babi & Baha´I faiths",
            "1009": "Baptist",
            "1010": "Bon",
            "1011": "Cao Dai",
            "1012": "Celticism",
            "1013": "Christian (non-Catholic, non-specific)",
            "1014": "Confucianism",
            "1015": "Cyberculture Religions",
            "1016": "Divination",
            "1017": "Fourth Way",
            "1018": "Free Daism",
            "1019": "Gnosis",
            "1020": "Hinduism",
            "1021": "Humanism",
            "1022": "Independent",
            "1023": "Islam",
            "1024": "Jainism",
            "1025": "Jehovah´s Witnesses",
            "1026": "Judaism",
            "1027": "Latter Day Saints",
            "1028": "Lutheran",
            "1029": "Mahayana",
            "1030": "Meditation",
            "1031": "Messianic Judaism",
            "1032": "Mitraism",
            "1033": "New Age",
            "1034": "non-Roman Catholic",
            "1035": "Occult",
            "1036": "Orthodox",
            "1037": "Paganism",
            "1038": "Pentecostal",
            "1039": "Process, The",
            "1040": "Reformed/Presbyterian",
            "1041": "Roman Catholic Church",
            "1042": "Satanism",
            "1043": "Scientology",
            "1044": "Shamanism",
            "1045": "Shiite (Islam)",
            "1046": "Shinto",
            "1047": "Sikism",
            "1048": "Spiritualism",
            "1049": "Sunni (Islam)",
            "1050": "Taoism",
            "1051": "Theravada",
            "1052": "Unitarian-Universalism",
            "1053": "Universal Life Church",
            "1054": "Vajrayana (Tibetan)",
            "1055": "Veda",
            "1056": "Voodoo",
            "1057": "Wicca",
            "1058": "Yaohushua",
            "1059": "Zen Buddhism",
            "1060": "Zoroastrianism",
            "1062": "Brethren",
            "1063": "Christian Scientist",
            "1064": "Church of Christ",
            "1065": "Church of God",
            "1066": "Congregational",
            "1067": "Disciples of Christ",
            "1068": "Eastern Orthodox",
            "1069": "Episcopalian",
            "1070": "Evangelical Covenant",
            "1071": "Friends",
            "1072": "Full Gospel",
            "1073": "Methodist",
            "1074": "Native American",
            "1075": "Nazarene",
            "1076": "Presbyterian",
            "1077": "Protestant",
            "1078": "Protestant, No Denomination",
            "1079": "Reformed",
            "1080": "Salvation Army",
            "1081": "Unitarian Universalist",
            "1082": "United Church of Christ"
        }
    },
    "2.16.840.1.113883.1.11.11526": {
        "name": "Internet Society Language",
        "uri": "http://www.loc.gov/standards/iso639-2/php/English_list.php"
    },
    "2.16.840.1.113883.11.20.9.22": {
        name: "ActStatus",
        table: {
            "completed": "Completed",
            "active": "Active",
            "aborted": "Aborted",
            "cancelled": "Cancelled"
        }
    },
    "2.16.840.1.113883.6.238": {
        name: "Race and Ethnicity - CDC",
        uri: "http://phinvads.cdc.gov/vads/ViewCodeSystemConcept.action?oid=2.16.840.1.113883.6.238&code=",
        table: {
            "1002-5": "American Indian or Alaska Native",
            "2028-9": "Asian",
            "2054-5": "Black or African American",
            "2076-8": "Native Hawaiian or Other Pacific Islander",
            "2106-3": "White",
            "2131-1": "Other Race",
            "1004-1": "American Indian",
            "1735-0": "Alaska Native",
            "2029-7": "Asian Indian",
            "2030-5": "Bangladeshi",
            "2031-3": "Bhutanese",
            "2032-1": "Burmese",
            "2033-9": "Cambodian",
            "2034-7": "Chinese",
            "2035-4": "Taiwanese",
            "2036-2": "Filipino",
            "2037-0": "Hmong",
            "2038-8": "Indonesian",
            "2039-6": "Japanese",
            "2040-4": "Korean",
            "2041-2": "Laotian",
            "2042-0": "Malaysian",
            "2043-8": "Okinawan",
            "2044-6": "Pakistani",
            "2045-3": "Sri Lankan",
            "2046-1": "Thai",
            "2047-9": "Vietnamese",
            "2048-7": "Iwo Jiman",
            "2049-5": "Maldivian",
            "2050-3": "Nepalese",
            "2051-1": "Singaporean",
            "2052-9": "Madagascar",
            "2056-0": "Black",
            "2058-6": "African American",
            "2060-2": "African",
            "2067-7": "Bahamian",
            "2068-5": "Barbadian",
            "2069-3": "Dominican",
            "2070-1": "Dominica Islander",
            "2071-9": "Haitian",
            "2072-7": "Jamaican",
            "2073-5": "Tobagoan",
            "2074-3": "Trinidadian",
            "2075-0": "West Indian",
            "2078-4": "Polynesian",
            "2085-9": "Micronesian",
            "2100-6": "Melanesian",
            "2500-7": "Other Pacific Islander",
            "2108-9": "European",
            "2118-8": "Middle Eastern or North African",
            "2129-5": "Arab",
            "1006-6": "Abenaki",
            "1008-2": "Algonquian",
            "1010-8": "Apache",
            "1021-5": "Arapaho",
            "1026-4": "Arikara",
            "1028-0": "Assiniboine",
            "1030-6": "Assiniboine Sioux",
            "1033-0": "Bannock",
            "1035-5": "Blackfeet",
            "1037-1": "Brotherton",
            "1039-7": "Burt Lake Band",
            "1041-3": "Caddo",
            "1044-7": "Cahuilla",
            "1053-8": "California Tribes",
            "1068-6": "Canadian and Latin American Indian",
            "1076-9": "Catawba",
            "1078-5": "Cayuse",
            "1080-1": "Chehalis",
            "1082-7": "Chemakuan",
            "1086-8": "Chemehuevi",
            "1088-4": "Cherokee",
            "1100-7": "Cherokee Shawnee",
            "1102-3": "Cheyenne",
            "1106-4": "Cheyenne-Arapaho",
            "1108-0": "Chickahominy",
            "1112-2": "Chickasaw",
            "1114-8": "Chinook",
            "1123-9": "Chippewa",
            "1150-2": "Chippewa Cree",
            "1153-6": "Chitimacha",
            "1155-1": "Choctaw",
            "1162-7": "Chumash",
            "1165-0": "Clear Lake",
            "1167-6": "Coeur D'Alene",
            "1169-2": "Coharie",
            "1171-8": "Colorado River",
            "1173-4": "Colville",
            "1175-9": "Comanche",
            "1178-3": "Coos, Lower Umpqua, Siuslaw",
            "1180-9": "Coos",
            "1182-5": "Coquilles",
            "1184-1": "Costanoan",
            "1186-6": "Coushatta",
            "1189-0": "Cowlitz",
            "1191-6": "Cree",
            "1193-2": "Creek",
            "1207-0": "Croatan",
            "1209-6": "Crow",
            "1211-2": "Cupeno",
            "1214-6": "Delaware",
            "1222-9": "Diegueno",
            "1233-6": "Eastern Tribes",
            "1250-0": "Esselen",
            "1252-6": "Fort Belknap",
            "1254-2": "Fort Berthold",
            "1256-7": "Fort Mcdowell",
            "1258-3": "Fort Hall",
            "1260-9": "Gabrieleno",
            "1262-5": "Grand Ronde",
            "1264-1": "Gros Ventres",
            "1267-4": "Haliwa",
            "1269-0": "Hidatsa",
            "1271-6": "Hoopa",
            "1275-7": "Hoopa Extension",
            "1277-3": "Houma",
            "1279-9": "Inaja-Cosmit",
            "1281-5": "Iowa",
            "1285-6": "Iroquois",
            "1297-1": "Juaneno",
            "1299-7": "Kalispel",
            "1301-1": "Karuk",
            "1303-7": "Kaw",
            "1305-2": "Kickapoo",
            "1309-4": "Kiowa",
            "1312-8": "Klallam",
            "1317-7": "Klamath",
            "1319-3": "Konkow",
            "1321-9": "Kootenai",
            "1323-5": "Lassik",
            "1325-0": "Long Island",
            "1331-8": "Luiseno",
            "1340-9": "Lumbee",
            "1342-5": "Lummi",
            "1344-1": "Maidu",
            "1348-2": "Makah",
            "1350-8": "Maliseet",
            "1352-4": "Mandan",
            "1354-0": "Mattaponi",
            "1356-5": "Menominee",
            "1358-1": "Miami",
            "1363-1": "Miccosukee",
            "1365-6": "Micmac",
            "1368-0": "Mission Indians",
            "1370-6": "Miwok",
            "1372-2": "Modoc",
            "1374-8": "Mohegan",
            "1376-3": "Mono",
            "1378-9": "Nanticoke",
            "1380-5": "Narragansett",
            "1382-1": "Navajo",
            "1387-0": "Nez Perce",
            "1389-6": "Nomalaki",
            "1391-2": "Northwest Tribes",
            "1403-5": "Omaha",
            "1405-0": "Oregon Athabaskan",
            "1407-6": "Osage",
            "1409-2": "Otoe-Missouria",
            "1411-8": "Ottawa",
            "1416-7": "Paiute",
            "1439-9": "Pamunkey",
            "1441-5": "Passamaquoddy",
            "1445-6": "Pawnee",
            "1448-0": "Penobscot",
            "1450-6": "Peoria",
            "1453-0": "Pequot",
            "1456-3": "Pima",
            "1460-5": "Piscataway",
            "1462-1": "Pit River",
            "1464-7": "Pomo",
            "1474-6": "Ponca",
            "1478-7": "Potawatomi",
            "1487-8": "Powhatan",
            "1489-4": "Pueblo",
            "1518-0": "Puget Sound Salish",
            "1541-2": "Quapaw",
            "1543-8": "Quinault",
            "1545-3": "Rappahannock",
            "1547-9": "Reno-Sparks",
            "1549-5": "Round Valley",
            "1551-1": "Sac and Fox",
            "1556-0": "Salinan",
            "1558-6": "Salish",
            "1560-2": "Salish and Kootenai",
            "1562-8": "Schaghticoke",
            "1564-4": "Scott Valley",
            "1566-9": "Seminole",
            "1573-5": "Serrano",
            "1576-8": "Shasta",
            "1578-4": "Shawnee",
            "1582-6": "Shinnecock",
            "1584-2": "Shoalwater Bay",
            "1586-7": "Shoshone",
            "1602-2": "Shoshone Paiute",
            "1607-1": "Siletz",
            "1609-7": "Sioux",
            "1643-6": "Siuslaw",
            "1645-1": "Spokane",
            "1647-7": "Stewart",
            "1649-3": "Stockbridge",
            "1651-9": "Susanville",
            "1653-5": "Tohono O'Odham",
            "1659-2": "Tolowa",
            "1661-8": "Tonkawa",
            "1663-4": "Tygh",
            "1665-9": "Umatilla",
            "1667-5": "Umpqua",
            "1670-9": "Ute",
            "1675-8": "Wailaki",
            "1677-4": "Walla-Walla",
            "1679-0": "Wampanoag",
            "1683-2": "Warm Springs",
            "1685-7": "Wascopum",
            "1687-3": "Washoe",
            "1692-3": "Wichita",
            "1694-9": "Wind River",
            "1696-4": "Winnebago",
            "1700-4": "Winnemucca",
            "1702-0": "Wintun",
            "1704-6": "Wiyot",
            "1707-9": "Yakama",
            "1709-5": "Yakama Cowlitz",
            "1711-1": "Yaqui",
            "1715-2": "Yavapai Apache",
            "1717-8": "Yokuts",
            "1722-8": "Yuchi",
            "1724-4": "Yuman",
            "1732-7": "Yurok",
            "1737-6": "Alaska Indian",
            "1840-8": "Eskimo",
            "1966-1": "Aleut",
            "2061-0": "Botswanan",
            "2062-8": "Ethiopian",
            "2063-6": "Liberian",
            "2064-4": "Namibian",
            "2065-1": "Nigerian",
            "2066-9": "Zairean",
            "2079-2": "Native Hawaiian",
            "2080-0": "Samoan",
            "2081-8": "Tahitian",
            "2082-6": "Tongan",
            "2083-4": "Tokelauan",
            "2086-7": "Guamanian or Chamorro",
            "2087-5": "Guamanian",
            "2088-3": "Chamorro",
            "2089-1": "Mariana Islander",
            "2090-9": "Marshallese",
            "2091-7": "Palauan",
            "2092-5": "Carolinian",
            "2093-3": "Kosraean",
            "2094-1": "Pohnpeian",
            "2095-8": "Saipanese",
            "2096-6": "Kiribati",
            "2097-4": "Chuukese",
            "2098-2": "Yapese",
            "2101-4": "Fijian",
            "2102-2": "Papua New Guinean",
            "2103-0": "Solomon Islander",
            "2104-8": "New Hebrides",
            "2109-7": "Armenian",
            "2110-5": "English",
            "2111-3": "French",
            "2112-1": "German",
            "2113-9": "Irish",
            "2114-7": "Italian",
            "2115-4": "Polish",
            "2116-2": "Scottish",
            "2119-6": "Assyrian",
            "2120-4": "Egyptian",
            "2121-2": "Iranian",
            "2122-0": "Iraqi",
            "2123-8": "Lebanese",
            "2124-6": "Palestinian",
            "2125-3": "Syrian",
            "2126-1": "Afghanistani",
            "2127-9": "Israeili",
            "1011-6": "Chiricahua",
            "1012-4": "Fort Sill Apache",
            "1013-2": "Jicarilla Apache",
            "1014-0": "Lipan Apache",
            "1015-7": "Mescalero Apache",
            "1016-5": "Oklahoma Apache",
            "1017-3": "Payson Apache",
            "1018-1": "San Carlos Apache",
            "1019-9": "White Mountain Apache",
            "1022-3": "Northern Arapaho",
            "1023-1": "Southern Arapaho",
            "1024-9": "Wind River Arapaho",
            "1031-4": "Fort Peck Assiniboine Sioux",
            "1042-1": "Oklahoma Cado",
            "1045-4": "Agua Caliente Cahuilla",
            "1046-2": "Augustine",
            "1047-0": "Cabazon",
            "1048-8": "Los Coyotes",
            "1049-6": "Morongo",
            "1050-4": "Santa Rosa Cahuilla",
            "1051-2": "Torres-Martinez",
            "1054-6": "Cahto",
            "1055-3": "Chimariko",
            "1056-1": "Coast Miwok",
            "1057-9": "Digger",
            "1058-7": "Kawaiisu",
            "1059-5": "Kern River",
            "1060-3": "Mattole",
            "1061-1": "Red Wood",
            "1062-9": "Santa Rosa",
            "1063-7": "Takelma",
            "1064-5": "Wappo",
            "1065-2": "Yana",
            "1066-0": "Yuki",
            "1069-4": "Canadian Indian",
            "1070-2": "Central American Indian",
            "1071-0": "French American Indian",
            "1072-8": "Mexican American Indian",
            "1073-6": "South American Indian",
            "1074-4": "Spanish American Indian",
            "1083-5": "Hoh",
            "1084-3": "Quileute",
            "1089-2": "Cherokee Alabama",
            "1090-0": "Cherokees of Northeast Alabama",
            "1091-8": "Cherokees of Southeast Alabama",
            "1092-6": "Eastern Cherokee",
            "1093-4": "Echota Cherokee",
            "1094-2": "Etowah Cherokee",
            "1095-9": "Northern Cherokee",
            "1096-7": "Tuscola",
            "1097-5": "United Keetowah Band of Cherokee",
            "1098-3": "Western Cherokee",
            "1103-1": "Northern Cheyenne",
            "1104-9": "Southern Cheyenne",
            "1109-8": "Eastern Chickahominy",
            "1110-6": "Western Chickahominy",
            "1115-5": "Clatsop",
            "1116-3": "Columbia River Chinook",
            "1117-1": "Kathlamet",
            "1118-9": "Upper Chinook",
            "1119-7": "Wakiakum Chinook",
            "1120-5": "Willapa Chinook",
            "1121-3": "Wishram",
            "1124-7": "Bad River",
            "1125-4": "Bay Mills Chippewa",
            "1126-2": "Bois Forte",
            "1127-0": "Burt Lake Chippewa",
            "1128-8": "Fond du Lac",
            "1129-6": "Grand Portage",
            "1130-4": "Grand Traverse Band of Ottawa/Chippewa",
            "1131-2": "Keweenaw",
            "1132-0": "Lac Courte Oreilles",
            "1133-8": "Lac du Flambeau",
            "1134-6": "Lac Vieux Desert Chippewa",
            "1135-3": "Lake Superior",
            "1136-1": "Leech Lake",
            "1137-9": "Little Shell Chippewa",
            "1138-7": "Mille Lacs",
            "1139-5": "Minnesota Chippewa",
            "1140-3": "Ontonagon",
            "1141-1": "Red Cliff Chippewa",
            "1142-9": "Red Lake Chippewa",
            "1143-7": "Saginaw Chippewa",
            "1144-5": "St. Croix Chippewa",
            "1145-2": "Sault Ste. Marie Chippewa",
            "1146-0": "Sokoagon Chippewa",
            "1147-8": "Turtle Mountain",
            "1148-6": "White Earth",
            "1151-0": "Rocky Boy's Chippewa Cree",
            "1156-9": "Clifton Choctaw",
            "1157-7": "Jena Choctaw",
            "1158-5": "Mississippi Choctaw",
            "1159-3": "Mowa Band of Choctaw",
            "1160-1": "Oklahoma Choctaw",
            "1163-5": "Santa Ynez",
            "1176-7": "Oklahoma Comanche",
            "1187-4": "Alabama Coushatta",
            "1194-0": "Alabama Creek",
            "1195-7": "Alabama Quassarte",
            "1196-5": "Eastern Creek",
            "1197-3": "Eastern Muscogee",
            "1198-1": "Kialegee",
            "1199-9": "Lower Muscogee",
            "1200-5": "Machis Lower Creek Indian",
            "1201-3": "Poarch Band",
            "1202-1": "Principal Creek Indian Nation",
            "1203-9": "Star Clan of Muscogee Creeks",
            "1204-7": "Thlopthlocco",
            "1205-4": "Tuckabachee",
            "1212-0": "Agua Caliente",
            "1215-3": "Eastern Delaware",
            "1216-1": "Lenni-Lenape",
            "1217-9": "Munsee",
            "1218-7": "Oklahoma Delaware",
            "1219-5": "Rampough Mountain",
            "1220-3": "Sand Hill",
            "1223-7": "Campo",
            "1224-5": "Capitan Grande",
            "1225-2": "Cuyapaipe",
            "1226-0": "La Posta",
            "1227-8": "Manzanita",
            "1228-6": "Mesa Grande",
            "1229-4": "San Pasqual",
            "1230-2": "Santa Ysabel",
            "1231-0": "Sycuan",
            "1234-4": "Attacapa",
            "1235-1": "Biloxi",
            "1236-9": "Georgetown (Eastern Tribes)",
            "1237-7": "Moor",
            "1238-5": "Nansemond",
            "1239-3": "Natchez",
            "1240-1": "Nausu Waiwash",
            "1241-9": "Nipmuc",
            "1242-7": "Paugussett",
            "1243-5": "Pocomoke Acohonock",
            "1244-3": "Southeastern Indians",
            "1245-0": "Susquehanock",
            "1246-8": "Tunica Biloxi",
            "1247-6": "Waccamaw-Siousan",
            "1248-4": "Wicomico",
            "1265-8": "Atsina",
            "1272-4": "Trinity",
            "1273-2": "Whilkut",
            "1282-3": "Iowa of Kansas-Nebraska",
            "1283-1": "Iowa of Oklahoma",
            "1286-4": "Cayuga",
            "1287-2": "Mohawk",
            "1288-0": "Oneida",
            "1289-8": "Onondaga",
            "1290-6": "Seneca",
            "1291-4": "Seneca Nation",
            "1292-2": "Seneca-Cayuga",
            "1293-0": "Tonawanda Seneca",
            "1294-8": "Tuscarora",
            "1295-5": "Wyandotte",
            "1306-0": "Oklahoma Kickapoo",
            "1307-8": "Texas Kickapoo",
            "1310-2": "Oklahoma Kiowa",
            "1313-6": "Jamestown",
            "1314-4": "Lower Elwha",
            "1315-1": "Port Gamble Klallam",
            "1326-8": "Matinecock",
            "1327-6": "Montauk",
            "1328-4": "Poospatuck",
            "1329-2": "Setauket",
            "1332-6": "La Jolla",
            "1333-4": "Pala",
            "1334-2": "Pauma",
            "1335-9": "Pechanga",
            "1336-7": "Soboba",
            "1337-5": "Twenty-Nine Palms",
            "1338-3": "Temecula",
            "1345-8": "Mountain Maidu",
            "1346-6": "Nishinam",
            "1359-9": "Illinois Miami",
            "1360-7": "Indiana Miami",
            "1361-5": "Oklahoma Miami",
            "1366-4": "Aroostook",
            "1383-9": "Alamo Navajo",
            "1384-7": "Canoncito Navajo",
            "1385-4": "Ramah Navajo",
            "1392-0": "Alsea",
            "1393-8": "Celilo",
            "1394-6": "Columbia",
            "1395-3": "Kalapuya",
            "1396-1": "Molala",
            "1397-9": "Talakamish",
            "1398-7": "Tenino",
            "1399-5": "Tillamook",
            "1400-1": "Wenatchee",
            "1401-9": "Yahooskin",
            "1412-6": "Burt Lake Ottawa",
            "1413-4": "Michigan Ottawa",
            "1414-2": "Oklahoma Ottawa",
            "1417-5": "Bishop",
            "1418-3": "Bridgeport",
            "1419-1": "Burns Paiute",
            "1420-9": "Cedarville",
            "1421-7": "Fort Bidwell",
            "1422-5": "Fort Independence",
            "1423-3": "Kaibab",
            "1424-1": "Las Vegas",
            "1425-8": "Lone Pine",
            "1426-6": "Lovelock",
            "1427-4": "Malheur Paiute",
            "1428-2": "Moapa",
            "1429-0": "Northern Paiute",
            "1430-8": "Owens Valley",
            "1431-6": "Pyramid Lake",
            "1432-4": "San Juan Southern Paiute",
            "1433-2": "Southern Paiute",
            "1434-0": "Summit Lake",
            "1435-7": "Utu Utu Gwaitu Paiute",
            "1436-5": "Walker River",
            "1437-3": "Yerington Paiute",
            "1442-3": "Indian Township",
            "1443-1": "Pleasant Point Passamaquoddy",
            "1446-4": "Oklahoma Pawnee",
            "1451-4": "Oklahoma Peoria",
            "1454-8": "Marshantucket Pequot",
            "1457-1": "Gila River Pima-Maricopa",
            "1458-9": "Salt River Pima-Maricopa",
            "1465-4": "Central Pomo",
            "1466-2": "Dry Creek",
            "1467-0": "Eastern Pomo",
            "1468-8": "Kashia",
            "1469-6": "Northern Pomo",
            "1470-4": "Scotts Valley",
            "1471-2": "Stonyford",
            "1472-0": "Sulphur Bank",
            "1475-3": "Nebraska Ponca",
            "1476-1": "Oklahoma Ponca",
            "1479-5": "Citizen Band Potawatomi",
            "1480-3": "Forest County",
            "1481-1": "Hannahville",
            "1482-9": "Huron Potawatomi",
            "1483-7": "Pokagon Potawatomi",
            "1484-5": "Prairie Band",
            "1485-2": "Wisconsin Potawatomi",
            "1490-2": "Acoma",
            "1491-0": "Arizona Tewa",
            "1492-8": "Cochiti",
            "1493-6": "Hopi",
            "1494-4": "Isleta",
            "1495-1": "Jemez",
            "1496-9": "Keres",
            "1497-7": "Laguna",
            "1498-5": "Nambe",
            "1499-3": "Picuris",
            "1500-8": "Piro",
            "1501-6": "Pojoaque",
            "1502-4": "San Felipe",
            "1503-2": "San Ildefonso",
            "1504-0": "San Juan Pueblo",
            "1505-7": "San Juan De",
            "1506-5": "San Juan",
            "1507-3": "Sandia",
            "1508-1": "Santa Ana",
            "1509-9": "Santa Clara",
            "1510-7": "Santo Domingo",
            "1511-5": "Taos",
            "1512-3": "Tesuque",
            "1513-1": "Tewa",
            "1514-9": "Tigua",
            "1515-6": "Zia",
            "1516-4": "Zuni",
            "1519-8": "Duwamish",
            "1520-6": "Kikiallus",
            "1521-4": "Lower Skagit",
            "1522-2": "Muckleshoot",
            "1523-0": "Nisqually",
            "1524-8": "Nooksack",
            "1525-5": "Port Madison",
            "1526-3": "Puyallup",
            "1527-1": "Samish",
            "1528-9": "Sauk-Suiattle",
            "1529-7": "Skokomish",
            "1530-5": "Skykomish",
            "1531-3": "Snohomish",
            "1532-1": "Snoqualmie",
            "1533-9": "Squaxin Island",
            "1534-7": "Steilacoom",
            "1535-4": "Stillaguamish",
            "1536-2": "Suquamish",
            "1537-0": "Swinomish",
            "1538-8": "Tulalip",
            "1539-6": "Upper Skagit",
            "1552-9": "Iowa Sac and Fox",
            "1553-7": "Missouri Sac and Fox",
            "1554-5": "Oklahoma Sac and Fox",
            "1567-7": "Big Cypress",
            "1568-5": "Brighton",
            "1569-3": "Florida Seminole",
            "1570-1": "Hollywood Seminole",
            "1571-9": "Oklahoma Seminole",
            "1574-3": "San Manual",
            "1579-2": "Absentee Shawnee",
            "1580-0": "Eastern Shawnee",
            "1587-5": "Battle Mountain",
            "1588-3": "Duckwater",
            "1589-1": "Elko",
            "1590-9": "Ely",
            "1591-7": "Goshute",
            "1592-5": "Panamint",
            "1593-3": "Ruby Valley",
            "1594-1": "Skull Valley",
            "1595-8": "South Fork Shoshone",
            "1596-6": "Te-Moak Western Shoshone",
            "1597-4": "Timbi-Sha Shoshone",
            "1598-2": "Washakie",
            "1599-0": "Wind River Shoshone",
            "1600-6": "Yomba",
            "1603-0": "Duck Valley",
            "1604-8": "Fallon",
            "1605-5": "Fort McDermitt",
            "1610-5": "Blackfoot Sioux",
            "1611-3": "Brule Sioux",
            "1612-1": "Cheyenne River Sioux",
            "1613-9": "Crow Creek Sioux",
            "1614-7": "Dakota Sioux",
            "1615-4": "Flandreau Santee",
            "1616-2": "Fort Peck",
            "1617-0": "Lake Traverse Sioux",
            "1618-8": "Lower Brule Sioux",
            "1619-6": "Lower Sioux",
            "1620-4": "Mdewakanton Sioux",
            "1621-2": "Miniconjou",
            "1622-0": "Oglala Sioux",
            "1623-8": "Pine Ridge Sioux",
            "1624-6": "Pipestone Sioux",
            "1625-3": "Prairie Island Sioux",
            "1626-1": "Prior Lake Sioux",
            "1627-9": "Rosebud Sioux",
            "1628-7": "Sans Arc Sioux",
            "1629-5": "Santee Sioux",
            "1630-3": "Sisseton-Wahpeton",
            "1631-1": "Sisseton Sioux",
            "1632-9": "Spirit Lake Sioux",
            "1633-7": "Standing Rock Sioux",
            "1634-5": "Teton Sioux",
            "1635-2": "Two Kettle Sioux",
            "1636-0": "Upper Sioux",
            "1637-8": "Wahpekute Sioux",
            "1638-6": "Wahpeton Sioux",
            "1639-4": "Wazhaza Sioux",
            "1640-2": "Yankton Sioux",
            "1641-0": "Yanktonai Sioux",
            "1654-3": "Ak-Chin",
            "1655-0": "Gila Bend",
            "1656-8": "San Xavier",
            "1657-6": "Sells",
            "1668-3": "Cow Creek Umpqua",
            "1671-7": "Allen Canyon",
            "1672-5": "Uintah Ute",
            "1673-3": "Ute Mountain Ute",
            "1680-8": "Gay Head Wampanoag",
            "1681-6": "Mashpee Wampanoag",
            "1688-1": "Alpine",
            "1689-9": "Carson",
            "1690-7": "Dresslerville",
            "1697-2": "Ho-chunk",
            "1698-0": "Nebraska Winnebago",
            "1705-3": "Table Bluff",
            "1712-9": "Barrio Libre",
            "1713-7": "Pascua Yaqui",
            "1718-6": "Chukchansi",
            "1719-4": "Tachi",
            "1720-2": "Tule River",
            "1725-1": "Cocopah",
            "1726-9": "Havasupai",
            "1727-7": "Hualapai",
            "1728-5": "Maricopa",
            "1729-3": "Mohave",
            "1730-1": "Quechan",
            "1731-9": "Yavapai",
            "1733-5": "Coast Yurok",
            "1739-2": "Alaskan Athabascan",
            "1811-9": "Southeast Alaska",
            "1842-4": "Greenland Eskimo",
            "1844-0": "Inupiat Eskimo",
            "1891-1": "Siberian Eskimo",
            "1896-0": "Yupik Eskimo",
            "1968-7": "Alutiiq Aleut",
            "1972-9": "Bristol Bay Aleut",
            "1984-4": "Chugach Aleut",
            "1990-1": "Eyak",
            "1992-7": "Koniag Aleut",
            "2002-4": "Sugpiaq",
            "2004-0": "Suqpigaq",
            "2006-5": "Unangan Aleut",
            "1740-0": "Ahtna",
            "1741-8": "Alatna",
            "1742-6": "Alexander",
            "1743-4": "Allakaket",
            "1744-2": "Alanvik",
            "1745-9": "Anvik",
            "1746-7": "Arctic",
            "1747-5": "Beaver",
            "1748-3": "Birch Creek",
            "1749-1": "Cantwell",
            "1750-9": "Chalkyitsik",
            "1751-7": "Chickaloon",
            "1752-5": "Chistochina",
            "1753-3": "Chitina",
            "1754-1": "Circle",
            "1755-8": "Cook Inlet",
            "1756-6": "Copper Center",
            "1757-4": "Copper River",
            "1758-2": "Dot Lake",
            "1759-0": "Doyon",
            "1760-8": "Eagle",
            "1761-6": "Eklutna",
            "1762-4": "Evansville",
            "1763-2": "Fort Yukon",
            "1764-0": "Gakona",
            "1765-7": "Galena",
            "1766-5": "Grayling",
            "1767-3": "Gulkana",
            "1768-1": "Healy Lake",
            "1769-9": "Holy Cross",
            "1770-7": "Hughes",
            "1771-5": "Huslia",
            "1772-3": "Iliamna",
            "1773-1": "Kaltag",
            "1774-9": "Kluti Kaah",
            "1775-6": "Knik",
            "1776-4": "Koyukuk",
            "1777-2": "Lake Minchumina",
            "1778-0": "Lime",
            "1779-8": "Mcgrath",
            "1780-6": "Manley Hot Springs",
            "1781-4": "Mentasta Lake",
            "1782-2": "Minto",
            "1783-0": "Nenana",
            "1784-8": "Nikolai",
            "1785-5": "Ninilchik",
            "1786-3": "Nondalton",
            "1787-1": "Northway",
            "1788-9": "Nulato",
            "1789-7": "Pedro Bay",
            "1790-5": "Rampart",
            "1791-3": "Ruby",
            "1792-1": "Salamatof",
            "1793-9": "Seldovia",
            "1794-7": "Slana",
            "1795-4": "Shageluk",
            "1796-2": "Stevens",
            "1797-0": "Stony River",
            "1798-8": "Takotna",
            "1799-6": "Tanacross",
            "1800-2": "Tanaina",
            "1801-0": "Tanana",
            "1802-8": "Tanana Chiefs",
            "1803-6": "Tazlina",
            "1804-4": "Telida",
            "1805-1": "Tetlin",
            "1806-9": "Tok",
            "1807-7": "Tyonek",
            "1808-5": "Venetie",
            "1809-3": "Wiseman",
            "1813-5": "Tlingit-Haida",
            "1837-4": "Tsimshian",
            "1845-7": "Ambler",
            "1846-5": "Anaktuvuk",
            "1847-3": "Anaktuvuk Pass",
            "1848-1": "Arctic Slope Inupiat",
            "1849-9": "Arctic Slope Corporation",
            "1850-7": "Atqasuk",
            "1851-5": "Barrow",
            "1852-3": "Bering Straits Inupiat",
            "1853-1": "Brevig Mission",
            "1854-9": "Buckland",
            "1855-6": "Chinik",
            "1856-4": "Council",
            "1857-2": "Deering",
            "1858-0": "Elim",
            "1859-8": "Golovin",
            "1860-6": "Inalik Diomede",
            "1861-4": "Inupiaq",
            "1862-2": "Kaktovik",
            "1863-0": "Kawerak",
            "1864-8": "Kiana",
            "1865-5": "Kivalina",
            "1866-3": "Kobuk",
            "1867-1": "Kotzebue",
            "1868-9": "Koyuk",
            "1869-7": "Kwiguk",
            "1870-5": "Mauneluk Inupiat",
            "1871-3": "Nana Inupiat",
            "1872-1": "Noatak",
            "1873-9": "Nome",
            "1874-7": "Noorvik",
            "1875-4": "Nuiqsut",
            "1876-2": "Point Hope",
            "1877-0": "Point Lay",
            "1878-8": "Selawik",
            "1879-6": "Shaktoolik",
            "1880-4": "Shishmaref",
            "1881-2": "Shungnak",
            "1882-0": "Solomon",
            "1883-8": "Teller",
            "1884-6": "Unalakleet",
            "1885-3": "Wainwright",
            "1886-1": "Wales",
            "1887-9": "White Mountain",
            "1888-7": "White Mountain Inupiat",
            "1889-5": "Mary's Igloo",
            "1892-9": "Gambell",
            "1893-7": "Savoonga",
            "1894-5": "Siberian Yupik",
            "1897-8": "Akiachak",
            "1898-6": "Akiak",
            "1899-4": "Alakanuk",
            "1900-0": "Aleknagik",
            "1901-8": "Andreafsky",
            "1902-6": "Aniak",
            "1903-4": "Atmautluak",
            "1904-2": "Bethel",
            "1905-9": "Bill Moore's Slough",
            "1906-7": "Bristol Bay Yupik",
            "1907-5": "Calista Yupik",
            "1908-3": "Chefornak",
            "1909-1": "Chevak",
            "1910-9": "Chuathbaluk",
            "1911-7": "Clark's Point",
            "1912-5": "Crooked Creek",
            "1913-3": "Dillingham",
            "1914-1": "Eek",
            "1915-8": "Ekuk",
            "1916-6": "Ekwok",
            "1917-4": "Emmonak",
            "1918-2": "Goodnews Bay",
            "1919-0": "Hooper Bay",
            "1920-8": "Iqurmuit (Russian Mission)",
            "1921-6": "Kalskag",
            "1922-4": "Kasigluk",
            "1923-2": "Kipnuk",
            "1924-0": "Koliganek",
            "1925-7": "Kongiganak",
            "1926-5": "Kotlik",
            "1927-3": "Kwethluk",
            "1928-1": "Kwigillingok",
            "1929-9": "Levelock",
            "1930-7": "Lower Kalskag",
            "1931-5": "Manokotak",
            "1932-3": "Marshall",
            "1933-1": "Mekoryuk",
            "1934-9": "Mountain Village",
            "1935-6": "Naknek",
            "1936-4": "Napaumute",
            "1937-2": "Napakiak",
            "1938-0": "Napaskiak",
            "1939-8": "Newhalen",
            "1940-6": "New Stuyahok",
            "1941-4": "Newtok",
            "1942-2": "Nightmute",
            "1943-0": "Nunapitchukv",
            "1944-8": "Oscarville",
            "1945-5": "Pilot Station",
            "1946-3": "Pitkas Point",
            "1947-1": "Platinum",
            "1948-9": "Portage Creek",
            "1949-7": "Quinhagak",
            "1950-5": "Red Devil",
            "1951-3": "St. Michael",
            "1952-1": "Scammon Bay",
            "1953-9": "Sheldon's Point",
            "1954-7": "Sleetmute",
            "1955-4": "Stebbins",
            "1956-2": "Togiak",
            "1957-0": "Toksook",
            "1958-8": "Tulukskak",
            "1959-6": "Tuntutuliak",
            "1960-4": "Tununak",
            "1961-2": "Twin Hills",
            "1962-0": "Georgetown (Yupik-Eskimo)",
            "1963-8": "St. Mary's",
            "1964-6": "Umkumiate",
            "1969-5": "Tatitlek",
            "1970-3": "Ugashik",
            "1973-7": "Chignik",
            "1974-5": "Chignik Lake",
            "1975-2": "Egegik",
            "1976-0": "Igiugig",
            "1977-8": "Ivanof Bay",
            "1978-6": "King Salmon",
            "1979-4": "Kokhanok",
            "1980-2": "Perryville",
            "1981-0": "Pilot Point",
            "1982-8": "Port Heiden",
            "1985-1": "Chenega",
            "1986-9": "Chugach Corporation",
            "1987-7": "English Bay",
            "1988-5": "Port Graham",
            "1993-5": "Akhiok",
            "1994-3": "Agdaagux",
            "1995-0": "Karluk",
            "1996-8": "Kodiak",
            "1997-6": "Larsen Bay",
            "1998-4": "Old Harbor",
            "1999-2": "Ouzinkie",
            "2000-8": "Port Lions",
            "2007-3": "Akutan",
            "2008-1": "Aleut Corporation",
            "2009-9": "Aleutian",
            "2010-7": "Aleutian Islander",
            "2011-5": "Atka",
            "2012-3": "Belkofski",
            "2013-1": "Chignik Lagoon",
            "2014-9": "King Cove",
            "2015-6": "False Pass",
            "2016-4": "Nelson Lagoon",
            "2017-2": "Nikolski",
            "2018-0": "Pauloff Harbor",
            "2019-8": "Qagan Toyagungin",
            "2020-6": "Qawalangin",
            "2021-4": "St. George",
            "2022-2": "St. Paul",
            "2023-0": "Sand Point",
            "2024-8": "South Naknek",
            "2025-5": "Unalaska",
            "2026-3": "Unga",
            "1814-3": "Angoon",
            "1815-0": "Central Council of Tlingit and Haida Tribes",
            "1816-8": "Chilkat",
            "1817-6": "Chilkoot",
            "1818-4": "Craig",
            "1819-2": "Douglas",
            "1820-0": "Haida",
            "1821-8": "Hoonah",
            "1822-6": "Hydaburg",
            "1823-4": "Kake",
            "1824-2": "Kasaan",
            "1825-9": "Kenaitze",
            "1826-7": "Ketchikan",
            "1827-5": "Klawock",
            "1828-3": "Pelican",
            "1829-1": "Petersburg",
            "1830-9": "Saxman",
            "1831-7": "Sitka",
            "1832-5": "Tenakee Springs",
            "1833-3": "Tlingit",
            "1834-1": "Wrangell",
            "1835-8": "Yakutat",
            "1838-2": "Metlakatla",
            "2135-2": "Hispanic or Latino",
            "2186-5": "Not Hispanic or Latino"
        }
    },
    "2.16.840.1.113883.3.26.1.1": {
        name: "Medication Route FDA",
        uri: "http://nci-thesaurus-look-me-up#",
        table: {
            "C38192": "AURICULAR (OTIC)",
            "C38193": "BUCCAL",
            "C38194": "CONJUNCTIVAL",
            "C38675": "CUTANEOUS",
            "C38197": "DENTAL",
            "C38633": "ELECTRO-OSMOSIS",
            "C38205": "ENDOCERVICAL",
            "C38206": "ENDOSINUSIAL",
            "C38208": "ENDOTRACHEAL",
            "C38209": "ENTERAL",
            "C38210": "EPIDURAL",
            "C38211": "EXTRA-AMNIOTIC",
            "C38212": "EXTRACORPOREAL",
            "C38200": "HEMODIALYSIS",
            "C38215": "INFILTRATION",
            "C38219": "INTERSTITIAL",
            "C38220": "INTRA-ABDOMINAL",
            "C38221": "INTRA-AMNIOTIC",
            "C38222": "INTRA-ARTERIAL",
            "C38223": "INTRA-ARTICULAR",
            "C38224": "INTRABILIARY",
            "C38225": "INTRABRONCHIAL",
            "C38226": "INTRABURSAL",
            "C38227": "INTRACARDIAC",
            "C38228": "INTRACARTILAGINOUS",
            "C38229": "INTRACAUDAL",
            "C38230": "INTRACAVERNOUS",
            "C38231": "INTRACAVITARY",
            "C38232": "INTRACEREBRAL",
            "C38233": "INTRACISTERNAL",
            "C38234": "INTRACORNEAL",
            "C38217": "INTRACORONAL, DENTAL",
            "C38218": "INTRACORONARY",
            "C38235": "INTRACORPORUS CAVERNOSUM",
            "C38238": "INTRADERMAL",
            "C38239": "INTRADISCAL",
            "C38240": "INTRADUCTAL",
            "C38241": "INTRADUODENAL",
            "C38242": "INTRADURAL",
            "C38243": "INTRAEPIDERMAL",
            "C38245": "INTRAESOPHAGEAL",
            "C38246": "INTRAGASTRIC",
            "C38247": "INTRAGINGIVAL",
            "C38249": "INTRAILEAL",
            "C38250": "INTRALESIONAL",
            "C38251": "INTRALUMINAL",
            "C38252": "INTRALYMPHATIC",
            "C38253": "INTRAMEDULLARY",
            "C38254": "INTRAMENINGEAL",
            "C28161": "INTRAMUSCULAR",
            "C38255": "INTRAOCULAR",
            "C38256": "INTRAOVARIAN",
            "C38257": "INTRAPERICARDIAL",
            "C38258": "INTRAPERITONEAL",
            "C38259": "INTRAPLEURAL",
            "C38260": "INTRAPROSTATIC",
            "C38261": "INTRAPULMONARY",
            "C38262": "INTRASINAL",
            "C38263": "INTRASPINAL",
            "C38264": "INTRASYNOVIAL",
            "C38265": "INTRATENDINOUS",
            "C38266": "INTRATESTICULAR",
            "C38267": "INTRATHECAL",
            "C38207": "INTRATHORACIC",
            "C38268": "INTRATUBULAR",
            "C38269": "INTRATUMOR",
            "C38270": "INTRATYMPANIC",
            "C38272": "INTRAUTERINE",
            "C38273": "INTRAVASCULAR",
            "C38276": "INTRAVENOUS",
            "C38277": "INTRAVENTRICULAR",
            "C38278": "INTRAVESICAL",
            "C38280": "INTRAVITREAL",
            "C38203": "IONTOPHORESIS",
            "C38281": "IRRIGATION",
            "C38282": "LARYNGEAL",
            "C38284": "NASAL",
            "C38285": "NASOGASTRIC",
            "C48623": "NOT APPLICABLE",
            "C38286": "OCCLUSIVE DRESSING TECHNIQUE",
            "C38287": "OPHTHALMIC",
            "C38288": "ORAL",
            "C38289": "OROPHARYNGEAL",
            "C38291": "PARENTERAL",
            "C38676": "PERCUTANEOUS",
            "C38292": "PERIARTICULAR",
            "C38677": "PERIDURAL",
            "C38293": "PERINEURAL",
            "C38294": "PERIODONTAL",
            "C38295": "RECTAL",
            "C38216": "RESPIRATORY (INHALATION)",
            "C38296": "RETROBULBAR",
            "C38198": "SOFT TISSUE",
            "C38297": "SUBARACHNOID",
            "C38298": "SUBCONJUNCTIVAL",
            "C38299": "SUBCUTANEOUS",
            "C38300": "SUBLINGUAL",
            "C38301": "SUBMUCOSAL",
            "C38304": "TOPICAL",
            "C38305": "TRANSDERMAL",
            "C38283": "TRANSMUCOSAL",
            "C38307": "TRANSPLACENTAL",
            "C38308": "TRANSTRACHEAL",
            "C38309": "TRANSTYMPANIC",
            "C38312": "URETERAL",
            "C38271": "URETHRAL"
        }
    },
    "2.16.840.1.113883.11.20.9.33": {
        name: "IND Roleclass Codes",
        uri: "",
        code_system: "2.16.840.1.113883.5.110",
        table: {
            "PRS": "Personal Relationship",
            "NOK": "Next of Kin",
            "CAREGIVER": "Caregiver",
            "AGNT": "Agent",
            "GUAR": "Guarantor",
            "ECON": "Emergency Contact"
        }
    },
    "2.16.840.1.113883.5.139": {
        name: "Domain TimingEvent",
        table: {
            //https://groups.google.com/forum/#!msg/ccda_samples/WawmwNMYT_8/pqnp5bG1IygJ
            "AC": "before meal",
            "ACD": "before lunch",
            "ACM": "before breakfast",
            "ACV": "before dinner",
            "C": "with meal",
            "CD": "with lunch",
            "CM": "with breakfast",
            "CV": "with dinner",
            "HS": "at bedtime",
            "IC": "between meals",
            "ICD": "between lunch and dinner",
            "ICM": "between breakfast and lunch",
            "ICV": "between dinner and bedtime",
            "PC": "after meal",
            "PCD": "after lunch",
            "PCM": "after breakfast",
            "PCV": "after dinner",
            "WAKE": "upon waking"
        }
    },
    "2.16.840.1.113883.6.14": {
        name: "HCPCS",
        uri: "http://www.cms.gov/Medicare/Coding/MedHCPCSGenInfo/index.html?redirect=/medhcpcsgeninfo/"
    },
    "2.16.840.1.113883.3.88.12.3221.8.9": {
        name: "Body Site Value Set"
    },
    "2.16.840.1.113883.5.7": {
        name: "ActPriority"
    }
};

},{}],35:[function(require,module,exports){
"use strict";

exports.arrayset = require('./lib/arrayset');
exports.object = require('./lib/object');
exports.objectset = require('./lib/objectset');
exports.datetime = require('./lib/datetime');
exports.predicate = require('./lib/predicate');

},{"./lib/arrayset":36,"./lib/datetime":37,"./lib/object":38,"./lib/objectset":39,"./lib/predicate":40}],36:[function(require,module,exports){
"use strict";

var lodash = require('lodash');

exports.append = function (arr, arrToAppend) {
    Array.prototype.push.apply(arr, arrToAppend);
};

exports.remove = lodash.remove;

},{"lodash":41}],37:[function(require,module,exports){
"use strict";

var moment = require('moment');

var dateToModel = exports.dateToModel = (function () {
    var precisions = ['year', 'month', 'day'];

    return function (d) {
        d = d.replace(/-/g, '');
        var m = moment.utc(d, 'YYYYMMDD');
        var dl = d.length;
        dl = (dl > 8) ? 8 : dl;
        var precisionIndex = dl / 2 - 2;
        var precision = precisions[precisionIndex];
        if (m.isValid() && precision) {
            return {
                date: m.toISOString(),
                precision: precision
            };
        } else {
            return null;
        }
    };
})();

exports.dateTimeToModel = function (d) {
    if (d.indexOf('T') > 0) {
        return {
            date: d,
            precision: 'second'
        };
    } else {
        return dateToModel(d);
    }
};

var modelToDateTime = exports.modelToDateTime = (function () {
    var precisionBasedFormatter = {
        year: function (t) {
            return moment(t, 'YYYY').format('YYYY');
        },
        month: function (t) {
            return moment(t, 'YYYYMM').format('YYYY-MM');
        },
        day: function (t) {
            return moment(t, 'YYYYMMDD').format('YYYY-MM-DD');
        }
    };

    return function (dt) {
        var f = precisionBasedFormatter[dt.precision];
        if (f) {
            return f(dt.date);
        } else {
            return dt.date;
        }
    };
})();

exports.modelToDate = function (dt) {
    var validPrecisions = {
        'day': true,
        'month': true,
        'year': true
    };
    if (!validPrecisions[dt.precision]) {
        dt.precision = 'day';
    }
    return modelToDateTime(dt);
};

},{"moment":80}],38:[function(require,module,exports){
"use strict";

var lodash = require('lodash');

exports.isObject = lodash.isObject;

var exists = exports.exists = function (obj) {
    return (obj !== undefined) && (obj !== null);
};

exports.deepValue = function (obj, deepProperty) {
    var propertyPieces = deepProperty.split('.');
    var n = propertyPieces.length;
    for (var i = 0; i < n; ++i) {
        if ((!exists(obj)) || (typeof obj !== 'object')) {
            return null;
        }
        var property = propertyPieces[i];
        obj = obj[property];
    }
    return obj;
};

},{"lodash":41}],39:[function(require,module,exports){
"use strict";

var lodash = require('lodash');

var object = require('./object');

exports.compact = function compact(obj) {
    if (typeof obj === 'object') {
        Object.keys(obj).forEach(function (key) {
            if (object.exists(obj[key])) {
                compact(obj[key]);
            } else {
                delete obj[key];
            }
        });
    }
};

exports.merge = lodash.merge;

exports.deepValue = function (obj, deepProperty, value) {
    if ((!object.exists(obj)) || (typeof obj !== 'object')) {
        return null;
    }
    var currentObj = obj;
    var propertyPieces = deepProperty.split('.');
    var lastIndex = propertyPieces.length - 1;
    for (var i = 0; i < lastIndex; ++i) {
        var propertyPiece = propertyPieces[i];
        var nextObj = currentObj[propertyPiece];
        if ((!object.exists(nextObj)) || (typeof nextObj !== 'object')) {
            currentObj[propertyPiece] = nextObj = {};
        }
        currentObj = nextObj;
    }
    currentObj[propertyPieces[lastIndex]] = value;
    return obj;
};

},{"./object":38,"lodash":41}],40:[function(require,module,exports){
"use strict";

var object = require('./object');

var exists = object.exists;

var hasProperty = exports.hasProperty = function (deepProperty) {
    var propertyPieces = deepProperty.split('.');
    if (propertyPieces.length > 1) {
        return function (input) {
            if (!exists(input)) {
                return false;
            } else {
                return propertyPieces.every(function (piece) {
                    if (typeof input !== 'object') {
                        return false;
                    }
                    if (!input.hasOwnProperty(piece)) {
                        return false;
                    }
                    input = input[piece];
                    if (!exists(input)) {
                        return false;
                    } else {
                        return true;
                    }
                });
            }
        };
    } else {
        return function (input) {
            if (exists(input) && (typeof input === 'object')) {
                return input.hasOwnProperty(deepProperty);
            } else {
                return false;
            }
        };
    }
};

exports.hasNoProperty = function (deepProperty) {
    var f = hasProperty(deepProperty);
    return function (input) {
        return !f(input);
    };
};

exports.inValueSet = function (valueSet) {
    return function (input) {
        return (valueSet.indexOf(input) >= 0);
    };
};

exports.hasNoProperties = function (deepProperties) {
    var fns = deepProperties.map(function (p) {
        return hasProperty(p);
    });
    return function (input) {
        var some = fns.some(function (fn) {
            return fn(input);
        });
        return !some;
    };
};

exports.propertyValue = function (deepProperty) {
    return function (input) {
        return object.deepValue(input, deepProperty);
    };
};

exports.falsyPropertyValue = function (deepProperty) {
    return function (input) {
        return !object.deepValue(input, deepProperty);
    };
};

exports.and = function (fns) {
    return function (input) {
        return fns.every(function (fn) {
            return fn(input);
        });
    };
};

exports.or = function (fns) {
    return function (input) {
        return fns.some(function (fn) {
            return fn(input);
        });
    };
};

},{"./object":38}],41:[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],42:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":43}],43:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.10.0';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":44,"./chai/config":45,"./chai/core/assertions":46,"./chai/interface/assert":47,"./chai/interface/expect":48,"./chai/interface/should":49,"./chai/utils":60,"assertion-error":69}],44:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');
var NOOP = function() { };

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.addChainableNoop = function(name, fn) {
    util.addChainableMethod(this.prototype, name, NOOP, fn);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String or Function} message or function that returns message to display if fails
   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":45}],45:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],46:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     expect('everthing').to.be.ok();
   *     
   * @name ok
   * @api public
   */

  Assertion.addChainableNoop('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     expect(true).to.be.true();
   *
   * @name true
   * @api public
   */

  Assertion.addChainableNoop('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     expect(false).to.be.false();
   *
   * @name false
   * @api public
   */

  Assertion.addChainableNoop('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     expect(null).to.be.null();
   *
   * @name null
   * @api public
   */

  Assertion.addChainableNoop('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     expect(undefined).to.be.undefined();
   *
   * @name undefined
   * @api public
   */

  Assertion.addChainableNoop('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     expect(foo).to.exist();
   *
   * @name exist
   * @api public
   */

  Assertion.addChainableNoop('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     expect([]).to.be.empty();
   *
   * @name empty
   * @api public
   */

  Assertion.addChainableNoop('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * Can also be used as a function, which prevents some linter errors.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments();
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addChainableNoop('arguments', checkArguments);
  Assertion.addChainableNoop('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj, msg).is.a('number');
    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
      throw new Error('the arguments to closeTo must be numbers');
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],47:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],48:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],49:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],50:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":45,"./flag":53,"./transferFlags":67}],51:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":45,"./flag":53}],52:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],53:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],54:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],55:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],56:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":53,"./getActual":54,"./inspect":61,"./objDisplay":62}],57:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],58:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],59:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],60:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":50,"./addMethod":51,"./addProperty":52,"./flag":53,"./getActual":54,"./getMessage":56,"./getName":57,"./getPathValue":58,"./inspect":61,"./objDisplay":62,"./overwriteChainableMethod":63,"./overwriteMethod":64,"./overwriteProperty":65,"./test":66,"./transferFlags":67,"./type":68,"deep-eql":70}],61:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && (1/value) === -Infinity) {
        return ctx.stylize('-0', 'number');
      }
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":55,"./getName":57,"./getProperties":59}],62:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":45,"./inspect":61}],63:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],64:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],65:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],66:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":53}],67:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],68:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],69:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],70:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":71}],71:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":74,"type-detect":72}],72:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":73}],73:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],74:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":75,"ieee754":76,"is-array":77}],75:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],76:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],77:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],78:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":79}],79:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],80:[function(require,module,exports){
(function (global){
//! moment.js
//! version : 2.8.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {
    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = '2.8.4',
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for locale config files
        locales = {},

        // extra moment internal properties (plugins register props here)
        momentProperties = [],

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.localeData().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.localeData().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            x    : function () {
                return this.valueOf();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
                                           m._a[SECOND] !== 0 ||
                                           m._a[MILLISECOND] !== 0)) ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0 &&
                    m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ?
                    +input : +moment(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }

    /************************************
        Locale
    ************************************/


    extend(Locale.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _ordinalParseLenient.
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
        },

        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName, format, strict) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = moment.utc([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LTS : 'h:mm:ss A',
            LT : 'h:mm A',
            L : 'MM/DD/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom, now) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom, [now]) : output;
        },

        _relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },

        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal : '%d',
        _ordinalParse : /\d{1,2}/,

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) {
                return parseTokenOneDigit;
            }
            /* falls through */
        case 'SS':
            if (strict) {
                return parseTokenTwoDigits;
            }
            /* falls through */
        case 'SSS':
            if (strict) {
                return parseTokenThreeDigits;
            }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return config._locale._meridiemParse;
        case 'x':
            return parseTokenOffsetMs;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(
                            input.match(/\d{1,2}/)[0], 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = config._locale.isPM(input);
            break;
        // HOUR
        case 'h' : // fall through to hh
        case 'hh' :
            config._pf.bigHour = true;
            /* falls through */
        case 'H' : // fall through to HH
        case 'HH' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX OFFSET (MILLISECONDS)
        case 'x':
            config._d = new Date(toInt(input));
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = config._locale.weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day || normalizedInput.date,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }
        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        res = new Moment(config);
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof(values) !== 'undefined') {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ('function' === typeof Date.prototype.toISOString) {
                    // native implementation is ~50x faster, use it when we can
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function (keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },

        local : function (keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.add(this._dateTzOffset(), 'm');
                }
            }
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add : createAdder(1, 'add'),

        subtract : createAdder(-1, 'subtract'),

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output, daysAdjust;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                daysAdjust = (this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'));
                // same as above but with zones, to negate all dst
                daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4;
                output += daysAdjust / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf : function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond') {
                return this;
            }
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },

        isBefore: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },

        isSame: function (input, units) {
            var inputMs;
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
            }
        },

        min: deprecate(
                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateTzOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._dateTzOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName : function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week : function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale : function (key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },

        lang : deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        ),

        localeData : function () {
            return this._locale;
        },

        _dateTzOffset : function () {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs : function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            var days, months;
            units = normalizeUnits(units);

            if (units === 'month' || units === 'year') {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                    case 'week': return days / 7 + this._milliseconds / 6048e5;
                    case 'day': return days + this._milliseconds / 864e5;
                    case 'hour': return days * 24 + this._milliseconds / 36e5;
                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang : moment.fn.lang,
        locale : moment.fn.locale,

        toIsoString : deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead ' +
            '(notice the capitals)',
            function () {
                return this.toISOString();
            }
        ),

        toISOString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData : function () {
            return this._locale;
        }
    });

    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
        Default Locale
    ************************************/


    // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    'Accessing Moment through the global scope is ' +
                    'deprecated, and will be removed in an upcoming ' +
                    'release.',
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === 'function' && define.amd) {
        define('moment', function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],81:[function(require,module,exports){
(function (global){

var rng;

if (global.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  _rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

module.exports = rng;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],82:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = (buf && offset) || 0, ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
    if (ii < 16) { // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;

},{"./rng":81}],83:[function(require,module,exports){
(function (Buffer,__dirname){
var expect = require('chai').expect;
var assert = require('chai').assert;


var path = require('path');
var bb = require('blue-button');
var bbg = require('../../index');

describe('parse generate parse generate', function () {
    var generatedDir = null;

    before(function () {
        generatedDir = path.join(__dirname, "../fixtures/files/generated");
        expect(generatedDir).to.exist;
    });

    it('CCD_1 should still be same', function () {
        var data = Buffer("PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pjw/eG1sLXN0eWxlc2hlZXQgdHlwZT0idGV4dC94c2wiIGhyZWY9IkNEQS54c2wiPz4KIAo8IS0tIFRpdGxlOiBVU19SZWFsbV9IZWFkZXJfVGVtcGxhdGUgLS0+CjxDbGluaWNhbERvY3VtZW50IHhtbG5zOnhzaT0iaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UiIHhtbG5zPSJ1cm46aGw3LW9yZzp2MyIKCXhtbG5zOmNkYT0idXJuOmhsNy1vcmc6djMiIHhtbG5zOnNkdGM9InVybjpobDctb3JnOnNkdGMiPgoJPCEtLSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBDREEgSGVhZGVyIAoJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJPHJlYWxtQ29kZSBjb2RlPSJVUyIvPgoJPHR5cGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xLjMiIGV4dGVuc2lvbj0iUE9DRF9IRDAwMDA0MCIvPgoJPCEtLSBVUyBHZW5lcmFsIEhlYWRlciBUZW1wbGF0ZSAtLT4KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjEuMSIvPgoJPCEtLSAqKiogTm90ZTogVGhlIG5leHQgdGVtcGxhdGVJZCwgY29kZSBhbmQgdGl0bGUgd2lsbCBkaWZmZXIgZGVwZW5kaW5nIAoJCW9uIHdoYXQgdHlwZSBvZiBkb2N1bWVudCBpcyBiZWluZyBzZW50LiAqKiogLS0+Cgk8IS0tIGNvbmZvcm1zIHRvIHRoZSBkb2N1bWVudCBzcGVjaWZpYyByZXF1aXJlbWVudHMgLS0+Cgk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4xLjIiLz4KCTxpZCBleHRlbnNpb249IlRUOTg4IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTk5LjEiLz4KCTxjb2RlIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBjb2RlPSIzNDEzMy05IgoJCWRpc3BsYXlOYW1lPSJTdW1tYXJpemF0aW9uIG9mIEVwaXNvZGUgTm90ZSIvPgoJPHRpdGxlPkNvbW11bml0eSBIZWFsdGggYW5kIEhvc3BpdGFsczogSGVhbHRoIFN1bW1hcnk8L3RpdGxlPgoJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTIwOTE1MDAwMC0wNDAwIi8+Cgk8Y29uZmlkZW50aWFsaXR5Q29kZSBjb2RlPSJOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjI1Ii8+Cgk8bGFuZ3VhZ2VDb2RlIGNvZGU9ImVuLVVTIi8+Cgk8c2V0SWQgZXh0ZW5zaW9uPSJzVFQ5ODgiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OTkuMTkiLz4KCTx2ZXJzaW9uTnVtYmVyIHZhbHVlPSIxIi8+Cgk8cmVjb3JkVGFyZ2V0PgoJCTxwYXRpZW50Um9sZT4KCQkJPGlkIGV4dGVuc2lvbj0iOTk4OTkxIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTk5LjIiLz4KCQkJPCEtLSBGYWtlIElEIHVzaW5nIEhMNyBleGFtcGxlIE9JRC4gLS0+CgkJCTxpZCBleHRlbnNpb249IjExMS0wMC0yMzMwIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjEiLz4KCQkJPCEtLSBGYWtlIFNvY2lhbCBTZWN1cml0eSBOdW1iZXIgdXNpbmcgdGhlIGFjdHVhbCBTU04gT0lELiAtLT4KCQkJPGFkZHIgdXNlPSJIUCI+CgkJCQk8IS0tIEhQIGlzICJwcmltYXJ5IGhvbWUiIGZyb20gY29kZVN5c3RlbSAyLjE2Ljg0MC4xLjExMzg4My41LjExMTkgLS0+CgkJCQk8c3RyZWV0QWRkcmVzc0xpbmU+MTM1NyBBbWJlciBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQk8Y2l0eT5CZWF2ZXJ0b248L2NpdHk+CgkJCQk8c3RhdGU+T1I8L3N0YXRlPgoJCQkJPHBvc3RhbENvZGU+OTc4Njc8L3Bvc3RhbENvZGU+CgkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCTwhLS0gVVMgaXMgIlVuaXRlZCBTdGF0ZXMiIGZyb20gSVNPIDMxNjYtMSBDb3VudHJ5IENvZGVzOiAxLjAuMzE2Ni4xIC0tPgoJCQk8L2FkZHI+CgkJCTx0ZWxlY29tIHZhbHVlPSJ0ZWw6KDgxNikyNzYtNjkwOSIgdXNlPSJIUCIvPgoJCQk8IS0tIEhQIGlzICJwcmltYXJ5IGhvbWUiIGZyb20gSEw3IEFkZHJlc3NVc2UgMi4xNi44NDAuMS4xMTM4ODMuNS4xMTE5IC0tPgoJCQk8cGF0aWVudD4KCQkJCTxuYW1lIHVzZT0iTCI+CgkJCQkJPCEtLSBMIGlzICJMZWdhbCIgZnJvbSBITDcgRW50aXR5TmFtZVVzZSAyLjE2Ljg0MC4xLjExMzg4My41LjQ1IC0tPgoJCQkJCTxnaXZlbj5Jc2FiZWxsYTwvZ2l2ZW4+CgkJCQkJPGdpdmVuPklzYTwvZ2l2ZW4+CgkJCQkJPCEtLSBDTCBpcyAiQ2FsbCBtZSIgZnJvbSBITDcgRW50aXR5TmFtZVBhcnRRdWFsaWZpZXIgMi4xNi44NDAuMS4xMTM4ODMuNS40MyAtLT4KCQkJCQk8ZmFtaWx5PkpvbmVzPC9mYW1pbHk+CgkJCQk8L25hbWU+CgkJCQk8YWRtaW5pc3RyYXRpdmVHZW5kZXJDb2RlIGNvZGU9IkYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMSIKCQkJCQlkaXNwbGF5TmFtZT0iRmVtYWxlIi8+CgkJCQk8YmlydGhUaW1lIHZhbHVlPSIxOTc1MDUwMSIvPgoJCQkJPG1hcml0YWxTdGF0dXNDb2RlIGNvZGU9Ik0iIGRpc3BsYXlOYW1lPSJNYXJyaWVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjIiCgkJCQkJY29kZVN5c3RlbU5hbWU9Ik1hcml0YWxTdGF0dXNDb2RlIi8+CgkJCQk8cmVsaWdpb3VzQWZmaWxpYXRpb25Db2RlIGNvZGU9IjEwMTMiCgkJCQkJZGlzcGxheU5hbWU9IkNocmlzdGlhbiAobm9uLUNhdGhvbGljLCBub24tc3BlY2lmaWMpIgoJCQkJCWNvZGVTeXN0ZW1OYW1lPSJITDcgUmVsaWdpb3VzIEFmZmlsaWF0aW9uIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjEwNzYiLz4KCQkJCTwhLS0gQ0RDIFJhY2UgYW5kIEV0aG5pY2l0eSBjb2RlIHNldCBjb250YWlucyB0aGUgbWluaW11bSByYWNlIGFuZCBldGhuaWNpdHkgY2F0ZWdvcmllcyBkZWZpbmVkIGJ5IE9NQiBTdGFuZGFyZHMgZm9yIFJhY2UgYW5kIEV0aG5pY2l0eSAtLT4KCQkJCTxyYWNlQ29kZSBjb2RlPSIyMTA2LTMiIGRpc3BsYXlOYW1lPSJXaGl0ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yMzgiCgkJCQkJY29kZVN5c3RlbU5hbWU9IlJhY2UgJmFtcDsgRXRobmljaXR5IC0gQ0RDIi8+CgkJCQk8ZXRobmljR3JvdXBDb2RlIGNvZGU9IjIxODYtNSIgZGlzcGxheU5hbWU9Ik5vdCBIaXNwYW5pYyBvciBMYXRpbm8iCgkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yMzgiIGNvZGVTeXN0ZW1OYW1lPSJSYWNlICZhbXA7IEV0aG5pY2l0eSAtIENEQyIvPgoJCQkJPGd1YXJkaWFuPgoJCQkJCTxjb2RlIGNvZGU9IlBSTiIgZGlzcGxheU5hbWU9IlBhcmVudCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiCgkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJITDcgUm9sZSBjb2RlIi8+CgkJCQkJPGFkZHIgdXNlPSJIUCI+CgkJCQkJCTwhLS0gSFAgaXMgInByaW1hcnkgaG9tZSIgZnJvbSBjb2RlU3lzdGVtIDIuMTYuODQwLjEuMTEzODgzLjUuMTExOSAtLT4KCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEzNTcgQW1iZXIgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPgoJCQkJCQk8Y2l0eT5CZWF2ZXJ0b248L2NpdHk+CgkJCQkJCTxzdGF0ZT5PUjwvc3RhdGU+CgkJCQkJCTxwb3N0YWxDb2RlPjk3ODY3PC9wb3N0YWxDb2RlPgoJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJPCEtLSBVUyBpcyAiVW5pdGVkIFN0YXRlcyIgZnJvbSBJU08gMzE2Ni0xIENvdW50cnkgQ29kZXM6IDEuMC4zMTY2LjEgLS0+CgkJCQkJPC9hZGRyPgoJCQkJCTx0ZWxlY29tIHZhbHVlPSJ0ZWw6KDgxNikyNzYtNjkwOSIgdXNlPSJIUCIvPgoJCQkJCTxndWFyZGlhblBlcnNvbj4KCQkJCQkJPG5hbWU+CgkJCQkJCQk8Z2l2ZW4+UmFscGg8L2dpdmVuPgoJCQkJCQkJPGZhbWlseT5Kb25lczwvZmFtaWx5PgoJCQkJCQk8L25hbWU+CgkJCQkJPC9ndWFyZGlhblBlcnNvbj4KCQkJCTwvZ3VhcmRpYW4+CgkJCQk8YmlydGhwbGFjZT4KCQkJCQk8cGxhY2U+CgkJCQkJCTxhZGRyPgoJCQkJCQkJPGNpdHk+QmVhdmVydG9uPC9jaXR5PgoJCQkJCQkJPHN0YXRlPk9SPC9zdGF0ZT4KCQkJCQkJCTxwb3N0YWxDb2RlPjk3ODY3PC9wb3N0YWxDb2RlPgoJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCTwvYWRkcj4KCQkJCQk8L3BsYWNlPgoJCQkJPC9iaXJ0aHBsYWNlPgoJCQkJPGxhbmd1YWdlQ29tbXVuaWNhdGlvbj4KCQkJCQk8bGFuZ3VhZ2VDb2RlIGNvZGU9ImVuIi8+CgkJCQkJPCEtLSBFTiBpcyAiRW5nbGlzaCIgYXMgaW4gdGhlIElHIC0tPgoJCQkJCTxtb2RlQ29kZSBjb2RlPSJFU1AiIGRpc3BsYXlOYW1lPSJFeHByZXNzZWQgc3Bva2VuIgoJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjYwIiBjb2RlU3lzdGVtTmFtZT0iTGFuZ3VhZ2VBYmlsaXR5TW9kZSIvPgoJCQkJCTxwcm9maWNpZW5jeUxldmVsQ29kZSBjb2RlPSJHIiBkaXNwbGF5TmFtZT0iR29vZCIKCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS42MSIKCQkJCQkJY29kZVN5c3RlbU5hbWU9Ikxhbmd1YWdlQWJpbGl0eVByb2ZpY2llbmN5Ii8+CgkJCQkJPHByZWZlcmVuY2VJbmQgdmFsdWU9InRydWUiLz4KCQkJCTwvbGFuZ3VhZ2VDb21tdW5pY2F0aW9uPgoJCQk8L3BhdGllbnQ+CgkJCTxwcm92aWRlck9yZ2FuaXphdGlvbj4KCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiLz4KCQkJCTxuYW1lPkNvbW11bml0eSBIZWFsdGggYW5kIEhvc3BpdGFsczwvbmFtZT4KCQkJCTx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSJ0ZWw6IDU1NS01NTUtNTAwMCIvPgoJCQkJPGFkZHI+CgkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEwMDEgVmlsbGFnZSBBdmVudWU8L3N0cmVldEFkZHJlc3NMaW5lPgoJCQkJCTxjaXR5PlBvcnRsYW5kPC9jaXR5PgoJCQkJCTxzdGF0ZT5PUjwvc3RhdGU+CgkJCQkJPHBvc3RhbENvZGU+OTkxMjM8L3Bvc3RhbENvZGU+CgkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQk8L2FkZHI+CgkJCTwvcHJvdmlkZXJPcmdhbml6YXRpb24+CgkJPC9wYXRpZW50Um9sZT4KCTwvcmVjb3JkVGFyZ2V0PgoJPGF1dGhvcj4KCQk8dGltZSB2YWx1ZT0iMjAwNTAzMjkyMjQ0MTErMDUwMCIvPgoJCTxhc3NpZ25lZEF1dGhvcj4KCQkJPGlkIGV4dGVuc2lvbj0iOTk5OTk5OTkiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIvPgoJCQk8Y29kZSBjb2RlPSIyMDAwMDAwMDBYIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMSIKCQkJCWRpc3BsYXlOYW1lPSJBbGxvcGF0aGljICZhbXA7IE9zdGVvcGF0aGljIFBoeXNpY2lhbnMiLz4KCQkJPGFkZHI+CgkJCQk8c3RyZWV0QWRkcmVzc0xpbmU+MTAwMiBIZWFsdGhjYXJlIERyaXZlIDwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQk8Y2l0eT5Qb3J0bGFuZDwvY2l0eT4KCQkJCTxzdGF0ZT5PUjwvc3RhdGU+CgkJCQk8cG9zdGFsQ29kZT45OTEyMzwvcG9zdGFsQ29kZT4KCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQk8L2FkZHI+CgkJCTx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSJ0ZWw6NTU1LTU1NS0xMDAyIi8+CgkJCTxhc3NpZ25lZFBlcnNvbj4KCQkJCTxuYW1lPgoJCQkJCTxnaXZlbj5IZW5yeTwvZ2l2ZW4+CgkJCQkJPGZhbWlseT5TZXZlbjwvZmFtaWx5PgoJCQkJPC9uYW1lPgoJCQk8L2Fzc2lnbmVkUGVyc29uPgoJCTwvYXNzaWduZWRBdXRob3I+Cgk8L2F1dGhvcj4KCTxkYXRhRW50ZXJlcj4KCQk8YXNzaWduZWRFbnRpdHk+CgkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTk5OTk5OTQzMjUyIi8+CgkJCTxhZGRyPgoJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEwMDEgVmlsbGFnZSBBdmVudWU8L3N0cmVldEFkZHJlc3NMaW5lPgoJCQkJPGNpdHk+UG9ydGxhbmQ8L2NpdHk+CgkJCQk8c3RhdGU+T1I8L3N0YXRlPgoJCQkJPHBvc3RhbENvZGU+OTkxMjM8L3Bvc3RhbENvZGU+CgkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJPC9hZGRyPgoJCQk8dGVsZWNvbSB1c2U9IldQIiB2YWx1ZT0idGVsOjU1NS01NTUtMTAwMiIvPgoJCQk8YXNzaWduZWRQZXJzb24+CgkJCQk8bmFtZT4KCQkJCQk8Z2l2ZW4+SGVucnk8L2dpdmVuPgoJCQkJCTxmYW1pbHk+U2V2ZW48L2ZhbWlseT4KCQkJCTwvbmFtZT4KCQkJPC9hc3NpZ25lZFBlcnNvbj4KCQk8L2Fzc2lnbmVkRW50aXR5PgoJPC9kYXRhRW50ZXJlcj4KCTxpbmZvcm1hbnQ+CgkJPGFzc2lnbmVkRW50aXR5PgoJCQk8aWQgZXh0ZW5zaW9uPSJLUDAwMDE3IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ii8+CgkJCTxhZGRyPgoJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEwMDEgVmlsbGFnZSBBdmVudWU8L3N0cmVldEFkZHJlc3NMaW5lPgoJCQkJPGNpdHk+UG9ydGxhbmQ8L2NpdHk+CgkJCQk8c3RhdGU+T1I8L3N0YXRlPgoJCQkJPHBvc3RhbENvZGU+OTkxMjM8L3Bvc3RhbENvZGU+CgkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJPC9hZGRyPgoJCQk8dGVsZWNvbSB1c2U9IldQIiB2YWx1ZT0idGVsOjU1NS01NTUtMTAwMiIvPgoJCQk8YXNzaWduZWRQZXJzb24+CgkJCQk8bmFtZT4KCQkJCQk8Z2l2ZW4+SGVucnk8L2dpdmVuPgoJCQkJCTxmYW1pbHk+U2V2ZW48L2ZhbWlseT4KCQkJCTwvbmFtZT4KCQkJPC9hc3NpZ25lZFBlcnNvbj4KCQk8L2Fzc2lnbmVkRW50aXR5PgoJPC9pbmZvcm1hbnQ+Cgk8aW5mb3JtYW50PgoJCTxyZWxhdGVkRW50aXR5IGNsYXNzQ29kZT0iUFJTIj4KCQkJPCEtLSBjbGFzc0NvZGUgUFJTIHJlcHJlc2VudHMgYSBwZXJzb24gd2l0aCBwZXJzb25hbCByZWxhdGlvbnNoaXAgd2l0aCAKCQkJCXRoZSBwYXRpZW50LiAtLT4KCQkJPGNvZGUgY29kZT0iU1BTIiBkaXNwbGF5TmFtZT0iU1BPVVNFIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4xLjExLjE5NTYzIgoJCQkJY29kZVN5c3RlbU5hbWU9IlBlcnNvbmFsIFJlbGF0aW9uc2hpcCBSb2xlIFR5cGUgVmFsdWUgU2V0Ii8+CgkJCTxyZWxhdGVkUGVyc29uPgoJCQkJPG5hbWU+CgkJCQkJPGdpdmVuPkZyYW5rPC9naXZlbj4KCQkJCQk8ZmFtaWx5PkpvbmVzPC9mYW1pbHk+CgkJCQk8L25hbWU+CgkJCTwvcmVsYXRlZFBlcnNvbj4KCQk8L3JlbGF0ZWRFbnRpdHk+Cgk8L2luZm9ybWFudD4KCTxjdXN0b2RpYW4+CgkJPGFzc2lnbmVkQ3VzdG9kaWFuPgoJCQk8cmVwcmVzZW50ZWRDdXN0b2RpYW5Pcmdhbml6YXRpb24+CgkJCQk8aWQgZXh0ZW5zaW9uPSI5OTk5OTk5OSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42Ii8+CgkJCQk8bmFtZT5Db21tdW5pdHkgSGVhbHRoIGFuZCBIb3NwaXRhbHM8L25hbWU+CgkJCQk8dGVsZWNvbSB2YWx1ZT0idGVsOiA1NTUtNTU1LTEwMDIiIHVzZT0iV1AiLz4KCQkJCTxhZGRyIHVzZT0iV1AiPgoJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xMDAyIEhlYWx0aGNhcmUgRHJpdmUgPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQk8Y2l0eT5Qb3J0bGFuZDwvY2l0eT4KCQkJCQk8c3RhdGU+T1I8L3N0YXRlPgoJCQkJCTxwb3N0YWxDb2RlPjk5MTIzPC9wb3N0YWxDb2RlPgoJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJPC9hZGRyPgoJCQk8L3JlcHJlc2VudGVkQ3VzdG9kaWFuT3JnYW5pemF0aW9uPgoJCTwvYXNzaWduZWRDdXN0b2RpYW4+Cgk8L2N1c3RvZGlhbj4KCTxpbmZvcm1hdGlvblJlY2lwaWVudD4KCQk8aW50ZW5kZWRSZWNpcGllbnQ+CgkJCTxpbmZvcm1hdGlvblJlY2lwaWVudD4KCQkJCTxuYW1lPgoJCQkJCTxnaXZlbj5IZW5yeTwvZ2l2ZW4+CgkJCQkJPGZhbWlseT5TZXZlbjwvZmFtaWx5PgoJCQkJPC9uYW1lPgoJCQk8L2luZm9ybWF0aW9uUmVjaXBpZW50PgoJCQk8cmVjZWl2ZWRPcmdhbml6YXRpb24+CgkJCQk8bmFtZT5Db21tdW5pdHkgSGVhbHRoIGFuZCBIb3NwaXRhbHM8L25hbWU+CgkJCTwvcmVjZWl2ZWRPcmdhbml6YXRpb24+CgkJPC9pbnRlbmRlZFJlY2lwaWVudD4KCTwvaW5mb3JtYXRpb25SZWNpcGllbnQ+Cgk8bGVnYWxBdXRoZW50aWNhdG9yPgoJCTx0aW1lIHZhbHVlPSIyMDA5MDIyNzEzMDAwMCswNTAwIi8+CgkJPHNpZ25hdHVyZUNvZGUgY29kZT0iUyIvPgoJCTxhc3NpZ25lZEVudGl0eT4KCQkJPGlkIGV4dGVuc2lvbj0iOTk5OTk5OTk5IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiLz4KCQkJPGFkZHI+CgkJCQk8c3RyZWV0QWRkcmVzc0xpbmU+MTAwMSBWaWxsYWdlIEF2ZW51ZTwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQk8Y2l0eT5Qb3J0bGFuZDwvY2l0eT4KCQkJCTxzdGF0ZT5PUjwvc3RhdGU+CgkJCQk8cG9zdGFsQ29kZT45OTEyMzwvcG9zdGFsQ29kZT4KCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQk8L2FkZHI+CgkJCTx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSJ0ZWw6NTU1LTU1NS0xMDAyIi8+CgkJCTxhc3NpZ25lZFBlcnNvbj4KCQkJCTxuYW1lPgoJCQkJCTxnaXZlbj5IZW5yeTwvZ2l2ZW4+CgkJCQkJPGZhbWlseT5TZXZlbjwvZmFtaWx5PgoJCQkJPC9uYW1lPgoJCQk8L2Fzc2lnbmVkUGVyc29uPgoJCTwvYXNzaWduZWRFbnRpdHk+Cgk8L2xlZ2FsQXV0aGVudGljYXRvcj4KCTxhdXRoZW50aWNhdG9yPgoJCTx0aW1lIHZhbHVlPSIyMDA5MDIyNzEzMDAwMCswNTAwIi8+CgkJPHNpZ25hdHVyZUNvZGUgY29kZT0iUyIvPgoJCTxhc3NpZ25lZEVudGl0eT4KCQkJPGlkIGV4dGVuc2lvbj0iOTk5OTk5OTk5IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiLz4KCQkJPGFkZHI+CgkJCQk8c3RyZWV0QWRkcmVzc0xpbmU+MTAwMSBWaWxsYWdlIEF2ZW51ZTwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQk8Y2l0eT5Qb3J0bGFuZDwvY2l0eT4KCQkJCTxzdGF0ZT5PUjwvc3RhdGU+CgkJCQk8cG9zdGFsQ29kZT45OTEyMzwvcG9zdGFsQ29kZT4KCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQk8L2FkZHI+CgkJCTx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSJ0ZWw6NTU1LTU1NS0xMDAyIi8+CgkJCTxhc3NpZ25lZFBlcnNvbj4KCQkJCTxuYW1lPgoJCQkJCTxnaXZlbj5IZW5yeTwvZ2l2ZW4+CgkJCQkJPGZhbWlseT5TZXZlbjwvZmFtaWx5PgoJCQkJPC9uYW1lPgoJCQk8L2Fzc2lnbmVkUGVyc29uPgoJCTwvYXNzaWduZWRFbnRpdHk+Cgk8L2F1dGhlbnRpY2F0b3I+Cgk8ZG9jdW1lbnRhdGlvbk9mPgoJCTxzZXJ2aWNlRXZlbnQgY2xhc3NDb2RlPSJQQ1BSIj4KCQkJPGNvZGUgY29kZT0iNzM3NjEwMDEiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiCgkJCQlkaXNwbGF5TmFtZT0iQ29sb25vc2NvcHkiLz4KCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQk8bG93IHZhbHVlPSIyMDEyMDkwODAwMDAtMDQwMCIvPgoJCQkJPGhpZ2ggdmFsdWU9IjIwMTIwOTE1MDAwMC0wNDAwIi8+CgkJCTwvZWZmZWN0aXZlVGltZT4KCQkJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4KCQkJCTxmdW5jdGlvbkNvZGUgY29kZT0iUFAiIGRpc3BsYXlOYW1lPSJQcmltYXJ5IFBlcmZvcm1lciIKCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4xMi40NDMiIGNvZGVTeXN0ZW1OYW1lPSJQcm92aWRlciBSb2xlIj4KCQkJCQk8b3JpZ2luYWxUZXh0PlByaW1hcnkgQ2FyZSBQcm92aWRlcjwvb3JpZ2luYWxUZXh0PgoJCQkJPC9mdW5jdGlvbkNvZGU+CgkJCQk8YXNzaWduZWRFbnRpdHk+CgkJCQkJPCEtLSBQcm92aWRlciBOUEkgIlBzZXVkb01ELTEiIC0tPgoJCQkJCTxpZCBleHRlbnNpb249IlBzZXVkb01ELTEiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIvPgoJCQkJCTxjb2RlIGNvZGU9IjIwN1JHMDEwMFgiIGRpc3BsYXlOYW1lPSJHYXN0cm9lbnRlcm9sb2dpc3QiCgkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJQcm92aWRlciBDb2RlcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDEiLz4KCQkJCQk8YWRkcj4KCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEwMDEgVmlsbGFnZSBBdmVudWU8L3N0cmVldEFkZHJlc3NMaW5lPgoJCQkJCQk8Y2l0eT5Qb3J0bGFuZDwvY2l0eT4KCQkJCQkJPHN0YXRlPk9SPC9zdGF0ZT4KCQkJCQkJPHBvc3RhbENvZGU+OTkxMjM8L3Bvc3RhbENvZGU+CgkJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJCTwvYWRkcj4KCQkJCQk8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTU1NS01NTUtNTAwMCIgdXNlPSJIUCIvPgoJCQkJCTxhc3NpZ25lZFBlcnNvbj4KCQkJCQkJPG5hbWU+CgkJCQkJCQk8cHJlZml4PkRyLjwvcHJlZml4PgoJCQkJCQkJPGdpdmVuPkhlbnJ5PC9naXZlbj4KCQkJCQkJCTxmYW1pbHk+U2V2ZW48L2ZhbWlseT4KCQkJCQkJPC9uYW1lPgoJCQkJCTwvYXNzaWduZWRQZXJzb24+CgkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPgoJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTMiLz4KCQkJCQkJPG5hbWU+Q29tbXVuaXR5IEhlYWx0aCBhbmQgSG9zcGl0YWxzPC9uYW1lPgoJCQkJCQk8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTU1NS01NTUtNTAwMCIgdXNlPSJIUCIvPgoJCQkJCQk8YWRkcj4KCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xMDAxIFZpbGxhZ2UgQXZlbnVlPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCTxjaXR5PlBvcnRsYW5kPC9jaXR5PgoJCQkJCQkJPHN0YXRlPk9SPC9zdGF0ZT4KCQkJCQkJCTxwb3N0YWxDb2RlPjk5MTIzPC9wb3N0YWxDb2RlPgoJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCTwvYWRkcj4KCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPgoJCQkJPC9hc3NpZ25lZEVudGl0eT4KCQkJPC9wZXJmb3JtZXI+CgkJPC9zZXJ2aWNlRXZlbnQ+Cgk8L2RvY3VtZW50YXRpb25PZj4KCTwhLS0gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQ0RBIEJvZHkgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogLS0+Cgk8Y29tcG9uZW50PgoJCTxzdHJ1Y3R1cmVkQm9keT4KCQkJPCEtLSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQURWQU5DRSBESVJFQ1RJVkVTKioqKioqKioqKioqKioqKioqKioqKioqKiogLS0+CgkJCTxjb21wb25lbnQ+CgkJCQk8c2VjdGlvbj4KCQkJCQk8IS0tIGNvbmZvcm1zIHRvIEFkdmFuY2UgRGlyZWN0aXZlcyBzZWN0aW9uIHdpdGggZW50cmllcyBvcHRpb25hbCAtLT4KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjIxIi8+CgkJCQkJPCEtLSBBZHZhbmNlIERpcmVjdGl2ZXMgc2VjdGlvbiB3aXRoIGVudHJpZXMgcmVxdWlyZWQgLS0+CgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4yMS4xIi8+CgkJCQkJPGNvZGUgY29kZT0iNDIzNDgtMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+CgkJCQkJPHRpdGxlPkFEVkFOQ0UgRElSRUNUSVZFUzwvdGl0bGU+CgkJCQkJPHRleHQ+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5EaXJlY3RpdmU8L3RoPgoJCQkJCQkJCQk8dGg+RGVzY3JpcHRpb248L3RoPgoJCQkJCQkJCQk8dGg+VmVyaWZpY2F0aW9uPC90aD4KCQkJCQkJCQkJPHRoPlN1cHBvcnRpbmcgRG9jdW1lbnQocyk8L3RoPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3RoZWFkPgoJCQkJCQkJPHRib2R5PgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPlJlc3VzY2l0YXRpb24gc3RhdHVzPC90ZD4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9IkFEMSI+RG8gbm90IHJlc3VzY2l0YXRlPC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+RHIuIFJvYmVydCBEb2xpbiwgRmViIDEzLCAyMDExPC90ZD4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGxpbmtIdG1sCgkJCQkJCQkJCQkJaHJlZj0iQWR2YW5jZURpcmVjdGl2ZS5iNTBiNzkxMC03ZmZiLTRmNGMtYmJlNC0xNzdlZDY4Y2JiZjMucGRmIgoJCQkJCQkJCQkJCT5BZHZhbmNlIGRpcmVjdGl2ZTwvbGlua0h0bWw+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGJvZHk+CgkJCQkJCTwvdGFibGU+CgkJCQkJPC90ZXh0PgoJCQkJCTxlbnRyeT4KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDgiLz4KCQkJCQkJCTwhLS0gKiogQWR2YW5jZSBEaXJlY3RpdmUgT2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQk8aWQgcm9vdD0iOWI1NGMzYzktMTY3My00OWM3LWFlZjktYjAzN2VkNzJlZDI3Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSIzMDQyNTEwMDgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJZGlzcGxheU5hbWU9IlJlc3VzY2l0YXRpb24iLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAxMTAyMTMiLz4KCQkJCQkJCQk8aGlnaCBudWxsRmxhdm9yPSJOQSIvPgoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMzA0MjUzMDA2IgoJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJEbyBub3QgcmVzdXNjaXRhdGUiPgoJCQkJCQkJCTxvcmlnaW5hbFRleHQ+CgkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNBRDEiLz4KCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCTwvdmFsdWU+CgkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IlZSRiI+CgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41OCIvPgoJCQkJCQkJCTx0aW1lIHZhbHVlPSIyMDExMDIwMTMiLz4KCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlPgoJCQkJCQkJCQk8aWQgcm9vdD0iMjBjZjE0ZmItYjY1Yy00YzhjLWE1NGQtYjBjY2E4MzRjMThjIi8+CgkJCQkJCQkJCTxwbGF5aW5nRW50aXR5PgoJCQkJCQkJCQkJPG5hbWU+CgkJCQkJCQkJCQkJPHByZWZpeD5Eci48L3ByZWZpeD4KCQkJCQkJCQkJCQk8ZmFtaWx5PkRvbGluPC9mYW1pbHk+CgkJCQkJCQkJCQkJPGdpdmVuPlJvYmVydDwvZ2l2ZW4+CgkJCQkJCQkJCQk8L25hbWU+CgkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4KCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4KCQkJCQkJCTwvcGFydGljaXBhbnQ+CgkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTVCI+CgkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IkFHTlQiPgoJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4yMSBOb3J0aCBBdmUuPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCTxjaXR5PkJ1cmxpbmd0b248L2NpdHk+CgkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJPHBvc3RhbENvZGU+MDIzNjg8L3Bvc3RhbENvZGU+CgkJCQkJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQk8dGVsZWNvbSB2YWx1ZT0idGVsOig1NTUpNTU1LTEwMDMiLz4KCQkJCQkJCQkJPHBsYXlpbmdFbnRpdHk+CgkJCQkJCQkJCQk8bmFtZT4KCQkJCQkJCQkJCQk8cHJlZml4PkRyLjwvcHJlZml4PgoJCQkJCQkJCQkJCTxmYW1pbHk+RG9saW48L2ZhbWlseT4KCQkJCQkJCQkJCQk8Z2l2ZW4+Um9iZXJ0PC9naXZlbj4KCQkJCQkJCQkJCTwvbmFtZT4KCQkJCQkJCQkJPC9wbGF5aW5nRW50aXR5PgoJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPgoJCQkJCQkJPC9wYXJ0aWNpcGFudD4KCQkJCQkJCTxyZWZlcmVuY2UgdHlwZUNvZGU9IlJFRlIiPgoJCQkJCQkJCTxzZXBlcmF0YWJsZUluZCB2YWx1ZT0iZmFsc2UiLz4KCQkJCQkJCQk8ZXh0ZXJuYWxEb2N1bWVudD4KCQkJCQkJCQkJPGlkIHJvb3Q9ImI1MGI3OTEwLTdmZmItNGY0Yy1iYmU0LTE3N2VkNjhjYmJmMyIvPgoJCQkJCQkJCQk8dGV4dCBtZWRpYVR5cGU9ImFwcGxpY2F0aW9uL3BkZiI+CgkJCQkJCQkJCQk8cmVmZXJlbmNlCgkJCQkJCQkJCQkJdmFsdWU9IkFkdmFuY2VEaXJlY3RpdmUuYjUwYjc5MTAtN2ZmYi00ZjRjLWJiZTQtMTc3ZWQ2OGNiYmYzLnBkZiIKCQkJCQkJCQkJCS8+CgkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQk8L2V4dGVybmFsRG9jdW1lbnQ+CgkJCQkJCQk8L3JlZmVyZW5jZT4KCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQk8L2VudHJ5PgoJCQkJPC9zZWN0aW9uPgoJCQk8L2NvbXBvbmVudD4KCQkJPCEtLSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQWxsZXJnaWVzLCBBZHZlcnNlIFJlYWN0aW9ucywgQWxlcnRzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAtLT4KCQkJPGNvbXBvbmVudD4KCQkJCTxzZWN0aW9uPgoJCQkJCTwhLS0gY29uZm9ybXMgdG8gQWxsZXJnaWVzIHNlY3Rpb24gd2l0aCBlbnRyaWVzIG9wdGlvbmFsIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuNiIvPgoJCQkJCTwhLS0gQWxsZXJnaWVzIHNlY3Rpb24gd2l0aCBlbnRyaWVzIHJlcXVpcmVkIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuNi4xIi8+CgkJCQkJPGNvZGUgY29kZT0iNDg3NjUtMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+CgkJCQkJPHRpdGxlPkFMTEVSR0lFUywgQURWRVJTRSBSRUFDVElPTlMsIEFMRVJUUzwvdGl0bGU+CgkJCQkJPHRleHQ+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5TdWJzdGFuY2U8L3RoPgoJCQkJCQkJCQk8dGg+T3ZlcmFsbCBTZXZlcml0eTwvdGg+CgkJCQkJCQkJCTx0aD5SZWFjdGlvbjwvdGg+CgkJCQkJCQkJCTx0aD5SZWFjdGlvbiBTZXZlcml0eTwvdGg+CgkJCQkJCQkJCTx0aD5TdGF0dXM8L3RoPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3RoZWFkPgoJCQkJCQkJPHRib2R5PgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPkFMTEVSR0VOSUMgRVhUUkFDVCwgUEVOSUNJTExJTjwvdGQ+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJzZXZlcml0eTQiPk1vZGVyYXRlIHRvIFNldmVyZTwvY29udGVudD4KCQkJCQkJCQkJPC90ZD4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InJlYWN0aW9uMSI+TmF1c2VhPC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+CgkJCQkJCQkJCQk8Y29udGVudCBJRD0ic2V2ZXJpdHkxIj5NaWxkPC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+SW5hY3RpdmU8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+Q29kZWluZTwvdGQ+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJzZXZlcml0eTUiPk1pbGQ8L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJyZWFjdGlvbjIiPldoZWV6aW5nPC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+CgkJCQkJCQkJCQk8Y29udGVudCBJRD0ic2V2ZXJpdHkyIj5Nb2RlcmF0ZTwvY29udGVudD4KCQkJCQkJCQkJPC90ZD4KCQkJCQkJCQkJPHRkPkFjdGl2ZTwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5Bc3BpcmluPC90ZD4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InNldmVyaXR5NiI+TWlsZDwvY29udGVudD4KCQkJCQkJCQkJPC90ZD4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InJlYWN0aW9uMyI+SGl2ZXM8L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJzZXZlcml0eTMiPk1pbGQgdG8gbW9kZXJhdGU8L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJCTx0ZD5BY3RpdmU8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3Rib2R5PgoJCQkJCQk8L3RhYmxlPgoJCQkJCTwvdGV4dD4KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPgoJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCTwhLS0gKiogQWxsZXJneSBwcm9ibGVtIGFjdCAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzAiLz4KCQkJCQkJCTxpZCByb290PSIzNmUzZTkzMC03YjE0LTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4KCQkJCQkJCTxjb2RlIGNvZGU9IjQ4NzY1LTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTE9JTkMiCgkJCQkJCQkJZGlzcGxheU5hbWU9IkFsbGVyZ2llcywgYWR2ZXJzZSByZWFjdGlvbnMsIGFsZXJ0cyIvPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iYWN0aXZlIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA1MDEiLz4KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIEFsbGVyZ3kgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNyIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iNGFkYzEwMjAtN2IxNC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJCTxsb3cgdmFsdWU9IjIwMDcwNTAxIi8+CgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNDE5NTExMDAzIgoJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gZHJ1ZyIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4KCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+CgkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3JlYWN0aW9uMSIvPgoJCQkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+CgkJCQkJCQkJCTwvdmFsdWU+CgkJCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQ1NNIj4KCQkJCQkJCQkJCTxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJNQU5VIj4KCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPgoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMTQ0MjIiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJBTExFUkdFTklDIEVYVFJBQ1QsIFBFTklDSUxMSU4iCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPgoJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcmVhY3Rpb24xIi8+CgkJCQkJCQkJCQkJCTwvb3JpZ2luYWxUZXh0PgoJCQkJCQkJCQkJCQk8L2NvZGU+CgkJCQkJCQkJCQkJPC9wbGF5aW5nRW50aXR5PgoJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+CgkJCQkJCQkJCTwvcGFydGljaXBhbnQ+CgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBBbGxlcmd5IHN0YXR1cyBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI4Ii8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTE9JTkMiIGRpc3BsYXlOYW1lPSJTdGF0dXMiLz4KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNFIiBjb2RlPSI3MzQyNTAwNyIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IkluYWN0aXZlIi8+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9Ik1GU1QiIGludmVyc2lvbkluZD0idHJ1ZSI+CgkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQkJCTwhLS0gKiogUmVhY3Rpb24gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC45Ii8+CgkJCQkJCQkJCQkJPGlkIHJvb3Q9IjRhZGMxMDIwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NCIvPgoJCQkJCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIi8+CgkJCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNyZWFjdGlvbjEiLz4KCQkJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCQkJCTxsb3cgdmFsdWU9IjIwMDcwNTAxIi8+CgkJCQkJCQkJCQkJCTxoaWdoIHZhbHVlPSIyMDA5MDIyNzEzMDAwMCswNTAwIi8+CgkJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjQyMjU4NzAwNyIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9Ik5hdXNlYSIvPgoJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQkJPCEtLSAqKiBTZXZlcml0eSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC44Ii8+CgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IlNFViIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlNldmVyaXR5IE9ic2VydmF0aW9uIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIi8+CgkJCQkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjc2V2ZXJpdHk0Ii8+CgkJCQkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjI1NTYwNDAwMiIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9Ik1pbGQiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiLz4KCQkJCQkJCQkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJTIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iU3VjZXB0aWJsZSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMS4xMS43OCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIi8+CgkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBTZXZlcml0eSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjgiLz4KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJTRVYiIGRpc3BsYXlOYW1lPSJTZXZlcml0eSBPYnNlcnZhdGlvbiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSIvPgoJCQkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjc2V2ZXJpdHkyIi8+CgkJCQkJCQkJCQkJPC90ZXh0PgoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjM3MTkyNDAwOSIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9Ik1vZGVyYXRlIHRvIHNldmVyZSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIvPgoJCQkJCQkJCQkJCTxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMS4xMS43OCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIi8+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQk8L2FjdD4KCQkJCQk8L2VudHJ5PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBBbGxlcmd5IHByb2JsZW0gYWN0ICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMCIvPgoJCQkJCQkJPGlkIHJvb3Q9IjM2ZTNlOTMwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJPGNvZGUgY29kZT0iNDg3NjUtMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIgoJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJCQlkaXNwbGF5TmFtZT0iQWxsZXJnaWVzLCBhZHZlcnNlIHJlYWN0aW9ucywgYWxlcnRzIi8+CgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiLz4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA2MDUwMSIvPgoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPgoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCTwhLS0gKiogQWxsZXJneSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC43Ii8+CgkJCQkJCQkJCTxpZCByb290PSI0YWRjMTAyMC03YjE0LTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4KCQkJCQkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiLz4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwNjA1MDEiLz4KCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSI0MTk1MTEwMDMiCgkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iUHJvcGVuc2l0eSB0byBhZHZlcnNlIHJlYWN0aW9ucyB0byBkcnVnIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPgoJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcmVhY3Rpb24yIi8+CgkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJPC92YWx1ZT4KCQkJCQkJCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDU00iPgoJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPgoJCQkJCQkJCQkJCTxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iTU1BVCI+CgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjI2NzAiIGRpc3BsYXlOYW1lPSJDb2RlaW5lIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4KCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3JlYWN0aW9uMiIvPgoJCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPC9jb2RlPgoJCQkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4KCQkJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPgoJCQkJCQkJCQk8L3BhcnRpY2lwYW50PgoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+CgkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQkJCTwhLS0gKiogQWxsZXJneSBzdGF0dXMgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yOCIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBkaXNwbGF5TmFtZT0iU3RhdHVzIi8+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRSIgY29kZT0iNTU1NjEwMDMiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJBY3RpdmUiLz4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iTUZTVCIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBSZWFjdGlvbiBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjkiLz4KCQkJCQkJCQkJCQk8aWQgcm9vdD0iNGFkYzEwMjAtN2IxNC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY0Ii8+CgkJCQkJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiLz4KCQkJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3JlYWN0aW9uMiIvPgoJCQkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwNjA1MDEiLz4KCQkJCQkJCQkJCQkJPGhpZ2ggdmFsdWU9IjIwMDkwMjI3MTMwMDAwKzA1MDAiLz4KCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNTYwMTgwMDQiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJXaGVlemluZyIvPgoJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQkJPCEtLSAqKiBTZXZlcml0eSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC44Ii8+CgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IlNFViIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlNldmVyaXR5IE9ic2VydmF0aW9uIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIi8+CgkJCQkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjc2V2ZXJpdHk1Ii8+CgkJCQkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjI1NTYwNDAwMiIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9Ik1pbGQiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiLz4KCQkJCQkJCQkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJTIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iU3VjZXB0aWJsZSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMS4xMS43OCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIi8+CgkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBTZXZlcml0eSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjgiLz4KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJTRVYiIGRpc3BsYXlOYW1lPSJTZXZlcml0eSBPYnNlcnZhdGlvbiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSIvPgoJCQkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjc2V2ZXJpdHkyIi8+CgkJCQkJCQkJCQkJPC90ZXh0PgoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjY3MzYwMDciCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJNb2RlcmF0ZSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIvPgoJCQkJCQkJCQkJCTxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMS4xMS43OCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIi8+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQk8L2FjdD4KCQkJCQk8L2VudHJ5PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBBbGxlcmd5IHByb2JsZW0gYWN0ICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMCIvPgoJCQkJCQkJPGlkIHJvb3Q9IjM2ZTNlOTMwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJPGNvZGUgY29kZT0iNDg3NjUtMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIgoJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJCQlkaXNwbGF5TmFtZT0iQWxsZXJnaWVzLCBhZHZlcnNlIHJlYWN0aW9ucywgYWxlcnRzIi8+CgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiLz4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDUwMSIvPgoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPgoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCTwhLS0gKiogQWxsZXJneSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC43Ii8+CgkJCQkJCQkJCTxpZCByb290PSI0YWRjMTAyMC03YjE0LTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4KCQkJCQkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiLz4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwODA1MDEiLz4KCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSI1OTAzNzAwNyIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJEcnVnIGludG9sZXJhbmNlIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPgoJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcmVhY3Rpb24zIi8+CgkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJPC92YWx1ZT4KCQkJCQkJCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDU00iPgoJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPgoJCQkJCQkJCQkJCTxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iTU1BVCI+CgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjExOTEiIGRpc3BsYXlOYW1lPSJBc3BpcmluIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4KCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3JlYWN0aW9uMyIvPgoJCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPC9jb2RlPgoJCQkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4KCQkJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPgoJCQkJCQkJCQk8L3BhcnRpY2lwYW50PgoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+CgkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQkJCTwhLS0gKiogQWxsZXJneSBzdGF0dXMgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yOCIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBkaXNwbGF5TmFtZT0iU3RhdHVzIi8+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRSIgY29kZT0iNTU1NjEwMDMiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJBY3RpdmUiLz4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iTUZTVCIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBSZWFjdGlvbiBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjkiLz4KCQkJCQkJCQkJCQk8aWQgcm9vdD0iNGFkYzEwMjAtN2IxNC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY0Ii8+CgkJCQkJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiLz4KCQkJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3JlYWN0aW9uMyIvPgoJCQkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwODA1MDEiLz4KCQkJCQkJCQkJCQkJPGhpZ2ggdmFsdWU9IjIwMDkwMjI3MTMwMDAwKzA1MDAiLz4KCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMjQ3NDcyMDA0IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iSGl2ZXMiLz4KCQkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+CgkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJCTwhLS0gKiogU2V2ZXJpdHkgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuOCIvPgoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJTRVYiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJTZXZlcml0eSBPYnNlcnZhdGlvbiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSIvPgoJCQkJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3NldmVyaXR5NiIvPgoJCQkJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIzNzE5MjMwMDMiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJNaWxkIHRvIG1vZGVyYXRlIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIi8+CgkJCQkJCQkJCQkJCTxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iUyIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlN1Y2VwdGlibGUiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjEuMTEuNzgiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbiBJbnRlcnByZXRhdGlvbiIvPgoJCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+CgkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQkJCTwhLS0gKiogU2V2ZXJpdHkgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC44Ii8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iU0VWIiBkaXNwbGF5TmFtZT0iU2V2ZXJpdHkgT2JzZXJ2YXRpb24iCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiLz4KCQkJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3NldmVyaXR5MyIvPgoJCQkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIzNzE5MjMwMDMiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJNaWxkIHRvIG1vZGVyYXRlIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIi8+CgkJCQkJCQkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4xLjExLjc4IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb24gSW50ZXJwcmV0YXRpb24iLz4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCTwvYWN0PgoJCQkJCTwvZW50cnk+CgkJCQk8L3NlY3Rpb24+CgkJCTwvY29tcG9uZW50PgoJCQk8IS0tICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBBU1NFU1NNRU5UICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAtLT4KCQkJPGNvbXBvbmVudD4KCQkJCTxzZWN0aW9uPgoJCQkJCTwhLS0gQXNzZXNzbWVudCBzZWN0aW9uIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuOCIvPgoJCQkJCTxjb2RlIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBjb2RlPSI1MTg0OC0wIgoJCQkJCQlkaXNwbGF5TmFtZT0iQVNTRVNTTUVOVCIvPgoJCQkJCTx0aXRsZT5BU1NFU1NNRU5UPC90aXRsZT4KCQkJCQk8dGV4dD4KCQkJCQkJPGxpc3QgbGlzdFR5cGU9Im9yZGVyZWQiPgoJCQkJCQkJPGl0ZW0+UmVjdXJyZW50IEdJIGJsZWVkIG9mIHVua25vd24gZXRpb2xvZ3k7IGh5cG90ZW5zaW9uIHBlcmhhcHMKCQkJCQkJCQlzZWNvbmRhcnkgdG8gdGhpcyBidXQgYXMgbGlrZWx5IHNlY29uZGFyeSB0byBwb2x5cGhhcm1hY3kuPC9pdGVtPgoJCQkJCQkJPGl0ZW0+QWN1dGUgb24gY2hyb25pYyBhbmVtaWEgc2Vjb25kYXJ5IHRvICMxLjwvaXRlbT4KCQkJCQkJCTxpdGVtPkF6b3RlbWlhLCBhY3V0ZSByZW5hbCBmYWlsdXJlIHdpdGggdm9sdW1lIGxvc3Mgc2Vjb25kYXJ5IHRvCgkJCQkJCQkJIzEuPC9pdGVtPgoJCQkJCQkJPGl0ZW0+SHlwZXJrYWxlbWlhIHNlY29uZGFyeSB0byAjMyBhbmQgb24gQUNFIGFuZCBLKyBzdXBwbGVtZW50LjwvaXRlbT4KCQkJCQkJCTxpdGVtPk90aGVyIGNocm9uaWMgZGlhZ25vc2VzIGFzIG5vdGVkIGFib3ZlLCBjdXJyZW50bHkgc3RhYmxlLjwvaXRlbT4KCQkJCQkJPC9saXN0PgoJCQkJCTwvdGV4dD4KCQkJCTwvc2VjdGlvbj4KCQkJPC9jb21wb25lbnQ+CgkJCTwhLS0gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkNPVU5URVJTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBjb25mb3JtcyB0byBFbmNvdW50ZXJzIHNlY3Rpb24gd2l0aCBlbnRyaWVzIG9wdGlvbmFsIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMjIiLz4KCQkJCQk8IS0tIEVuY291bnRlcnMgc2VjdGlvbiB3aXRoIGVudHJpZXMgcmVxdWlyZWQgLS0+CgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4yMi4xIi8+CgkJCQkJPGNvZGUgY29kZT0iNDYyNDAtOCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiCgkJCQkJCWRpc3BsYXlOYW1lPSJIaXN0b3J5IG9mIGVuY291bnRlcnMiLz4KCQkJCQk8dGl0bGU+RU5DT1VOVEVSUzwvdGl0bGU+CgkJCQkJPHRleHQ+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5FbmNvdW50ZXI8L3RoPgoJCQkJCQkJCQk8dGg+UGVyZm9ybWVyPC90aD4KCQkJCQkJCQkJPHRoPkxvY2F0aW9uPC90aD4KCQkJCQkJCQkJPHRoPkRhdGU8L3RoPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3RoZWFkPgoJCQkJCQkJPHRib2R5PgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9IkVuY291bnRlcjEiLz4gQ2hlY2t1cCBFeGFtaW5hdGlvbiA8L3RkPgoJCQkJCQkJCQk8dGQ+UGVyZm9ybWVyIE5hbWU8L3RkPgoJCQkJCQkJCQk8dGQ+Q29tbXVuaXR5IFVyZ2VudCBDYXJlIENlbnRlcjwvdGQ+CgkJCQkJCQkJCTx0ZD4yMDA5MDIyNzEzMDAwMCswNTAwPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90Ym9keT4KCQkJCQkJPC90YWJsZT4KCQkJCQk8L3RleHQ+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQk8IS0tICoqIEVuY291bnRlciBhY3Rpdml0aWVzICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40OSIvPgoJCQkJCQkJPGlkIHJvb3Q9IjJhNjIwMTU1LTlkMTEtNDM5ZS05MmIzLTVkOTgxNWZmNGRlOCIvPgoJCQkJCQkJPGNvZGUgY29kZT0iOTkyMTMiIGRpc3BsYXlOYW1lPSJPZmZpY2Ugb3V0cGF0aWVudCB2aXNpdCAxNSBtaW51dGVzIgoJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJDUFQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTIiCgkJCQkJCQkJY29kZVN5c3RlbVZlcnNpb249IjQiPgoJCQkJCQkJCTxvcmlnaW5hbFRleHQ+IENoZWNrdXAgRXhhbWluYXRpb24gPHJlZmVyZW5jZSB2YWx1ZT0iI0VuY291bnRlcjEiLz4KCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iQU1CIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiCgkJCQkJCQkJCWRpc3BsYXlOYW1lPSJBbWJ1bGF0b3J5IiBjb2RlU3lzdGVtTmFtZT0iSEw3IEFjdEVuY291bnRlckNvZGUiLz4KCQkJCQkJCTwvY29kZT4KCQkJCQkJCTwhLS0gRmVicnVhcnkgMjcsIDIwMDkgYXQgMTowMFBNIEVTVCAtLT4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA5MDIyNzEzMDAwMCswNTAwIi8+CgkJCQkJCQk8cGVyZm9ybWVyPgoJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4KCQkJCQkJCQkJPCEtLSBQcm92aWRlciBOUEkgIlBzZWR1b01ELTMiIC0tPgoJCQkJCQkJCQk8aWQgcm9vdD0iUHNlZHVvTUQtMyIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI1OTA1ODAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIGRpc3BsYXlOYW1lPSJHZW5lcmFsIFBoeXNpY2lhbiIvPgoJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+CgkJCQkJCQk8L3BlcmZvcm1lcj4KCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iTE9DIj4KCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iU0RMT0MiPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMyIi8+CgkJCQkJCQkJCTwhLS0gU2VydmljZSBEZWxpdmVyeSBMb2NhdGlvbiB0ZW1wbGF0ZSAtLT4KCQkJCQkJCQkJPGNvZGUgY29kZT0iMTE2MC0xIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1OSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJIZWFsdGhjYXJlU2VydmljZUxvY2F0aW9uIgoJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlVyZ2VudCBDYXJlIENlbnRlciIvPgoJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xNyBEYXdzIFJkLjwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQkJCQkJCQk8Y2l0eT5CbHVlIEJlbGw8L2NpdHk+CgkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJPHBvc3RhbENvZGU+MDIzNjg8L3Bvc3RhbENvZGU+CgkJCQkJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQk8dGVsZWNvbSBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPgoJCQkJCQkJCQkJPG5hbWU+Q29tbXVuaXR5IFVyZ2VudCBDYXJlIENlbnRlcjwvbmFtZT4KCQkJCQkJCQkJPC9wbGF5aW5nRW50aXR5PgoJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPgoJCQkJCQkJPC9wYXJ0aWNpcGFudD4KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+CgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xOSIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iZGI3MzQ2NDctZmM5OS00MjRjLWE4NjQtN2UzY2RhODJlNzAzIgoJCQkJCQkJCQkJZXh0ZW5zaW9uPSI0NTY2NSIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI0MDQ2ODQwMDMiIGRpc3BsYXlOYW1lPSJGaW5kaW5nIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiLz4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwNzAxMDMiLz4KCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIyMzM2MDQwMDciIGRpc3BsYXlOYW1lPSJQbmV1bW9uaWEiCgkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2Ii8+CgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCTwvZW5jb3VudGVyPgoJCQkJCTwvZW50cnk+CgkJCQk8L3NlY3Rpb24+CgkJCTwvY29tcG9uZW50PgoJCQk8IS0tICoqKioqKioqKioqKioqKioqKioqKioqKiBGQU1JTFkgSElTVE9SWSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBGYW1pbHkgaGlzdG9yeSBzZWN0aW9uIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMTUiLz4KCQkJCQk8Y29kZSBjb2RlPSIxMDE1Ny02IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiLz4KCQkJCQk8dGl0bGU+RkFNSUxZIEhJU1RPUlk8L3RpdGxlPgoJCQkJCTx0ZXh0PgoJCQkJCQk8cGFyYWdyYXBoPkZhdGhlciAoZGVjZWFzZWQpPC9wYXJhZ3JhcGg+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5EaWFnbm9zaXM8L3RoPgoJCQkJCQkJCQk8dGg+QWdlIEF0IE9uc2V0PC90aD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90aGVhZD4KCQkJCQkJCTx0Ym9keT4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5NeW9jYXJkaWFsIEluZmFyY3Rpb24gKGNhdXNlIG9mIGRlYXRoKTwvdGQ+CgkJCQkJCQkJCTx0ZD41NzwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5EaWFiZXRlczwvdGQ+CgkJCQkJCQkJCTx0ZD40MDwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGJvZHk+CgkJCQkJCTwvdGFibGU+CgkJCQkJPC90ZXh0PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxvcmdhbml6ZXIgbW9vZENvZGU9IkVWTiIgY2xhc3NDb2RlPSJDTFVTVEVSIj4KCQkJCQkJCTwhLS0gKiogRmFtaWx5IGhpc3Rvcnkgb3JnYW5pemVyICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40NSIvPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8c3ViamVjdD4KCQkJCQkJCQk8cmVsYXRlZFN1YmplY3QgY2xhc3NDb2RlPSJQUlMiPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSJGVEgiIGRpc3BsYXlOYW1lPSJGYXRoZXIiCgkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iRmFtaWx5UmVsYXRpb25zaGlwUm9sZVR5cGUiCgkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMSI+CgkJCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iOTk0NzAwOCIgZGlzcGxheU5hbWU9IkJpb2xvZ2ljYWwgZmF0aGVyIgoJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQiCgkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIvPgoJCQkJCQkJCQk8L2NvZGU+CgkJCQkJCQkJCTxzdWJqZWN0PgoJCQkJCQkJCQkJPHNkdGM6aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5OS4yIgoJCQkJCQkJCQkJCWV4dGVuc2lvbj0iOTk5OTk5OTkiLz4KCQkJCQkJCQkJCTxhZG1pbmlzdHJhdGl2ZUdlbmRlckNvZGUgY29kZT0iTSIKCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjEiIGRpc3BsYXlOYW1lPSJNYWxlIi8+CgkJCQkJCQkJCQk8YmlydGhUaW1lIHZhbHVlPSIxOTEwIi8+CgkJCQkJCQkJCQk8IS0tIEV4YW1wbGUgdXNlIG9mIHNkdGMgZXh0ZW5zaW9ucyBpbmNsdWRlZCBiZWxvdyBpbiBjb21tZW50cyAtLT4KCQkJCQkJCQkJCTwhLS0gPHNkdGM6ZGVjZWFzZWRJbmQgdmFsdWU9InRydWUiLz4gPHNkdGM6ZGVjZWFzZWRUaW1lIHZhbHVlPSIxOTY3Ii8+IC0tPgoJCQkJCQkJCQk8L3N1YmplY3Q+CgkJCQkJCQkJPC9yZWxhdGVkU3ViamVjdD4KCQkJCQkJCTwvc3ViamVjdD4KCQkJCQkJCTxjb21wb25lbnQ+CgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJPCEtLSAqKiBGYW1pbHkgaGlzdG9yeSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40NiIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iZDQyZWJmNzAtNWM4OS0xMWRiLWIwZGUtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IjY0NTcyMDAxIiBkaXNwbGF5TmFtZT0iQ29uZGl0aW9uIgoJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiLz4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIxOTY3Ii8+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjIyMjk4MDA2IgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJNeW9jYXJkaWFsIGluZmFyY3Rpb24iLz4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJDQVVTIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBGYW1pbHkgaGlzdG9yeSBkZWF0aCBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQ3Ii8+CgkJCQkJCQkJCQkJPGlkIHJvb3Q9IjY4OThmYWUwLTVjOGEtMTFkYi1iMGRlLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNDE5MDk5MDA5IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iRGVhZCIvPgoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPgoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQk8IS0tICoqIEFnZSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMxIi8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNDQ1NTE4MDA4IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iQWdlIEF0IE9uc2V0Ii8+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjU3IiB1bml0PSJhIi8+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQk8L2NvbXBvbmVudD4KCQkJCQkJCTxjb21wb25lbnQ+CgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJPCEtLSAqKiBGYW1pbHkgaGlzdG9yeSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40NiIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iNWJmZTNlYzAtNWM4Yi0xMWRiLWIwZGUtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IjY0NTcyMDAxIiBkaXNwbGF5TmFtZT0iQ29uZGl0aW9uIgoJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiLz4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIxOTUwIi8+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjQ0MDU0MDA2IgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJEaWFiZXRlcyBtZWxsaXR1cyB0eXBlIDIiLz4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPgoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQk8IS0tICoqIEFnZSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMxIi8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNDQ1NTE4MDA4IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iQWdlIEF0IE9uc2V0Ii8+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjQwIiB1bml0PSJhIi8+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQk8L2NvbXBvbmVudD4KCQkJCQkJPC9vcmdhbml6ZXI+CgkJCQkJPC9lbnRyeT4KCQkJCTwvc2VjdGlvbj4KCQkJPC9jb21wb25lbnQ+CgkJCTwhLS0gKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBGVU5DVElPTkFMIFNUQVRVUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogLS0+CgkJCTxjb21wb25lbnQ+CgkJCQk8c2VjdGlvbj4KCQkJCQk8IS0tIEZ1bmN0aW9uYWwgc3RhdHVzIHNlY3Rpb24gLS0+CgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4xNCIvPgoJCQkJCTxjb2RlIGNvZGU9IjQ3NDIwLTUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPgoJCQkJCTx0aXRsZT5GdW5jdGlvbmFsIFN0YXR1czwvdGl0bGU+CgkJCQkJPHRleHQ+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5GdW5jdGlvbmFsIG9yIENvZ25pdGl2ZSBGaW5kaW5nPC90aD4KCQkJCQkJCQkJPHRoPk9ic2VydmF0aW9uPC90aD4KCQkJCQkJCQkJPHRoPk9ic2VydmF0aW9uIERhdGU8L3RoPgoJCQkJCQkJCQk8dGg+Q29uZGl0aW9uIFN0YXR1czwvdGg+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGhlYWQ+CgkJCQkJCQk8dGJvZHk+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+PGNvbnRlbnQgSUQ9IkZVTkMxIj5BbWJ1bGF0aW9uKERlcGVuZGVudCB0bwoJCQkJCQkJCQkJCUluZGVwZW5kZW50KTwvY29udGVudD48L3RkPgoJCQkJCQkJCQk8dGQ+SW5kZXBlbmRlbnRseSBhYmxlPC90ZD4KCQkJCQkJCQkJPHRkPk1hcmNoIDExLCAyMDA5PC90ZD4KCQkJCQkJCQkJPHRkPkFjdGl2ZTwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD48Y29udGVudCBJRD0iRlVOQzIiPkZpbmRpbmcgb2YgRnVuY3Rpb25hbCBQZXJmb3JtYW5jZSBhbmQKCQkJCQkJCQkJCQlBY3Rpdml0eTwvY29udGVudD48L3RkPgoJCQkJCQkJCQk8dGQ+RHlzcG5lYTwvdGQ+CgkJCQkJCQkJCTx0ZD5GZWJydWFyeSAyMDA3PC90ZD4KCQkJCQkJCQkJPHRkPkFjdGl2ZTwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5Db2duaXRpdmUgRnVuY3Rpb24gRmluZGluZzwvdGQ+CgkJCQkJCQkJCTx0ZD48Y29udGVudCBJRD0iQ09HMiI+TWVtb3J5IGltcGFpcm1lbnQ8L2NvbnRlbnQ+PC90ZD4KCQkJCQkJCQkJPHRkPkFwcmlsIDIwMDc8L3RkPgoJCQkJCQkJCQk8dGQ+QWN0aXZlPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPjxjb250ZW50IElEPSJDT0cxIj5Db2duaXRpdmUgRnVuY3Rpb24gRmluZGluZyhOb24tQWdncmVzc2l2ZQoJCQkJCQkJCQkJCXRvIEFnZ3Jlc3NpdmUpPC9jb250ZW50PjwvdGQ+CgkJCQkJCQkJCTx0ZD5BZ2dyZXNzaXZlIGJlaGF2aW9yPC90ZD4KCQkJCQkJCQkJPHRkPk1hcmNoIDExLCAyMDA5PC90ZD4KCQkJCQkJCQkJPHRkPkFjdGl2ZTwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGJvZHk+CgkJCQkJCTwvdGFibGU+CgkJCQkJPC90ZXh0PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxvcmdhbml6ZXIgY2xhc3NDb2RlPSJDTFVTVEVSIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMSIvPgoJCQkJCQkJPCEtLSAqKiBjb25mb3JtcyB0byBSZXN1bHQgT3JnYW5pemVyICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC42NiIvPgoJCQkJCQkJPCEtLSBGdW5jdGlvbmFsIFN0YXR1cyBSZXN1bHQgT3JnYW5pemVyIHRlbXBsYXRlIC0tPgoJCQkJCQkJPGlkIHJvb3Q9IjkyOTVkYmE0LWRmMDUtNDZiYi1iOTRlLWYyYzRlNGIxNTZmOCIvPgoJCQkJCQkJPGNvZGUgY29kZT0iZDUiIGRpc3BsYXlOYW1lPSJTZWxmLUNhcmUiCgkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTQiIGNvZGVTeXN0ZW1OYW1lPSJJQ0YiLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIGNvbmZvcm1zIHRvIFJlc3VsdCBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIi8+CgkJCQkJCQkJCTwhLS0gKiogRnVuY3Rpb25hbCBzdGF0dXMgcmVzdWx0IG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjY3Ii8+CgkJCQkJCQkJCTxpZCByb290PSJjNmI1YTA0Yi0yYmY0LTQ5ZDEtODMzNi02MzZhMzgxM2RmMGEiLz4KCQkJCQkJCQkJPGNvZGUgY29kZT0iNTcyNTEtMSIgZGlzcGxheU5hbWU9IkFtYnVsYXRpb24iCgkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIvPgoJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNGVU5DMSIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwOTAzMTExMjMwIi8+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjM3MTE1MzAwNiIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJJbmRlcGVuZGVudGx5IGFibGUiCgkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIvPgoJCQkJCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9IkIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiLz4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJDT01QIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBBc3Nlc3NtZW50IHNjYWxlIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNjkiLz4KCQkJCQkJCQkJCQk8aWQgcm9vdD0iYzZiNWEwNGItMmJmNC00OWQxLTgzMzYtNjM2YTM4MTNkZjBiIi8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNTQ2MTQtMyIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IkJyaWVmIEludGVydmlldyBmb3IgTWVudGFsIFN0YXR1cyIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTE9JTkMiLz4KCQkJCQkJCQkJCQk8ZGVyaXZhdGlvbkV4cHI+VGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUKCQkJCQkJCQkJCQkJY2FsY3VsYXRpb248L2Rlcml2YXRpb25FeHByPgoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDEyMDIxNCIvPgoJCQkJCQkJCQkJCTwhLS0gU3VtbWVkIHNjb3JlIG9mIHRoZSBjb21wb25lbnQgdmFsdWVzIC0tPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSU5UIiB2YWx1ZT0iNyIvPgoJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iQ09NUCI+CgkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJCTwhLS0gKiogQXNzZXNzbWVudCBzY2FsZSBzdXBwb3J0aW5nIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljg2Ii8+CgkJCQkJCQkJCQkJCTxpZCByb290PSJmNGRjZTc5MC04MzI4LTExZGItOWZlMS0wODAwMjAwYzlhMzMiLz4KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNTI3MzEtNyIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlJlcGV0aXRpb24gb2YgVGhyZWUgV29yZHMiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkxPSU5DIi8+CgkJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSJMQTYzOTUtMyIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlRocmVlIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiLz4KCQkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iQ09NUCI+CgkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJCTwhLS0gKiogQXNzZXNzbWVudCBzY2FsZSBzdXBwb3J0aW5nIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljg2Ii8+CgkJCQkJCQkJCQkJCTxpZCByb290PSJmNGRjZTc5MC04MzI4LTExZGItOWZlMS0wODAwMjAwYzlhMjIiLz4KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNTI3MzItNSIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlRlbXBvcmFsIG9yaWVudGF0aW9uIC0gY3VycmVudCB5ZWFyIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIvPgoJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iTEExMDk2Ni0yIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iTWlzc2VkIGJ5IDItNSB5ZWFycyIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+CgkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPgoJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQkJCQk8IS0tICoqIENhcmVnaXZlciBjaGFyYWN0ZXJpc3RpY3MgKiogLS0+CgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNzIiLz4KCQkJCQkJCQkJCQkJPGlkIHJvb3Q9ImM2YjVhMDRiLTJiZjQtNDlkMS04MzM2LTYzNmEzODEzZGYwYyIvPgoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPgoJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNDIyNjE1MDAxIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iY2FyZWdpdmVyIGRpZmZpY3VsdHkgcHJvdmlkaW5nIHBoeXNpY2FsIGNhcmUiLz4KCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJJTkQiPgoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iQ0FSRUdJVkVSIj4KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iTVRIIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMSIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9Ik1vdGhlciIvPgoJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4KCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudD4KCQkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9jb21wb25lbnQ+CgkJCQkJCTwvb3JnYW5pemVyPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCTwhLS0gKiogY29uZm9ybXMgdG8gUHJvYmxlbSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNCIvPgoJCQkJCQkJPCEtLSAqKiBGdW5jdGlvbmFsIHN0YXR1cyBwcm9ibGVtIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC42OCIvPgoJCQkJCQkJPGlkIHJvb3Q9IjA4ZWRiN2MwLTIxMTEtNDNmMi1hNzg0LTlhNWZkZmFhNjdmMCIvPgoJCQkJCQkJPGNvZGUgY29kZT0iMjQ4NTM2MDA2IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCWRpc3BsYXlOYW1lPSJGaW5kaW5nIG9mIEZ1bmN0aW9uYWwgUGVyZm9ybWFuY2UgYW5kIEFjdGl2aXR5Ii8+CgkJCQkJCQk8dGV4dD4KCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjRlVOQzIiLz4KCQkJCQkJCTwvdGV4dD4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwNzAyIi8+CgkJCQkJCQkJPGhpZ2ggdmFsdWU9IjIwMDcwNCIvPgoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iIDE2Mjg5MTAwNyIKCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iZHlzcG5lYSIvPgoJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCTwhLS0gKiogY29uZm9ybXMgdG8gUHJvYmxlbSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNCIvPgoJCQkJCQkJPCEtLSAqKiBDb2duaXRpdmUgc3RhdHVzIHByb2JsZW0gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjczIi8+CgkJCQkJCQk8aWQgcm9vdD0iMDhlZGI3YzAtMjExMS00M2YyLWE3ODQtOWE1ZmRmYWE2N2YwIi8+CgkJCQkJCQk8Y29kZSBjb2RlPSIzNzM5MzAwMDAiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJZGlzcGxheU5hbWU9IkNvZ25pdGl2ZSBGdW5jdGlvbiBGaW5kaW5nIi8+CgkJCQkJCQk8dGV4dD4KCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjQ09HMiIvPgoJCQkJCQkJPC90ZXh0PgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA3MDQiLz4KCQkJCQkJCQk8aGlnaCB2YWx1ZT0iMjAwNzA2Ii8+CgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIzODY4MDcwMDYiCgkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9Ik1lbW9yeSBpbXBhaXJtZW50IgoJCQkJCQkJLz4KCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQk8L2VudHJ5PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxvcmdhbml6ZXIgY2xhc3NDb2RlPSJDTFVTVEVSIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCTwhLS0gKiogY29uZm9ybXMgdG8gUmVzdWx0IG9yZ2FuaXplciAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMSIvPgoJCQkJCQkJPCEtLSAqKiBDb2duaXRpdmUgc3RhdHVzIHJlc3VsdCBvcmdhbml6ZXIgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljc1Ii8+CgkJCQkJCQk8aWQgcm9vdD0iOTI5NWRiYTQtZGYwNS00NmJiLWI5NGUtZjJjNGU0YjE1NmY4Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSJkMyIgZGlzcGxheU5hbWU9IkNvbW11bmljYXRpb24iCgkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTQiIGNvZGVTeXN0ZW1OYW1lPSJJQ0YiLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIGNvbmZvcm1zIHRvIFJlc3VsdCBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIi8+CgkJCQkJCQkJCTwhLS0gKiogQ29nbml0aXZlIHN0YXR1cyByZXN1bHQgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNzQiLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImM2YjVhMDRiLTJiZjQtNDlkMS04MzM2LTYzNmEzODEzZGYwYSIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSIzNzM5MzAwMDAiIGRpc3BsYXlOYW1lPSJDb2duaXRpdmUgZnVuY3Rpb24gZmluZGluZyIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIi8+CgkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI0NPRzEiLz4KCQkJCQkJCQkJPC90ZXh0PgoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDkwMzExMTIzMCIvPgoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSI2MTM3MjAwMSIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJBZ2dyZXNzaXZlIGJlaGF2aW9yIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiLz4KCQkJCQkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJISCIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiLz4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJDT01QIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBBc3Nlc3NtZW50IHNjYWxlIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNjkiLz4KCQkJCQkJCQkJCQk8aWQgcm9vdD0iYzZiNWEwNGItMmJmNC00OWQxLTgzMzYtNjM2YTM4MTNkZjBiMSIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjI0ODI0MTAwMiIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IkJyaWVmIEludGVydmlldyBmb3IgTWVudGFsIFN0YXR1cyIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTE9JTkMiLz4KCQkJCQkJCQkJCQk8ZGVyaXZhdGlvbkV4cHI+VGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUKCQkJCQkJCQkJCQkJY2FsY3VsYXRpb248L2Rlcml2YXRpb25FeHByPgoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDEyMDIxNCIvPgoJCQkJCQkJCQkJCTwhLS0gU3VtbWVkIHNjb3JlIG9mIHRoZSBjb21wb25lbnQgdmFsdWVzIC0tPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSU5UIiB2YWx1ZT0iNyIvPgoJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iQ09NUCI+CgkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJCTwhLS0gKiogQXNzZXNzbWVudCBzY2FsZSBzdXBwb3J0aW5nIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljg2Ii8+CgkJCQkJCQkJCQkJCTxpZCByb290PSJmNGRjZTc5MC04MzI4LTExZGItOWZlMS0wODAwMjAwYzlhMzMiLz4KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNTI3MzEtNyIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlJlcGV0aXRpb24gb2YgVGhyZWUgV29yZHMiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkxPSU5DIi8+CgkJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSJMQTYzOTUtMyIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlRocmVlIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiLz4KCQkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iQ09NUCI+CgkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJCTwhLS0gKiogQXNzZXNzbWVudCBzY2FsZSBzdXBwb3J0aW5nIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljg2Ii8+CgkJCQkJCQkJCQkJCTxpZCByb290PSJmNGRjZTc5MC04MzI4LTExZGItOWZlMS0wODAwMjAwYzlhMjIiLz4KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNTI3MzItNSIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlRlbXBvcmFsIG9yaWVudGF0aW9uIC0gY3VycmVudCB5ZWFyIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIvPgoJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iTEExMDk2Ni0yIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iTWlzc2VkIGJ5IDItNSB5ZWFycyIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+CgkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPgoJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQkJCQk8IS0tICoqIENhcmVnaXZlciBjaGFyYWN0ZXJpc3RpY3MgKiogLS0+CgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNzIiLz4KCQkJCQkJCQkJCQkJPGlkIHJvb3Q9ImM2YjVhMDRiLTJiZjQtNDlkMS04MzM2LTYzNmEzODEzZGYwYyIvPgoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPgoJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNDIyNjE1MDAxIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iY2FyZWdpdmVyIGRpZmZpY3VsdHkgcHJvdmlkaW5nIHBoeXNpY2FsIGNhcmUiLz4KCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJJTkQiPgoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iQ0FSRUdJVkVSIj4KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iTVRIIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMSIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9Ik1vdGhlciIvPgoJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4KCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudD4KCQkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJPHJlZmVyZW5jZVJhbmdlPgoJCQkJCQkJCQkJPG9ic2VydmF0aW9uUmFuZ2U+CgkJCQkJCQkJCQkJPHRleHQ+Tm9uIEFnZ3Jlc3NpdmUgdG8gQWdncmVzc2l2ZTwvdGV4dD4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb25SYW5nZT4KCQkJCQkJCQkJPC9yZWZlcmVuY2VSYW5nZT4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9jb21wb25lbnQ+CgkJCQkJCTwvb3JnYW5pemVyPgoJCQkJCTwvZW50cnk+CgkJCQk8L3NlY3Rpb24+CgkJCTwvY29tcG9uZW50PgoJCQk8IS0tICoqKioqKioqKioqKioqKioqKioqIElNTVVOSVpBVElPTlMgKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBjb25mb3JtcyB0byBJbW11bml6YXRpb25zIHNlY3Rpb24gd2l0aCBlbnRyaWVzIG9wdGlvbmFsIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMiIvPgoJCQkJCTwhLS0gSW1tdW5pemF0aW9ucyBzZWN0aW9uIHdpdGggZW50cmllcyByZXF1aXJlZCAtLT4KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjIuMSIvPgoJCQkJCTxjb2RlIGNvZGU9IjExMzY5LTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIgoJCQkJCQlkaXNwbGF5TmFtZT0iSGlzdG9yeSBvZiBpbW11bml6YXRpb25zIi8+CgkJCQkJPHRpdGxlPklNTVVOSVpBVElPTlM8L3RpdGxlPgoJCQkJCTx0ZXh0PgoJCQkJCQk8Y29udGVudCBJRD0iaW1tdW5TZWN0Ii8+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5WYWNjaW5lPC90aD4KCQkJCQkJCQkJPHRoPkRhdGU8L3RoPgoJCQkJCQkJCQk8dGg+U3RhdHVzPC90aD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90aGVhZD4KCQkJCQkJCTx0Ym9keT4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbW1pMSIvPiBJbmZsdWVuemEsIHNlYXNvbmFsLCBJTSA8L3RkPgoJCQkJCQkJCQk8dGQ+Tm92IDE5OTk8L3RkPgoJCQkJCQkJCQk8dGQ+Q29tcGxldGVkPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImltbWkyIi8+IEluZmx1ZW56YSwgc2Vhc29uYWwsIElNIDwvdGQ+CgkJCQkJCQkJCTx0ZD5EZWMgMTk5ODwvdGQ+CgkJCQkJCQkJCTx0ZD5Db21wbGV0ZWQ8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+CgkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW1taTMiLz4gUG5ldW1vY29jY2FsIHBvbHlzYWNjaGFyaWRlIHZhY2NpbmUsCgkJCQkJCQkJCQlJTSA8L3RkPgoJCQkJCQkJCQk8dGQ+RGVjIDE5OTg8L3RkPgoJCQkJCQkJCQk8dGQ+Q29tcGxldGVkPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImltbWk0Ii8+IFRldGFudXMgYW5kIGRpcGh0aGVyaWEgdG94b2lkcywgSU0gPC90ZD4KCQkJCQkJCQkJPHRkPjE5OTc8L3RkPgoJCQkJCQkJCQk8dGQ+UmVmdXNlZDwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGJvZHk+CgkJCQkJCTwvdGFibGU+CgkJCQkJPC90ZXh0PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iRVZOIgoJCQkJCQkJbmVnYXRpb25JbmQ9ImZhbHNlIj4KCQkJCQkJCTwhLS0gKiogSW1tdW5pemF0aW9uIGFjdGl2aXR5ICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41MiIvPgoJCQkJCQkJPGlkIHJvb3Q9ImU2ZjFiYTQzLWMwZWQtNGI5Yi05ZjEyLWY0MzVkOGFkOGY5MiIvPgoJCQkJCQkJPHRleHQ+CgkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2ltbXVuMSIvPgoJCQkJCQkJPC90ZXh0PgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIiB2YWx1ZT0iMTk5OTExIi8+CgkJCQkJCQk8cm91dGVDb2RlIGNvZGU9IkMyODE2MSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMy4yNi4xLjEiCgkJCQkJCQkJY29kZVN5c3RlbU5hbWU9Ik5hdGlvbmFsIENhbmNlciBJbnN0aXR1dGUgKE5DSSkgVGhlc2F1cnVzIgoJCQkJCQkJCWRpc3BsYXlOYW1lPSJJbnRyYW11c2N1bGFyIGluamVjdGlvbiIvPgoJCQkJCQkJPGRvc2VRdWFudGl0eSB2YWx1ZT0iNTAiIHVuaXQ9Im1jZyIvPgoJCQkJCQkJPGNvbnN1bWFibGU+CgkJCQkJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4KCQkJCQkJCQkJPCEtLSAqKiBJbW11bml6YXRpb24gbWVkaWNhdGlvbiBpbmZvcm1hdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41NCIvPgoJCQkJCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+CgkJCQkJCQkJCQk8Y29kZSBjb2RlPSI4OCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMTIuMjkyIgoJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJJbmZsdWVuemEgdmlydXMgdmFjY2luZSIKCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iQ1ZYIj4KCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjaW1taTEiLz4KCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iMTQxIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iSW5mbHVlbnphLCBzZWFzb25hbCwgaW5qZWN0YWJsZSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkNWWCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMTIuMjkyIi8+CgkJCQkJCQkJCQk8L2NvZGU+CgkJCQkJCQkJCQk8bG90TnVtYmVyVGV4dD4xPC9sb3ROdW1iZXJUZXh0PgoJCQkJCQkJCQk8L21hbnVmYWN0dXJlZE1hdGVyaWFsPgoJCQkJCQkJCQk8bWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPgoJCQkJCQkJCQkJPG5hbWU+SGVhbHRoIExTIC0gSW1tdW5vIEluYy48L25hbWU+CgkJCQkJCQkJCTwvbWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPgoJCQkJCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4KCQkJCQkJCTwvY29uc3VtYWJsZT4KCQkJCQkJCTxwZXJmb3JtZXI+CgkJCQkJCQkJPGFzc2lnbmVkRW50aXR5PgoJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjQ1NiIgZXh0ZW5zaW9uPSIyOTgxODI0Ii8+CgkJCQkJCQkJCTxhZGRyPgoJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEwMjEgSGVhbHRoIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCTxjaXR5PkFubiBBcmJvcjwvY2l0eT4KCQkJCQkJCQkJCTxzdGF0ZT5NSTwvc3RhdGU+CgkJCQkJCQkJCQk8cG9zdGFsQ29kZT45OTA5OTwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJCQkJCQk8L2FkZHI+CgkJCQkJCQkJCTx0ZWxlY29tIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+CgkJCQkJCQkJCQk8bmFtZT4KCQkJCQkJCQkJCQk8Z2l2ZW4+QW1hbmRhPC9naXZlbj4KCQkJCQkJCQkJCQk8ZmFtaWx5PkFzc2lnbmVkPC9mYW1pbHk+CgkJCQkJCQkJCQk8L25hbWU+CgkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+CgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTkuMTM5NCIvPgoJCQkJCQkJCQkJPG5hbWU+R29vZCBIZWFsdGggQ2xpbmljPC9uYW1lPgoJCQkJCQkJCQkJPHRlbGVjb20gbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8YWRkciBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5PgoJCQkJCQkJPC9wZXJmb3JtZXI+CgkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPgoJCQkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJJTlQiPgoJCQkJCQkJCQk8IS0tICoqIEluc3RydWN0aW9ucyAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSIxNzEwNDQwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iaW1tdW5pemF0aW9uIGVkdWNhdGlvbiIvPgoJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNpbW11blNlY3QiLz4gUG9zc2libGUgZmx1LWxpa2Ugc3ltcHRvbXMKCQkJCQkJCQkJCWZvciB0aHJlZSBkYXlzLiA8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCTwvYWN0PgoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4KCQkJCQk8L2VudHJ5PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0idHJ1ZSI+CgkJCQkJCQk8IS0tICoqIEltbXVuaXphdGlvbiBhY3Rpdml0eSAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNTIiLz4KCQkJCQkJCTxpZCByb290PSJlNmYxYmE0My1jMGVkLTRiOWItOWYxMi1mNDM1ZDhhZDhmOTIiLz4KCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNpbW11bjIiLz4KCQkJCQkJCTwvdGV4dD4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyIgdmFsdWU9IjE5OTgxMjE1Ii8+CgkJCQkJCQk8cm91dGVDb2RlIGNvZGU9IkMyODE2MSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMy4yNi4xLjEiCgkJCQkJCQkJY29kZVN5c3RlbU5hbWU9Ik5hdGlvbmFsIENhbmNlciBJbnN0aXR1dGUgKE5DSSkgVGhlc2F1cnVzIgoJCQkJCQkJCWRpc3BsYXlOYW1lPSJJbnRyYW11c2N1bGFyIGluamVjdGlvbiIvPgoJCQkJCQkJPGRvc2VRdWFudGl0eSB2YWx1ZT0iNTAiIHVuaXQ9Im1jZyIvPgoJCQkJCQkJPGNvbnN1bWFibGU+CgkJCQkJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4KCQkJCQkJCQkJPCEtLSAqKiBJbW11bml6YXRpb24gbWVkaWNhdGlvbiBpbmZvcm1hdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41NCIvPgoJCQkJCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+CgkJCQkJCQkJCQk8Y29kZSBjb2RlPSI4OCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMTIuMjkyIgoJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJJbmZsdWVuemEgdmlydXMgdmFjY2luZSIKCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iQ1ZYIj4KCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjaW1taTIiLz4KCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iMTQxIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iSW5mbHVlbnphLCBzZWFzb25hbCwgaW5qZWN0YWJsZSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkNWWCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMTIuMjkyIi8+CgkJCQkJCQkJCQk8L2NvZGU+CgkJCQkJCQkJCQk8bG90TnVtYmVyVGV4dD4xPC9sb3ROdW1iZXJUZXh0PgoJCQkJCQkJCQk8L21hbnVmYWN0dXJlZE1hdGVyaWFsPgoJCQkJCQkJCQk8bWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPgoJCQkJCQkJCQkJPG5hbWU+SGVhbHRoIExTIC0gSW1tdW5vIEluYy48L25hbWU+CgkJCQkJCQkJCTwvbWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPgoJCQkJCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4KCQkJCQkJCTwvY29uc3VtYWJsZT4KCQkJCQkJCTxwZXJmb3JtZXI+CgkJCQkJCQkJPGFzc2lnbmVkRW50aXR5PgoJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjQ1NiIgZXh0ZW5zaW9uPSIyOTgxODI0Ii8+CgkJCQkJCQkJCTxhZGRyPgoJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEwMjEgSGVhbHRoIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCTxjaXR5PkFubiBBcmJvcjwvY2l0eT4KCQkJCQkJCQkJCTxzdGF0ZT5NSTwvc3RhdGU+CgkJCQkJCQkJCQk8cG9zdGFsQ29kZT45OTA5OTwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJCQkJCQk8L2FkZHI+CgkJCQkJCQkJCTx0ZWxlY29tIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+CgkJCQkJCQkJCQk8bmFtZT4KCQkJCQkJCQkJCQk8Z2l2ZW4+QW1hbmRhPC9naXZlbj4KCQkJCQkJCQkJCQk8ZmFtaWx5PkFzc2lnbmVkPC9mYW1pbHk+CgkJCQkJCQkJCQk8L25hbWU+CgkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+CgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTkuMTM5NCIvPgoJCQkJCQkJCQkJPG5hbWU+R29vZCBIZWFsdGggQ2xpbmljPC9uYW1lPgoJCQkJCQkJCQkJPHRlbGVjb20gbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8YWRkciBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5PgoJCQkJCQkJPC9wZXJmb3JtZXI+CgkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+CgkJCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IklOVCI+CgkJCQkJCQkJCTwhLS0gKiogSW5zdHJ1Y3Rpb25zICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIwIi8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IjE3MTA0NDAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJpbW11bml6YXRpb24gZWR1Y2F0aW9uIi8+CgkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2ltbXVuU2VjdCIvPiBQb3NzaWJsZSBmbHUtbGlrZSBzeW1wdG9tcwoJCQkJCQkJCQkJZm9yIHRocmVlIGRheXMuIDwvdGV4dD4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJPC9hY3Q+CgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJFVk4iCgkJCQkJCQluZWdhdGlvbkluZD0iZmFsc2UiPgoJCQkJCQkJPCEtLSAqKiBJbW11bml6YXRpb24gYWN0aXZpdHkgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjUyIi8+CgkJCQkJCQk8aWQgcm9vdD0iZTZmMWJhNDMtYzBlZC00YjliLTlmMTItZjQzNWQ4YWQ4ZjkyIi8+CgkJCQkJCQk8dGV4dD4KCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjaW1tdW4zIi8+CgkJCQkJCQk8L3RleHQ+CgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiIHZhbHVlPSIxOTk4MTIxNSIvPgoJCQkJCQkJPHJvdXRlQ29kZSBjb2RlPSJDMjgxNjEiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjMuMjYuMS4xIgoJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJOYXRpb25hbCBDYW5jZXIgSW5zdGl0dXRlIChOQ0kpIFRoZXNhdXJ1cyIKCQkJCQkJCQlkaXNwbGF5TmFtZT0iSW50cmFtdXNjdWxhciBpbmplY3Rpb24iLz4KCQkJCQkJCTxkb3NlUXVhbnRpdHkgdmFsdWU9IjUwIiB1bml0PSJtY2ciLz4KCQkJCQkJCTxjb25zdW1hYmxlPgoJCQkJCQkJCTxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+CgkJCQkJCQkJCTwhLS0gKiogSW1tdW5pemF0aW9uIG1lZGljYXRpb24gaW5mb3JtYXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNTQiLz4KCQkJCQkJCQkJPG1hbnVmYWN0dXJlZE1hdGVyaWFsPgoJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjEyLjI5MiIKCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iUG5ldW1vY29jY2FsIHBvbHlzYWNjaGFyaWRlIHZhY2NpbmUiCgkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkNWWCI+CgkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2ltbWkzIi8+CgkJCQkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+CgkJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjEwOSIgZGlzcGxheU5hbWU9IlBuZXVtb2NvY2NhbCBOT1MiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJDVlgiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjEyLjI5MiIvPgoJCQkJCQkJCQkJPC9jb2RlPgoJCQkJCQkJCQkJPGxvdE51bWJlclRleHQ+MTwvbG90TnVtYmVyVGV4dD4KCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4KCQkJCQkJCQkJPG1hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTxuYW1lPkhlYWx0aCBMUyAtIEltbXVubyBJbmMuPC9uYW1lPgoJCQkJCQkJCQk8L21hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4KCQkJCQkJCQk8L21hbnVmYWN0dXJlZFByb2R1Y3Q+CgkJCQkJCQk8L2NvbnN1bWFibGU+CgkJCQkJCQk8cGVyZm9ybWVyPgoJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4KCQkJCQkJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OS40NTYiIGV4dGVuc2lvbj0iMjk4MTgyNCIvPgoJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xMDIxIEhlYWx0aCBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQkJCQkJCQk8Y2l0eT5Bbm4gQXJib3I8L2NpdHk+CgkJCQkJCQkJCQk8c3RhdGU+TUk8L3N0YXRlPgoJCQkJCQkJCQkJPHBvc3RhbENvZGU+OTkwOTk8L3Bvc3RhbENvZGU+CgkJCQkJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQk8dGVsZWNvbSBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPgoJCQkJCQkJCQkJPG5hbWU+CgkJCQkJCQkJCQkJPGdpdmVuPkFtYW5kYTwvZ2l2ZW4+CgkJCQkJCQkJCQkJPGZhbWlseT5Bc3NpZ25lZDwvZmFtaWx5PgoJCQkJCQkJCQkJPC9uYW1lPgoJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPgoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTQiLz4KCQkJCQkJCQkJCTxuYW1lPkdvb2QgSGVhbHRoIENsaW5pYzwvbmFtZT4KCQkJCQkJCQkJCTx0ZWxlY29tIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQkJPGFkZHIgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJPC9hc3NpZ25lZEVudGl0eT4KCQkJCQkJCTwvcGVyZm9ybWVyPgoJCQkJCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJ0cnVlIj4KCQkJCQkJCTwhLS0gKiogSW1tdW5pemF0aW9uIGFjdGl2aXR5ICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41MiIvPgoJCQkJCQkJPGlkIHJvb3Q9ImU2ZjFiYTQzLWMwZWQtNGI5Yi05ZjEyLWY0MzVkOGFkOGY5MiIvPgoJCQkJCQkJPHRleHQ+CgkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2ltbXVuNCIvPgoJCQkJCQkJPC90ZXh0PgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIiB2YWx1ZT0iMTk5ODEyMTUiLz4KCQkJCQkJCTxyb3V0ZUNvZGUgY29kZT0iQzI4MTYxIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4zLjI2LjEuMSIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTmF0aW9uYWwgQ2FuY2VyIEluc3RpdHV0ZSAoTkNJKSBUaGVzYXVydXMiCgkJCQkJCQkJZGlzcGxheU5hbWU9IkludHJhbXVzY3VsYXIgaW5qZWN0aW9uIi8+CgkJCQkJCQk8ZG9zZVF1YW50aXR5IHZhbHVlPSI1MCIgdW5pdD0ibWNnIi8+CgkJCQkJCQk8Y29uc3VtYWJsZT4KCQkJCQkJCQk8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPgoJCQkJCQkJCQk8IS0tICoqIEltbXVuaXphdGlvbiBtZWRpY2F0aW9uIElpbmZvcm1hdGlvbiAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41NCIvPgoJCQkJCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+CgkJCQkJCQkJCQk8Y29kZSBjb2RlPSIxMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjEyLjI5MiIKCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iVGV0YW51cyBhbmQgZGlwaHRoZXJpYSB0b3hvaWRzIC0gcHJlc2VydmF0aXZlIGZyZWUiCgkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkNWWCI+CgkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2ltbWk0Ii8+CgkJCQkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+CgkJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjA5IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iVGV0YW51cyBhbmQgZGlwaHRoZXJpYSB0b3hvaWRzIC0gcHJlc2VydmF0aXZlIGZyZWUiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJDVlgiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjEyLjI5MiIvPgoJCQkJCQkJCQkJPC9jb2RlPgoJCQkJCQkJCQkJPGxvdE51bWJlclRleHQ+MTwvbG90TnVtYmVyVGV4dD4KCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4KCQkJCQkJCQkJPG1hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTxuYW1lPkhlYWx0aCBMUyAtIEltbXVubyBJbmMuPC9uYW1lPgoJCQkJCQkJCQk8L21hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4KCQkJCQkJCQk8L21hbnVmYWN0dXJlZFByb2R1Y3Q+CgkJCQkJCQk8L2NvbnN1bWFibGU+CgkJCQkJCQk8cGVyZm9ybWVyPgoJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4KCQkJCQkJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OS40NTYiIGV4dGVuc2lvbj0iMjk4MTgyNCIvPgoJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xMDIxIEhlYWx0aCBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQkJCQkJCQk8Y2l0eT5Bbm4gQXJib3I8L2NpdHk+CgkJCQkJCQkJCQk8c3RhdGU+TUk8L3N0YXRlPgoJCQkJCQkJCQkJPHBvc3RhbENvZGU+OTkwOTk8L3Bvc3RhbENvZGU+CgkJCQkJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQk8dGVsZWNvbSBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPgoJCQkJCQkJCQkJPG5hbWU+CgkJCQkJCQkJCQkJPGdpdmVuPkFtYW5kYTwvZ2l2ZW4+CgkJCQkJCQkJCQkJPGZhbWlseT5Bc3NpZ25lZDwvZmFtaWx5PgoJCQkJCQkJCQkJPC9uYW1lPgoJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPgoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTQiLz4KCQkJCQkJCQkJCTxuYW1lPkdvb2QgSGVhbHRoIENsaW5pYzwvbmFtZT4KCQkJCQkJCQkJCTx0ZWxlY29tIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQkJPGFkZHIgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJPC9hc3NpZ25lZEVudGl0eT4KCQkJCQkJCTwvcGVyZm9ybWVyPgoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSU09OIj4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIEltbXVuaXphdGlvbiByZWZ1c2FsICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjUzIi8+CgkJCQkJCQkJCTxpZCByb290PSIyYTYyMDE1NS05ZDExLTQzOWUtOTJiMy01ZDk4MTVmZjRkZDgiLz4KCQkJCQkJCQkJPGNvZGUgZGlzcGxheU5hbWU9IlBhdGllbnQgT2JqZWN0aW9uIiBjb2RlPSJQQVRPQkoiCgkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iSEw3IEFjdE5vSW1tdW5pemF0aW9uUmVhc29uIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44Ii8+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPgoJCQkJCTwvZW50cnk+CgkJCQk8L3NlY3Rpb24+CgkJCTwvY29tcG9uZW50PgoJCQk8IS0tICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBJTlRFUlZFTlRJT05TICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAtLT4KCQkJPGNvbXBvbmVudD4KCQkJCTxzZWN0aW9uPgoJCQkJCTwhLS0gSW50ZXJ2ZW50aW9ucyBzZWN0aW9uIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIxLjIuMyIvPgoJCQkJCTxjb2RlIGNvZGU9IjYyMzg3LTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIgoJCQkJCQlkaXNwbGF5TmFtZT0iSU5URVJWRU5USU9OUyIvPgoJCQkJCTx0aXRsZT5JTlRFUlZFTlRJT05TIFBST1ZJREVEPC90aXRsZT4KCQkJCQk8dGV4dD4KCQkJCQkJPGxpc3QgbGlzdFR5cGU9Im9yZGVyZWQiPgoJCQkJCQkJPGl0ZW0+VGhlcmFwZXV0aWMgZXhlcmNpc2UgaW50ZXJ2ZW50aW9uOiBrbmVlIGV4dGVuc2lvbiwgMyBzZXRzLCAxMAoJCQkJCQkJCXJlcGV0aXRpb25zLCAxMC1sYiB3ZWlnaHQuIDwvaXRlbT4KCQkJCQkJCTxpdGVtPlRoZXJhcGV1dGljIGV4ZXJjaXNlIGludGVydmVudGlvbjogYXJtIGN1cmwsIDMgc2V0cywgMTAKCQkJCQkJCQlyZXBldGl0aW9ucywgMTUtbGIgd2VpZ2h0IDwvaXRlbT4KCQkJCQkJPC9saXN0PgoJCQkJCTwvdGV4dD4KCQkJCTwvc2VjdGlvbj4KCQkJPC9jb21wb25lbnQ+CgkJCTwhLS0gKioqKioqKioqKioqKioqKioqKioqKiogTUVESUNBTCBFUVVJUE1FTlQgKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBNZWRpY2FsIGVxdWlwbWVudCBzZWN0aW9uIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMjMiLz4KCQkJCQk8Y29kZSBjb2RlPSI0NjI2NC04IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiLz4KCQkJCQk8dGl0bGU+TUVESUNBTCBFUVVJUE1FTlQ8L3RpdGxlPgoJCQkJCTx0ZXh0PgoJCQkJCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+CgkJCQkJCQk8dGhlYWQ+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGg+U3VwcGx5L0RldmljZTwvdGg+CgkJCQkJCQkJCTx0aD5EYXRlIFN1cHBsaWVkPC90aD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90aGVhZD4KCQkJCQkJCTx0Ym9keT4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5BdXRvbWF0aWMgaW1wbGFudGFibGUgY2FyZGlvdmVydGVyL2RlZmlicmlsbGF0b3I8L3RkPgoJCQkJCQkJCQk8dGQ+Tm92IDE5OTk8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+VG90YWwgaGlwIHJlcGxhY2VtZW50IHByb3N0aGVzaXM8L3RkPgoJCQkJCQkJCQk8dGQ+MTk5ODwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5XaGVlbGNoYWlyPC90ZD4KCQkJCQkJCQkJPHRkPjE5OTk8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3Rib2R5PgoJCQkJCQk8L3RhYmxlPgoJCQkJCTwvdGV4dD4KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPgoJCQkJCQk8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQk8IS0tICoqIE5vbi1tZWRpY2luYWwgc3VwcGx5IGFjdGl2aXR5ICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41MCIvPgoJCQkJCQkJPGlkIHJvb3Q9IjI0MTM3NzNjLTIzNzItNDI5OS1iYmU2LTViMGY2MDY2NDQ0NiIvPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4KCQkJCQkJCQk8aGlnaCB2YWx1ZT0iMTk5OTExIi8+CgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQk8cXVhbnRpdHkgdmFsdWU9IjIiLz4KCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iUFJEIj4KCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+CgkJCQkJCQkJCTwhLS0gKiogUHJvZHVjdCBpbnN0YW5jZSAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zNyIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iMjQxMzc3M2MtMjM3Mi00Mjk5LWJiZTYtNWIwZjYwNjY0NDg5Ii8+CgkJCQkJCQkJCTxwbGF5aW5nRGV2aWNlPgoJCQkJCQkJCQkJPGNvZGUgY29kZT0iNzI1MDYwMDEiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IkF1dG9tYXRpYyBpbXBsYW50YWJsZSBjYXJkaW92ZXJ0ZXIvZGVmaWJyaWxsYXRvciIKCQkJCQkJCQkJCS8+CgkJCQkJCQkJCTwvcGxheWluZ0RldmljZT4KCQkJCQkJCQkJPHNjb3BpbmdFbnRpdHk+CgkJCQkJCQkJCQk8aWQgcm9vdD0iZWI5MzYwMTAtN2IxNy0xMWRiLTlmZTEtMDgwMDIwMGM5YjY1Ii8+CgkJCQkJCQkJCTwvc2NvcGluZ0VudGl0eT4KCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4KCQkJCQkJCTwvcGFydGljaXBhbnQ+CgkJCQkJCTwvc3VwcGx5PgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBOb24tbWVkaWNpbmFsIHN1cHBseSBhY3Rpdml0eSAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNTAiLz4KCQkJCQkJCTxpZCByb290PSIyMzBiMGFiNy0yMDZkLTQyZDgtYTk0Ny1hYjRmNjNhYWQ3OTUiLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+CgkJCQkJCQkJPGNlbnRlciB2YWx1ZT0iMTk5OCIvPgoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJPHF1YW50aXR5IHZhbHVlPSIxIi8+CgkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IlBSRCI+CgkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPgoJCQkJCQkJCQk8IS0tICoqIFByb2R1Y3QgaW5zdGFuY2UgKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzciLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImViOTM2MDEwLTdiMTctMTFkYi05ZmUxLTA4MDAyMDBjOWE2OCIvPgoJCQkJCQkJCQk8cGxheWluZ0RldmljZT4KCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMwNDEyMDAwNyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iVG90YWwgaGlwIHJlcGxhY2VtZW50IHByb3N0aGVzaXMiLz4KCQkJCQkJCQkJPC9wbGF5aW5nRGV2aWNlPgoJCQkJCQkJCQk8c2NvcGluZ0VudGl0eT4KCQkJCQkJCQkJCTxpZCByb290PSIwYWJlYTk1MC01YjQwLTRiN2UtYjhkOS0yYTVlYTNhYzU1MDAiLz4KCQkJCQkJCQkJCTxkZXNjPkdvb2QgSGVhbHRoIFByb3N0aGVzZXMgQ29tcGFueTwvZGVzYz4KCQkJCQkJCQkJPC9zY29waW5nRW50aXR5PgoJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPgoJCQkJCQkJPC9wYXJ0aWNpcGFudD4KCQkJCQkJPC9zdXBwbHk+CgkJCQkJPC9lbnRyeT4KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPgoJCQkJCQk8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQk8IS0tICoqIE5vbi1tZWRpY2luYWwgc3VwcGx5IGFjdGl2aXR5ICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41MCIvPgoJCQkJCQkJPGlkIHJvb3Q9ImM0ZmZlOThlLTNjZDMtNGM1NC1iNWJkLTA4ZWNiODAzNzllMCIvPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4KCQkJCQkJCQk8Y2VudGVyIHZhbHVlPSIxOTk5Ii8+CgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQk8cXVhbnRpdHkgdmFsdWU9IjEiLz4KCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iUFJEIj4KCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+CgkJCQkJCQkJCTwhLS0gKiogUHJvZHVjdCBpbnN0YW5jZSAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zNyIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iZWI5MzYwMTAtN2IxNy0xMWRiLTlmZTEtMDgwMDIwMGM5YTY4Ii8+CgkJCQkJCQkJCTxwbGF5aW5nRGV2aWNlPgoJCQkJCQkJCQkJPGNvZGUgY29kZT0iNTg5MzgwMDgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IldoZWVsY2hhaXIiLz4KCQkJCQkJCQkJPC9wbGF5aW5nRGV2aWNlPgoJCQkJCQkJCQk8c2NvcGluZ0VudGl0eT4KCQkJCQkJCQkJCTxpZCByb290PSJlYjkzNjAxMC03YjE3LTExZGItOWZlMS0wODAwMjAwYzliNjciLz4KCQkJCQkJCQkJCTxkZXNjPkdvb2QgSGVhbHRoIER1cmFibGUgTWVkaWNhbCBFcXVpcG1lbnQ8L2Rlc2M+CgkJCQkJCQkJCTwvc2NvcGluZ0VudGl0eT4KCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4KCQkJCQkJCTwvcGFydGljaXBhbnQ+CgkJCQkJCTwvc3VwcGx5PgoJCQkJCTwvZW50cnk+CgkJCQk8L3NlY3Rpb24+CgkJCTwvY29tcG9uZW50PgoJCQk8IS0tICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogTUVESUNBVElPTlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogLS0+CgkJCTxjb21wb25lbnQ+CgkJCQk8c2VjdGlvbj4KCQkJCQk8IS0tIGNvbmZvcm1zIHRvIE1lZGljYXRpb25zIHNlY3Rpb24gd2l0aCBlbnRyaWVzIG9wdGlvbmFsIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMSIvPgoJCQkJCTwhLS0gTWVkaWNhdGlvbnMgc2VjdGlvbiB3aXRoIGVudHJpZXMgcmVxdWlyZWQgLS0+CgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4xLjEiLz4KCQkJCQk8Y29kZSBjb2RlPSIxMDE2MC0wIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJZGlzcGxheU5hbWU9IkhJU1RPUlkgT0YgTUVESUNBVElPTiBVU0UiLz4KCQkJCQk8dGl0bGU+TUVESUNBVElPTlM8L3RpdGxlPgoJCQkJCTx0ZXh0PgoJCQkJCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+CgkJCQkJCQk8dGhlYWQ+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGg+TWVkaWNhdGlvbjwvdGg+CgkJCQkJCQkJCTx0aD5EaXJlY3Rpb25zPC90aD4KCQkJCQkJCQkJPHRoPlN0YXJ0IERhdGU8L3RoPgoJCQkJCQkJCQk8dGg+U3RhdHVzPC90aD4KCQkJCQkJCQkJPHRoPkluZGljYXRpb25zPC90aD4KCQkJCQkJCQkJPHRoPkZpbGwgSW5zdHJ1Y3Rpb25zPC90aD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90aGVhZD4KCQkJCQkJCTx0Ym9keT4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJNZWRTZWNfMSI+UHJvdmVudGlsIEhGQQoJCQkJCQkJCQkJCTwvY29udGVudD4KCQkJCQkJCQkJPC90ZD4KCQkJCQkJCQkJPHRkPjAuMDkgTUcvQUNUVUFUIGluaGFsYW50IHNvbHV0aW9uLCAyIHB1ZmZzIFFJRCBQUk4KCQkJCQkJCQkJCXdoZWV6aW5nPC90ZD4KCQkJCQkJCQkJPHRkPjIwMDcwMTAzPC90ZD4KCQkJCQkJCQkJPHRkPkFjdGl2ZTwvdGQ+CgkJCQkJCQkJCTx0ZD5QbmV1bW9uaWEgKDIzMzYwNDAwNyBTTk9NRUQgQ1QpPC90ZD4KCQkJCQkJCQkJPHRkPkdlbmVyaWMgU3Vic3RpdGl0aW9uIEFsbG93ZWQ8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3Rib2R5PgoJCQkJCQk8L3RhYmxlPgoJCQkJCTwvdGV4dD4KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPgoJCQkJCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQk8IS0tICoqIE1lZGljYXRpb24gYWN0aXZpdHkgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE2Ii8+CgkJCQkJCQk8aWQgcm9vdD0iY2RiZDMzZjAtNmNkZS0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQk8dGV4dD4KCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjTWVkU2VjXzEiLz4gUHJvdmVudGlsIEhGQTwvdGV4dD4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+CgkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwNzAxMDMiLz4KCQkJCQkJCQk8aGlnaCB2YWx1ZT0iMjAxMjA1MTUiLz4KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJQSVZMX1RTIiBpbnN0aXR1dGlvblNwZWNpZmllZD0idHJ1ZSIKCQkJCQkJCQlvcGVyYXRvcj0iQSI+CgkJCQkJCQkJPHBlcmlvZCB2YWx1ZT0iNiIgdW5pdD0iaCIvPgoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJPHJvdXRlQ29kZSBjb2RlPSJDMzgyMTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjMuMjYuMS4xIgoJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJOQ0kgVGhlc2F1cnVzIgoJCQkJCQkJCWRpc3BsYXlOYW1lPSJSRVNQSVJBVE9SWSAoSU5IQUxBVElPTikiLz4KCQkJCQkJCTxkb3NlUXVhbnRpdHkgdmFsdWU9IjEiIHVuaXQ9Im1nL2FjdHVhdCIvPgoJCQkJCQkJPHJhdGVRdWFudGl0eSB2YWx1ZT0iOTAiIHVuaXQ9Im1sL21pbiIvPgoJCQkJCQkJPG1heERvc2VRdWFudGl0eSBudWxsRmxhdm9yPSJVTksiPgoJCQkJCQkJCTxudW1lcmF0b3IgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJPGRlbm9taW5hdG9yIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJPC9tYXhEb3NlUXVhbnRpdHk+CgkJCQkJCQk8YWRtaW5pc3RyYXRpb25Vbml0Q29kZSBjb2RlPSJDNDI5NDQiIGRpc3BsYXlOYW1lPSJJTkhBTEFOVCIKCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4zLjI2LjEuMSIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTkNJIFRoZXNhdXJ1cyIvPgoJCQkJCQkJPGNvbnN1bWFibGU+CgkJCQkJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4KCQkJCQkJCQkJPCEtLSAqKiBNZWRpY2F0aW9uIGluZm9ybWF0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIi8+CgkJCQkJCQkJCTxpZCByb290PSIyYTYyMDE1NS05ZDExLTQzOWUtOTJiMy01ZDk4MTVmZjRlZTgiLz4KCQkJCQkJCQkJPG1hbnVmYWN0dXJlZE1hdGVyaWFsPgoJCQkJCQkJCQkJPGNvZGUgY29kZT0iMjE5NDgzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IgoJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJQcm92ZW50aWwgSEZBIj4KCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjTWVkU2VjXzEiLz4KCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iNTczNjIxIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iUHJvdmVudGlsIDAuMDkgTUcvQUNUVUFUIGluaGFsYW50IHNvbHV0aW9uIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iUnhOb3JtIi8+CgkJCQkJCQkJCQk8L2NvZGU+CgkJCQkJCQkJCTwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+CgkJCQkJCQkJCTxtYW51ZmFjdHVyZXJPcmdhbml6YXRpb24+CgkJCQkJCQkJCQk8bmFtZT5NZWRpY2F0aW9uIEZhY3RvcnkgSW5jLjwvbmFtZT4KCQkJCQkJCQkJPC9tYW51ZmFjdHVyZXJPcmdhbml6YXRpb24+CgkJCQkJCQkJPC9tYW51ZmFjdHVyZWRQcm9kdWN0PgoJCQkJCQkJPC9jb25zdW1hYmxlPgoJCQkJCQkJPHBlcmZvcm1lcj4KCQkJCQkJCQk8YXNzaWduZWRFbnRpdHk+CgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIvPgoJCQkJCQkJCQk8YWRkciBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPHRlbGVjb20gbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTkuMTM5MyIvPgoJCQkJCQkJCQkJPG5hbWU+Q29tbXVuaXR5IEhlYWx0aCBhbmQgSG9zcGl0YWxzPC9uYW1lPgoJCQkJCQkJCQkJPHRlbGVjb20gbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8YWRkciBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5PgoJCQkJCQkJPC9wZXJmb3JtZXI+CgkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+CgkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPgoJCQkJCQkJCQk8IS0tICoqIERydWcgdmVoaWNsZSAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNCIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI0MTIzMDcwMDkiIGRpc3BsYXlOYW1lPSJkcnVnIHZlaGljbGUiCgkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2Ii8+CgkJCQkJCQkJCTxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iTU1BVCI+CgkJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMjQwNDkiIGRpc3BsYXlOYW1lPSJBZXJvc29sIgoJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiCgkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSIvPgoJCQkJCQkJCQkJPG5hbWU+QWVyb3NvbDwvbmFtZT4KCQkJCQkJCQkJPC9wbGF5aW5nRW50aXR5PgoJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPgoJCQkJCQkJPC9wYXJ0aWNpcGFudD4KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+CgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJPCEtLSAqKiBJbmRpY2F0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE5Ii8+CgkJCQkJCQkJCTxpZCByb290PSJkYjczNDY0Ny1mYzk5LTQyNGMtYTg2NC03ZTNjZGE4MmU3MDMiCgkJCQkJCQkJCQlleHRlbnNpb249IjQ1NjY1Ii8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IjQwNDY4NDAwMyIgZGlzcGxheU5hbWU9IkZpbmRpbmciCgkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIvPgoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA3MDEwMyIvPgoJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjIzMzYwNDAwNyIgZGlzcGxheU5hbWU9IlBuZXVtb25pYSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiLz4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+CgkJCQkJCQkJPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJJTlQiPgoJCQkJCQkJCQk8IS0tICoqIE1lZGljYXRpb24gc3VwcGx5IG9yZGVyICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3Ii8+CgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIvPgoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+CgkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA3MDEwMyIvPgoJCQkJCQkJCQkJPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJPHJlcGVhdE51bWJlciB2YWx1ZT0iMSIvPgoJCQkJCQkJCQk8cXVhbnRpdHkgdmFsdWU9Ijc1Ii8+CgkJCQkJCQkJCTxwcm9kdWN0PgoJCQkJCQkJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4KCQkJCQkJCQkJCQk8IS0tICoqIE1lZGljYXRpb24gaW5mb3JtYXRpb24gKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIvPgoJCQkJCQkJCQkJCTxpZCByb290PSIyYTYyMDE1NS05ZDExLTQzOWUtOTJiMy01ZDk4MTVmZjRlZTgiLz4KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+CgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjU3MzYyMSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlByb3ZlbnRpbCAwLjA5IE1HL0FDVFVBVCBpbmhhbGFudCBzb2x1dGlvbiI+CgkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+CgkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNNZWRTZWNfMSIvPgoJCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjU3MzYyMSIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlByb3ZlbnRpbCAwLjA5IE1HL0FDVFVBVCBpbmhhbGFudCBzb2x1dGlvbiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSIvPgoJCQkJCQkJCQkJCQk8L2NvZGU+CgkJCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPgoJCQkJCQkJCQkJCQk8bmFtZT5NZWRpY2F0aW9uIEZhY3RvcnkgSW5jLjwvbmFtZT4KCQkJCQkJCQkJCQk8L21hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4KCQkJCQkJCQkJPC9wcm9kdWN0PgoJCQkJCQkJCQk8cGVyZm9ybWVyPgoJCQkJCQkJCQkJPGFzc2lnbmVkRW50aXR5PgoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjI5ODE4MjMiCgkJCQkJCQkJCQkJCXJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OS40NTYiLz4KCQkJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjEwMDEgVmlsbGFnZQoJCQkJCQkJCQkJCQlBdmVudWU8L3N0cmVldEFkZHJlc3NMaW5lPgoJCQkJCQkJCQkJCQk8Y2l0eT5Qb3J0bGFuZDwvY2l0eT4KCQkJCQkJCQkJCQkJPHN0YXRlPk9SPC9zdGF0ZT4KCQkJCQkJCQkJCQkJPHBvc3RhbENvZGU+OTkxMjM8L3Bvc3RhbENvZGU+CgkJCQkJCQkJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJCQkJCQkJCTwvYWRkcj4KCQkJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+CgkJCQkJCQkJCTwvcGVyZm9ybWVyPgoJCQkJCQkJCQk8YXV0aG9yPgoJCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+CgkJCQkJCQkJCQkJPGlkIHJvb3Q9IjJhNjIwMTU1LTlkMTEtNDM5ZS05MmIzLTVkOTgxNWZlNGRlOCIvPgoJCQkJCQkJCQkJCTxhZGRyIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQkJCTx0ZWxlY29tIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4KCQkJCQkJCQkJCQkJPG5hbWU+CgkJCQkJCQkJCQkJCTxwcmVmaXg+RHIuPC9wcmVmaXg+CgkJCQkJCQkJCQkJCTxnaXZlbj5IZW5yeTwvZ2l2ZW4+CgkJCQkJCQkJCQkJCTxmYW1pbHk+U2V2ZW48L2ZhbWlseT4KCQkJCQkJCQkJCQkJPC9uYW1lPgoJCQkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+CgkJCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPgoJCQkJCQkJCQk8L2F1dGhvcj4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPgoJCQkJCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IklOVCI+CgkJCQkJCQkJCQkJPCEtLSAqKiBJbnN0cnVjdGlvbnMgKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjQwOTA3MzAwNyIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9Imluc3RydWN0aW9uIi8+CgkJCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNNZWRTZWNfMSIvPiBsYWJlbCBpbiBzcGFuaXNoIDwvdGV4dD4KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCTwvYWN0PgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCTwvc3VwcGx5PgoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+CgkJCQkJCQkJPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIE1lZGljYXRpb24gZGlzcGVuc2UgKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTgiLz4KCQkJCQkJCQkJPGlkIHJvb3Q9IjEuMi4zLjQuNTY3ODkuMSIKCQkJCQkJCQkJCWV4dGVuc2lvbj0iY2I3MzQ2NDctZmM5OS00MjRjLWE4NjQtN2UzY2RhODJlNzA0Ii8+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzAxMDMiLz4KCQkJCQkJCQkJPHJlcGVhdE51bWJlciB2YWx1ZT0iMSIvPgoJCQkJCQkJCQk8cXVhbnRpdHkgdmFsdWU9Ijc1Ii8+CgkJCQkJCQkJCTxwcm9kdWN0PgoJCQkJCQkJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4KCQkJCQkJCQkJCQk8IS0tICoqIE1lZGljYXRpb24gaW5mb3JtYXRpb24gKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIvPgoJCQkJCQkJCQkJCTxpZCByb290PSIyYTYyMDE1NS05ZDExLTQzOWUtOTJiMy01ZDk4MTVmZjRlZTgiLz4KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+CgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjU3MzYyMSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlByb3ZlbnRpbCAwLjA5IE1HL0FDVFVBVCBpbmhhbGFudCBzb2x1dGlvbiI+CgkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+CgkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNNZWRTZWNfMSIvPgoJCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjU3MzYyMSIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IlByb3ZlbnRpbCAwLjA5IE1HL0FDVFVBVCBpbmhhbGFudCBzb2x1dGlvbiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSIvPgoJCQkJCQkJCQkJCQk8L2NvZGU+CgkJCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPgoJCQkJCQkJCQkJCQk8bmFtZT5NZWRpY2F0aW9uIEZhY3RvcnkgSW5jLjwvbmFtZT4KCQkJCQkJCQkJCQk8L21hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4KCQkJCQkJCQkJPC9wcm9kdWN0PgoJCQkJCQkJCQk8cGVyZm9ybWVyPgoJCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8YXNzaWduZWRFbnRpdHk+CgkJCQkJCQkJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OS40NTYiCgkJCQkJCQkJCQkJCWV4dGVuc2lvbj0iMjk4MTgyMyIvPgoJCQkJCQkJCQkJCTxhZGRyPgoJCQkJCQkJCQkJCQk8c3RyZWV0QWRkcmVzc0xpbmU+MTAwMSBWaWxsYWdlCgkJCQkJCQkJCQkJCUF2ZW51ZTwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQkJCQkJCQkJCTxjaXR5PlBvcnRsYW5kPC9jaXR5PgoJCQkJCQkJCQkJCQk8c3RhdGU+T1I8L3N0YXRlPgoJCQkJCQkJCQkJCQk8cG9zdGFsQ29kZT45OTEyMzwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQkJCTx0ZWxlY29tIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4KCQkJCQkJCQkJCQkJPG5hbWU+CgkJCQkJCQkJCQkJCTxwcmVmaXg+RHIuPC9wcmVmaXg+CgkJCQkJCQkJCQkJCTxnaXZlbj5IZW5yeTwvZ2l2ZW4+CgkJCQkJCQkJCQkJCTxmYW1pbHk+U2V2ZW48L2ZhbWlseT4KCQkJCQkJCQkJCQkJPC9uYW1lPgoJCQkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+CgkJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPgoJCQkJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTMiLz4KCQkJCQkJCQkJCQkJPG5hbWU+Q29tbXVuaXR5IEhlYWx0aCBhbmQgSG9zcGl0YWxzPC9uYW1lPgoJCQkJCQkJCQkJCQk8dGVsZWNvbSBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJCQkJPGFkZHIgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+CgkJCQkJCQkJCTwvcGVyZm9ybWVyPgoJCQkJCQkJCTwvc3VwcGx5PgoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCTxwcmVjb25kaXRpb24gdHlwZUNvZGU9IlBSQ04iPgoJCQkJCQkJCTwhLS0gKiogUHJlY29uZGl0aW9uIGZvciBzdWJzdGFuY2UgYWRtaW5pc3RyYXRpb24gKiogLS0+CgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNSIvPgoJCQkJCQkJCTxjcml0ZXJpb24+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0UiIGNvZGU9IjU2MDE4MDA0IgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IldoZWV6aW5nIi8+CgkJCQkJCQkJPC9jcml0ZXJpb24+CgkJCQkJCQk8L3ByZWNvbmRpdGlvbj4KCQkJCQkJPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4KCQkJCQk8L2VudHJ5PgoJCQkJPC9zZWN0aW9uPgoJCQk8L2NvbXBvbmVudD4KCQkJPCEtLSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQQVlFUlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogLS0+CgkJCTxjb21wb25lbnQ+CgkJCQk8c2VjdGlvbj4KCQkJCQk8IS0tIFBheWVycyBzZWN0aW9uIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMTgiLz4KCQkJCQk8Y29kZSBjb2RlPSI0ODc2OC02IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJZGlzcGxheU5hbWU9IlBheWVyIi8+CgkJCQkJPHRpdGxlPklOU1VSQU5DRSBQUk9WSURFUlM8L3RpdGxlPgoJCQkJCTx0ZXh0PgoJCQkJCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+CgkJCQkJCQk8dGhlYWQ+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGg+UGF5ZXIgbmFtZTwvdGg+CgkJCQkJCQkJCTx0aD5Qb2xpY3kgdHlwZSAvIENvdmVyYWdlIHR5cGU8L3RoPgoJCQkJCQkJCQk8dGg+UG9saWN5IElEPC90aD4KCQkJCQkJCQkJPHRoPkNvdmVyZWQgcGFydHkgSUQ8L3RoPgoJCQkJCQkJCQk8dGg+UG9saWN5IEhvbGRlcjwvdGg+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGhlYWQ+CgkJCQkJCQk8dGJvZHk+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+R29vZCBIZWFsdGggSW5zdXJhbmNlPC90ZD4KCQkJCQkJCQkJPHRkPkV4dGVuZGVkIGhlYWx0aGNhcmUgLyBGYW1pbHk8L3RkPgoJCQkJCQkJCQk8dGQ+Q29udHJhY3QgTnVtYmVyPC90ZD4KCQkJCQkJCQkJPHRkPjExMzgzNDU8L3RkPgoJCQkJCQkJCQk8dGQ+UGF0aWVudCdzIE1vdGhlcjwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGJvZHk+CgkJCQkJCTwvdGFibGU+CgkJCQkJPC90ZXh0PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBDb3ZlcmFnZSBhY3Rpdml0eSAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNjAiLz4KCQkJCQkJCTxpZCByb290PSIxZmUyY2RkMC03YWFkLTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4KCQkJCQkJCTxjb2RlIGNvZGU9IjQ4NzY4LTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTE9JTkMiIGRpc3BsYXlOYW1lPSJQYXltZW50IHNvdXJjZXMiLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJDT01QIj4KCQkJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJPCEtLSAqKiBQb2xpY3kgYWN0aXZpdHkgKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNjEiLz4KCQkJCQkJCQkJPGlkIHJvb3Q9IjNlNjc2YTUwLTdhYWMtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSJTRUxGIiBjb2RlU3lzdGVtTmFtZT0iSEw3IFJvbGVDbGFzc1JlbGF0aW9uc2hpcCIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMTEwIi8+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8IS0tIEluc3VyYW5jZSBDb21wYW55IEluZm9ybWF0aW9uIC0tPgoJCQkJCQkJCQk8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPgoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC44NyIvPgoJCQkJCQkJCQkJPHRpbWU+CgkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJCQk8aGlnaCBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJCTwvdGltZT4KCQkJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4KCQkJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkiLz4KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJQQVlPUiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTAiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJITDcgUm9sZUNvZGUiLz4KCQkJCQkJCQkJCQk8YWRkciB1c2U9IldQIj4KCQkJCQkJCQkJCQkJPCEtLSBIUCBpcyAicHJpbWFyeSBob21lIiBmcm9tIGNvZGVTeXN0ZW0gMi4xNi44NDAuMS4xMTM4ODMuNS4xMTE5IC0tPgoJCQkJCQkJCQkJCQk8c3RyZWV0QWRkcmVzc0xpbmU+MTIzIEluc3VyYW5jZQoJCQkJCQkJCQkJCQlSb2FkPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCQkJPGNpdHk+Qmx1ZSBCZWxsPC9jaXR5PgoJCQkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJCQk8cG9zdGFsQ29kZT4wMjM2ODwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCQkJCQkJCTwhLS0gVVMgaXMgIlVuaXRlZCBTdGF0ZXMiIGZyb20gSVNPIDMxNjYtMSBDb3VudHJ5IENvZGVzOiAxLjAuMzE2Ni4xIC0tPgoJCQkJCQkJCQkJCTwvYWRkcj4KCQkJCQkJCQkJCQk8dGVsZWNvbSB2YWx1ZT0idGVsOig3ODEpNTU1LTE1MTUiIHVzZT0iV1AiLz4KCQkJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJCQkJCTxuYW1lPkdvb2QgSGVhbHRoIEluc3VyYW5jZTwvbmFtZT4KCQkJCQkJCQkJCQkJPHRlbGVjb20gdmFsdWU9InRlbDooNzgxKTU1NS0xNTE1IiB1c2U9IldQIi8+CgkJCQkJCQkJCQkJCTxhZGRyIHVzZT0iV1AiPgoJCQkJCQkJCQkJCQk8IS0tIEhQIGlzICJwcmltYXJ5IGhvbWUiIGZyb20gY29kZVN5c3RlbSAyLjE2Ljg0MC4xLjExMzg4My41LjExMTkgLS0+CgkJCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xMjMgSW5zdXJhbmNlCgkJCQkJCQkJCQkJCVJvYWQ8L3N0cmVldEFkZHJlc3NMaW5lPgoJCQkJCQkJCQkJCQk8Y2l0eT5CbHVlIEJlbGw8L2NpdHk+CgkJCQkJCQkJCQkJCTxzdGF0ZT5NQTwvc3RhdGU+CgkJCQkJCQkJCQkJCTxwb3N0YWxDb2RlPjAyMzY4PC9wb3N0YWxDb2RlPgoJCQkJCQkJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJCQkJCQkJPCEtLSBVUyBpcyAiVW5pdGVkIFN0YXRlcyIgZnJvbSBJU08gMzE2Ni0xIENvdW50cnkgQ29kZXM6IDEuMC4zMTY2LjEgLS0+CgkJCQkJCQkJCQkJCTwvYWRkcj4KCQkJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPgoJCQkJCQkJCQkJPC9hc3NpZ25lZEVudGl0eT4KCQkJCQkJCQkJPC9wZXJmb3JtZXI+CgkJCQkJCQkJCTwhLS0gR3VhcmFudG9yIEluZm9ybWF0aW9uLi4uIFRoZSBwZXJzb24gcmVzcG9uc2libGUgZm9yIHRoZSBmaW5hbCBiaWxsLiAtLT4KCQkJCQkJCQkJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuODgiLz4KCQkJCQkJCQkJCTx0aW1lPgoJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQkJPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8L3RpbWU+CgkJCQkJCQkJCQk8YXNzaWduZWRFbnRpdHk+CgkJCQkJCQkJCQkJPGlkIHJvb3Q9IjMyOWZjZGYwLTdhYjMtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IkdVQVIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMTExIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iSEw3IFJvbGVDb2RlIi8+CgkJCQkJCQkJCQkJPGFkZHIgdXNlPSJIUCI+CgkJCQkJCQkJCQkJCTwhLS0gSFAgaXMgInByaW1hcnkgaG9tZSIgZnJvbSBjb2RlU3lzdGVtIDIuMTYuODQwLjEuMTEzODgzLjUuMTExOSAtLT4KCQkJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjE3IERhd3MgUmQuPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCQkJPGNpdHk+Qmx1ZSBCZWxsPC9jaXR5PgoJCQkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJCQk8cG9zdGFsQ29kZT4wMjM2ODwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCQkJCQkJCTwhLS0gVVMgaXMgIlVuaXRlZCBTdGF0ZXMiIGZyb20gSVNPIDMxNjYtMSBDb3VudHJ5IENvZGVzOiAxLjAuMzE2Ni4xIC0tPgoJCQkJCQkJCQkJCTwvYWRkcj4KCQkJCQkJCQkJCQk8dGVsZWNvbSB2YWx1ZT0idGVsOig3ODEpNTU1LTEyMTIiIHVzZT0iSFAiLz4KCQkJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+CgkJCQkJCQkJCQkJCTxuYW1lPgoJCQkJCQkJCQkJCQk8cHJlZml4Pk1yLjwvcHJlZml4PgoJCQkJCQkJCQkJCQk8Z2l2ZW4+QWRhbTwvZ2l2ZW4+CgkJCQkJCQkJCQkJCTxnaXZlbj5GcmFua2llPC9naXZlbj4KCQkJCQkJCQkJCQkJPGZhbWlseT5FdmVyeW1hbjwvZmFtaWx5PgoJCQkJCQkJCQkJCQk8L25hbWU+CgkJCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4KCQkJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+CgkJCQkJCQkJCTwvcGVyZm9ybWVyPgoJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNPViI+CgkJCQkJCQkJCQk8IS0tIENvdmVyZWQgUGFydHkgUGFydGljaXBhbnQgLS0+CgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljg5Ii8+CgkJCQkJCQkJCQk8dGltZT4KCQkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQkJCTxoaWdoIG51bGxGbGF2b3I9IlVOSyIvPgoJCQkJCQkJCQkJPC90aW1lPgoJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlBBVCI+CgkJCQkJCQkJCQkJPCEtLSBIZWFsdGggcGxhbiBJRCBmb3IgcGF0aWVudC4gLS0+CgkJCQkJCQkJCQkJPGlkIHJvb3Q9IjE0ZDRhNTIwLTdhYWUtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIKCQkJCQkJCQkJCQkJZXh0ZW5zaW9uPSIxMTM4MzQ1Ii8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iU0VMRiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJTZWxmIi8+CgkJCQkJCQkJCQkJPGFkZHIgdXNlPSJIUCI+CgkJCQkJCQkJCQkJCTwhLS0gSFAgaXMgInByaW1hcnkgaG9tZSIgZnJvbSBjb2RlU3lzdGVtIDIuMTYuODQwLjEuMTEzODgzLjUuMTExOSAtLT4KCQkJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjE3IERhd3MgUmQuPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCQkJPGNpdHk+Qmx1ZSBCZWxsPC9jaXR5PgoJCQkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJCQk8cG9zdGFsQ29kZT4wMjM2ODwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCQkJCQkJCTwhLS0gVVMgaXMgIlVuaXRlZCBTdGF0ZXMiIGZyb20gSVNPIDMxNjYtMSBDb3VudHJ5IENvZGVzOiAxLjAuMzE2Ni4xIC0tPgoJCQkJCQkJCQkJCTwvYWRkcj4KCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eT4KCQkJCQkJCQkJCQkJPG5hbWU+CgkJCQkJCQkJCQkJCTwhLS0gTmFtZSBpcyBuZWVkZWQgaWYgZGlmZmVyZW50IHRoYW4gaGVhbHRoIHBsYW4gbmFtZS4gLS0+CgkJCQkJCQkJCQkJCTxwcmVmaXg+TXIuPC9wcmVmaXg+CgkJCQkJCQkJCQkJCTxnaXZlbj5GcmFuazwvZ2l2ZW4+CgkJCQkJCQkJCQkJCTxnaXZlbj5BLjwvZ2l2ZW4+CgkJCQkJCQkJCQkJCTxmYW1pbHk+RXZlcnltYW48L2ZhbWlseT4KCQkJCQkJCQkJCQkJPC9uYW1lPgoJCQkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4KCQkJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPgoJCQkJCQkJCQk8L3BhcnRpY2lwYW50PgoJCQkJCQkJCQk8IS0tIFBvbGljeSBIb2xkZXIgLS0+CgkJCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iSExEIj4KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuOTAiLz4KCQkJCQkJCQkJCTxwYXJ0aWNpcGFudFJvbGU+CgkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iMTEzODM0NSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkiLz4KCQkJCQkJCQkJCQk8YWRkciB1c2U9IkhQIj4KCQkJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjE3IERhd3MgUmQuPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCQkJPGNpdHk+Qmx1ZSBCZWxsPC9jaXR5PgoJCQkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJCQk8cG9zdGFsQ29kZT4wMjM2ODwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+CgkJCQkJCQkJCTwvcGFydGljaXBhbnQ+CgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+CgkJCQkJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQk8IS0tICoqIEF1dGhvcml6YXRpb24gYWN0aXZpdHkgKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xOSIvPgoJCQkJCQkJCQkJCTxpZCByb290PSJmNGRjZTc5MC04MzI4LTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4KCQkJCQkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIvPgoJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+CgkJCQkJCQkJCQkJCTxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iUFJNUyI+CgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjczNzYxMDAxIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iQ29sb25vc2NvcHkiLz4KCQkJCQkJCQkJCQkJPC9wcm9jZWR1cmU+CgkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJCTwvYWN0PgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQk8IS0tIFRoZSBhYm92ZSBlbnRyeVJlbGF0aW9uc2hpcCBPUiB0aGUgZm9sbG93aW5nLiA8ZW50cnlSZWxhdGlvbnNoaXAgCgkJCQkJCQkJCQl0eXBlQ29kZT0iUkVGUiI+IDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJERUYiPiA8aWQgcm9vdD0iZjRkY2U3OTAtODMyOC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+IAoJCQkJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iVU5LIi8+IDx0ZXh0PkhlYWx0aCBQbGFuIE5hbWU8cmVmZXJlbmNlIHZhbHVlPSJQbnRyVG9IZWFsdGhQbGFuTmFtZUluU2VjdGlvblRleHQiLz4gCgkJCQkJCQkJCQk8L3RleHQ+IDxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIvPiA8L2FjdD4gPC9lbnRyeVJlbGF0aW9uc2hpcD4gLS0+CgkJCQkJCQkJPC9hY3Q+CgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQk8L2FjdD4KCQkJCQk8L2VudHJ5PgoJCQkJPC9zZWN0aW9uPgoJCQk8L2NvbXBvbmVudD4KCQkJPCEtLSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQTEFOIE9GIENBUkUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogLS0+CgkJCTxjb21wb25lbnQ+CgkJCQk8c2VjdGlvbj4KCQkJCQk8IS0tIFBsYW4gb2YgY2FyZSBzZWN0aW9uIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMTAiLz4KCQkJCQk8Y29kZSBjb2RlPSIxODc3Ni01IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJZGlzcGxheU5hbWU9IlRyZWF0bWVudCBwbGFuIi8+CgkJCQkJPHRpdGxlPlBMQU4gT0YgQ0FSRTwvdGl0bGU+CgkJCQkJPHRleHQ+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5QbGFubmVkIEFjdGl2aXR5PC90aD4KCQkJCQkJCQkJPHRoPlBsYW5uZWQgRGF0ZTwvdGg+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGhlYWQ+CgkJCQkJCQk8dGJvZHk+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+Q29sb25vc2NvcHk8L3RkPgoJCQkJCQkJCQk8dGQ+MjAxMjA1MTI8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3Rib2R5PgoJCQkJCQk8L3RhYmxlPgoJCQkJCTwvdGV4dD4KCQkJCQk8IS0tIEV4YW1wbGVzIG9mIHRoZSBzYW1lIHBsYW5uZWQgYWN0aXZpdHkgYXJlIHNob3duIGluIGRpZmZlcmVudCBwbGFuIG9mIGNhcmUgZW50cmllcyAtLT4KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPgoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJSUU8iPgoJCQkJCQkJPCEtLSAqKiBQbGFuIG9mIGNhcmUgYWN0aXZpdHkgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQ0Ii8+CgkJCQkJCQk8aWQgcm9vdD0iOWE2ZDFiYWMtMTdkMy00MTk1LTg5YTQtMTEyMWJjODA5YjRhIi8+CgkJCQkJCQk8Y29kZSBjb2RlPSI3Mzc2MTAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBkaXNwbGF5TmFtZT0iQ29sb25vc2NvcHkiLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9Im5ldyIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJPGNlbnRlciB2YWx1ZT0iMjAxMjA1MTIiLz4KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQk8L2VudHJ5PgoJCQkJCTxlbnRyeT4KCQkJCQkJPGFjdCBtb29kQ29kZT0iUlFPIiBjbGFzc0NvZGU9IkFDVCI+CgkJCQkJCQk8IS0tICoqIFBsYW4gb2YgY2FyZSBhY3Rpdml0eSBhY3QgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjM5Ii8+CgkJCQkJCQk8aWQgcm9vdD0iOWE2ZDFiYWMtMTdkMy00MTk1LTg5YTQtMTEyMWJjODA5YTVjIi8+CgkJCQkJCQk8Y29kZSBjb2RlPSI3Mzc2MTAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBkaXNwbGF5TmFtZT0iQ29sb25vc2NvcHkiLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9Im5ldyIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJPGNlbnRlciB2YWx1ZT0iMjAxMjA1MTIiLz4KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJPC9hY3Q+CgkJCQkJPC9lbnRyeT4KCQkJCQk8ZW50cnk+CgkJCQkJCTxlbmNvdW50ZXIgbW9vZENvZGU9IklOVCIgY2xhc3NDb2RlPSJFTkMiPgoJCQkJCQkJPCEtLSAqKiBQbGFuIG9mIGNhcmUgYWN0aXZpdHkgZW5jb3VudGVyICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40MCIvPgoJCQkJCQkJPGlkIHJvb3Q9IjlhNmQxYmFjLTE3ZDMtNDE5NS04OWE0LTExMjFiYzgwOWI0ZCIvPgoJCQkJCQkJPGNvZGUgY29kZT0iNzM3NjEwMDEiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgZGlzcGxheU5hbWU9IkNvbG9ub3Njb3B5Ii8+CgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJuZXciLz4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lPgoJCQkJCQkJCTxjZW50ZXIgdmFsdWU9IjIwMTIwNTEyIi8+CgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCTwvZW5jb3VudGVyPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5PgoJCQkJCQk8cHJvY2VkdXJlIG1vb2RDb2RlPSJSUU8iIGNsYXNzQ29kZT0iUFJPQyI+CgkJCQkJCQk8IS0tICoqIFBsYW4gb2YgY2FyZSBhY3Rpdml0eSBwcm9jZWR1cmUgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQxIi8+CgkJCQkJCQk8aWQgcm9vdD0iOWE2ZDFiYWMtMTdkMy00MTk1LTg5YzQtMTEyMWJjODA5YjVhIi8+CgkJCQkJCQk8Y29kZSBjb2RlPSI3Mzc2MTAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBkaXNwbGF5TmFtZT0iQ29sb25vc2NvcHkiLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9Im5ldyIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJPGNlbnRlciB2YWx1ZT0iMjAxMjA1MTIiLz4KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJPC9wcm9jZWR1cmU+CgkJCQkJPC9lbnRyeT4KCQkJCTwvc2VjdGlvbj4KCQkJPC9jb21wb25lbnQ+CgkJCTwhLS0gKioqKioqKioqKioqKioqKioqKioqKioqKiBQUk9CTEVNIExJU1QgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBjb25mb3JtcyB0byBQcm9ibGVtcyBzZWN0aW9uIHdpdGggZW50cmllcyBvcHRpb25hbCAtLT4KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjUiLz4KCQkJCQk8IS0tIFByb2JsZW1zIHNlY3Rpb24gd2l0aCBlbnRyaWVzIHJlcXVpcmVkIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuNS4xIi8+CgkJCQkJPGNvZGUgY29kZT0iMTE0NTAtNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiCgkJCQkJCWRpc3BsYXlOYW1lPSJQUk9CTEVNIExJU1QiLz4KCQkJCQk8dGl0bGU+UFJPQkxFTVM8L3RpdGxlPgoJCQkJCTx0ZXh0PgoJCQkJCQk8Y29udGVudCBJRD0icHJvYmxlbXMiLz4KCQkJCQkJPGxpc3QgbGlzdFR5cGU9Im9yZGVyZWQiPgoJCQkJCQkJPGl0ZW0+CgkJCQkJCQkJPGNvbnRlbnQgSUQ9InByb2JsZW0xIj5QbmV1bW9uaWEgPC9jb250ZW50PgoJCQkJCQkJCTxjb250ZW50IElEPSJzdGF0MSI+U3RhdHVzOiBSZXNvbHZlZDwvY29udGVudD4KCQkJCQkJCTwvaXRlbT4KCQkJCQkJCTxpdGVtPgoJCQkJCQkJCTxjb250ZW50IElEPSJwcm9ibGVtMiI+QXN0aG1hPC9jb250ZW50PgoJCQkJCQkJCTxjb250ZW50IElEPSJzdGF0MiI+U3RhdHVzOiBBY3RpdmU8L2NvbnRlbnQ+CgkJCQkJCQk8L2l0ZW0+CgkJCQkJCTwvbGlzdD4KCQkJCQk8L3RleHQ+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQk8IS0tICoqIFByb2JsZW0gY29uY2VybiBhY3QgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMiLz4KCQkJCQkJCTxpZCByb290PSJlYzhhNmZmOC1lZDRiLTRmN2UtODJjMy1lOThlNThiNDVkZTciLz4KCQkJCQkJCTxjb2RlIGNvZGU9IkNPTkMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIKCQkJCQkJCQlkaXNwbGF5TmFtZT0iQ29uY2VybiIvPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA4MDEwMyIvPgoJCQkJCQkJCTxoaWdoIHZhbHVlPSIyMDA4MDEwMyIvPgoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIFByb2JsZW0gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNCIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iYWIxNzkxYjAtNWM3MS0xMWRiLWIwZGUtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IjQwOTU4NjAwNiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJDb21wbGFpbnQiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcHJvYmxlbTEiLz4KCQkJCQkJCQkJPC90ZXh0PgoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA4MDEwMyIvPgoJCQkJCQkJCQkJPGhpZ2ggdmFsdWU9IjIwMDgwMTAzIi8+CgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMjMzNjA0MDA3IgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IlBuZXVtb25pYSIvPgoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPgoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQk8IS0tICoqIFByb2JsZW0gc3RhdHVzIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNiIvPgoJCQkJCQkJCQkJCTxpZCByb290PSJhYjE3OTFiMC01YzcxLTExZGItYjBkZS0wODAwMjAwYzlhNjYiLz4KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJTdGF0dXMiLz4KCQkJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI1NUQVQxIi8+CgkJCQkJCQkJCQkJPC90ZXh0PgoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA4MDEwMyIvPgoJCQkJCQkJCQkJCQk8aGlnaCB2YWx1ZT0iMjAwOTAyMjcxMzAwMDArMDUwMCIvPgoJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSI0MTMzMjIwMDkiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJSZXNvbHZlZCIvPgoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPgoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQk8IS0tIEFnZSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMxIi8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNDQ1NTE4MDA4IgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iQWdlIEF0IE9uc2V0Ii8+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjU3IiB1bml0PSJhIi8+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPgoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJCQk8IS0tIEhlYWx0aCBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC41Ii8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iMTEzMjMtMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIgoJCQkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iTE9JTkMiIGRpc3BsYXlOYW1lPSJIZWFsdGggc3RhdHVzIi8+CgkJCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNwcm9ibGVtcyIvPgoJCQkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSI4MTMyMzAwNCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IkFsaXZlIGFuZCB3ZWxsIi8+CgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPgoJCQkJCQk8L2FjdD4KCQkJCQk8L2VudHJ5PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSBQcm9ibGVtIGNvbmNlcm4gYWN0ICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIi8+CgkJCQkJCQk8aWQgcm9vdD0iZWM4YTZmZjgtZWQ0Yi00ZjdlLTgyYzMtZTk4ZTU4YjQ1ZGU3Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSJDT05DIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjYiCgkJCQkJCQkJZGlzcGxheU5hbWU9IkNvbmNlcm4iLz4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwNzAxMDMiLz4KCQkJCQkJCQk8aGlnaCB2YWx1ZT0iMjAwNzAxMDMiLz4KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+CgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCQkJPCEtLSAqKiBQcm9ibGVtIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQiLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImFiMTc5MWIwLTVjNzEtMTFkYi1iMGRlLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI0MDk1ODYwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iQ29tcGxhaW50Ii8+CgkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3Byb2JsZW0yIi8+CgkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPgoJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwNzAxMDMiLz4KCQkJCQkJCQkJCTxoaWdoIHZhbHVlPSIyMDA4MDEwMyIvPgoJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjE5NTk2NzAwMSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBc3RobWEiLz4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBQcm9ibGVtIHN0YXR1cyBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjYiLz4KCQkJCQkJCQkJCQk8aWQgcm9vdD0iYWIxNzkxYjAtNWM3MS0xMWRiLWIwZGUtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIgoJCQkJCQkJCQkJCQlkaXNwbGF5TmFtZT0iU3RhdHVzIi8+CgkJCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNTVEFUMiIvPgoJCQkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAwODAxMDMiLz4KCQkJCQkJCQkJCQkJPGhpZ2ggdmFsdWU9IjIwMDkwMjI3MTMwMDAwKzA1MDAiLz4KCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNTU1NjEwMDMiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJBY3RpdmUiLz4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+CgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBBZ2Ugb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMSIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjQ0NTUxODAwOCIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IkFnZSBBdCBPbnNldCIvPgoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSI1NyIgdW5pdD0iYSIvPgoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCQkJPCEtLSAqKiBIZWFsdGggc3RhdHVzIG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNSIvPgoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjExMzIzLTMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBkaXNwbGF5TmFtZT0iSGVhbHRoIHN0YXR1cyIvPgoJCQkJCQkJCQkJCTx0ZXh0PgoJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcHJvYmxlbXMiLz4KCQkJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iODEzMjMwMDQiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiCgkJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJBbGl2ZSBhbmQgd2VsbCIvPgoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4KCQkJCQkJPC9hY3Q+CgkJCQkJPC9lbnRyeT4KCQkJCTwvc2VjdGlvbj4KCQkJPC9jb21wb25lbnQ+CgkJCTwhLS0gKioqKioqKioqKioqKioqKioqKioqKioqKiogUFJPQ0VEVVJFUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBjb25mb3JtcyB0byBQcm9jZWR1cmVzIHNlY3Rpb24gd2l0aCBlbnRyaWVzIG9wdGlvbmFsIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuNyIvPgoJCQkJCTwhLS0gUHJvY2VkdXJlcyBzZWN0aW9uIHdpdGggZW50cmllcyByZXF1aXJlZCAtLT4KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjcuMSIvPgoJCQkJCTxjb2RlIGNvZGU9IjQ3NTE5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIgoJCQkJCQlkaXNwbGF5TmFtZT0iSElTVE9SWSBPRiBQUk9DRURVUkVTIi8+CgkJCQkJPHRpdGxlPlBST0NFRFVSRVM8L3RpdGxlPgoJCQkJCTx0ZXh0PgoJCQkJCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+CgkJCQkJCQk8dGhlYWQ+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGg+UHJvY2VkdXJlPC90aD4KCQkJCQkJCQkJPHRoPkRhdGU8L3RoPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQk8L3RoZWFkPgoJCQkJCQkJPHRib2R5PgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9IlByb2MxIj5Db2xvbmljIHBvbHlwZWN0b215PC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+MTk5ODwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGJvZHk+CgkJCQkJCTwvdGFibGU+CgkJCQkJPC90ZXh0PgoJCQkJCTwhLS0gRXhhbXBsZXMgb2YgdGhlIHNhbWUgcHJvY2VkdXJlIGFyZSBzaG93biBpbiBkaWZmZXJlbnQgcHJvY2VkdXJlIGVudHJpZXMgLS0+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBQcm9jZWR1cmUgYWN0aXZpdHkgcHJvY2VkdXJlICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIvPgoJCQkJCQkJPGlkIHJvb3Q9ImQ2OGI3ZTMyLTc4MTAtNGY1Yi05Y2MyLWFjZDU0YjBmZDg1ZCIvPgoJCQkJCQkJPGNvZGUgY29kZT0iNzM3NjEwMDEiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgZGlzcGxheU5hbWU9IkNvbG9ub3Njb3B5Ij4KCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjUHJvYzEiLz4KCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCTwvY29kZT4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTIwNTEyIi8+CgkJCQkJCQk8bWV0aG9kQ29kZSBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCTx0YXJnZXRTaXRlQ29kZSBjb2RlPSJhcHByb3ByaWF0ZV9jb2RlIiBkaXNwbGF5TmFtZT0iY29sb24iCgkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMi4zMjIxLjguOSIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iQm9keSBTaXRlIFZhbHVlIFNldCIvPgoJCQkJCQkJPHNwZWNpbWVuIHR5cGVDb2RlPSJTUEMiPgoJCQkJCQkJCTxzcGVjaW1lblJvbGUgY2xhc3NDb2RlPSJTUEVDIj4KCQkJCQkJCQkJPGlkIHJvb3Q9ImMyZWU5ZWU5LWFlMzEtNDYyOC1hOTE5LWZlYzFjYmI1ODY4MyIvPgoJCQkJCQkJCQk8c3BlY2ltZW5QbGF5aW5nRW50aXR5PgoJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzA5MjI2MDA1IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJjb2xvbmljIHBvbHlwIHNhbXBsZSIvPgoJCQkJCQkJCQk8L3NwZWNpbWVuUGxheWluZ0VudGl0eT4KCQkJCQkJCQk8L3NwZWNpbWVuUm9sZT4KCQkJCQkJCTwvc3BlY2ltZW4+CgkJCQkJCQk8cGVyZm9ybWVyPgoJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4KCQkJCQkJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OS40NTYiIGV4dGVuc2lvbj0iMjk4MTgyMyIvPgoJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xMDAxIFZpbGxhZ2UgQXZlbnVlPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCTxjaXR5PlBvcnRsYW5kPC9jaXR5PgoJCQkJCQkJCQkJPHN0YXRlPk9SPC9zdGF0ZT4KCQkJCQkJCQkJCTxwb3N0YWxDb2RlPjk5MTIzPC9wb3N0YWxDb2RlPgoJCQkJCQkJCQkJPGNvdW50cnk+VVM8L2NvdW50cnk+CgkJCQkJCQkJCTwvYWRkcj4KCQkJCQkJCQkJPHRlbGVjb20gdXNlPSJXUCIgdmFsdWU9IjU1NS01NTUtNTAwMCIvPgoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTMiLz4KCQkJCQkJCQkJCTxuYW1lPkNvbW11bml0eSBIZWFsdGggYW5kIEhvc3BpdGFsczwvbmFtZT4KCQkJCQkJCQkJCTx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSI1NTUtNTU1LTUwMDAiLz4KCQkJCQkJCQkJCTxhZGRyPgoJCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xMDAxIFZpbGxhZ2UKCQkJCQkJCQkJCQkJQXZlbnVlPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCQk8Y2l0eT5Qb3J0bGFuZDwvY2l0eT4KCQkJCQkJCQkJCQk8c3RhdGU+T1I8L3N0YXRlPgoJCQkJCQkJCQkJCTxwb3N0YWxDb2RlPjk5MTIzPC9wb3N0YWxDb2RlPgoJCQkJCQkJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPgoJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+CgkJCQkJCQk8L3BlcmZvcm1lcj4KCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iREVWIj4KCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+CgkJCQkJCQkJCTwhLS0gKiogUHJvZHVjdCBpbnN0YW5jZSAqKiAtLT4KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zNyIvPgoJCQkJCQkJCQk8aWQgcm9vdD0iNzQyYWVlMzAtMjFjNS0xMWUxLWJmYzItMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQkJCTxwbGF5aW5nRGV2aWNlPgoJCQkJCQkJCQkJPGNvZGUgY29kZT0iOTA0MTIwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJCQkJZGlzcGxheU5hbWU9IkNvbG9ub3Njb3BlIi8+CgkJCQkJCQkJCTwvcGxheWluZ0RldmljZT4KCQkJCQkJCQkJPHNjb3BpbmdFbnRpdHk+CgkJCQkJCQkJCQk8aWQgcm9vdD0iZWI5MzYwMTAtN2IxNy0xMWRiLTlmZTEtMDgwMDIwMGM5YjY1Ii8+CgkJCQkJCQkJCTwvc2NvcGluZ0VudGl0eT4KCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4KCQkJCQkJCTwvcGFydGljaXBhbnQ+CgkJCQkJCTwvcHJvY2VkdXJlPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5PgoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBQcm9jZWR1cmUgYWN0aXZpdHkgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjEzIi8+CgkJCQkJCQk8aWQgZXh0ZW5zaW9uPSIxMjM0NTY3ODkiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSIyNzQwMjUwMDUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiCgkJCQkJCQkJZGlzcGxheU5hbWU9IkNvbG9uaWMgcG9seXBlY3RvbXkiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQtQ1QiPgoJCQkJCQkJCTxvcmlnaW5hbFRleHQ+CgkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNQcm9jMSIvPgoJCQkJCQkJCTwvb3JpZ2luYWxUZXh0PgoJCQkJCQkJPC9jb2RlPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iYWJvcnRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTEwMjAzIi8+CgkJCQkJCQk8cHJpb3JpdHlDb2RlIGNvZGU9IkNSIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjciCgkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkFjdFByaW9yaXR5IiBkaXNwbGF5TmFtZT0iQ2FsbGJhY2sgcmVzdWx0cyIvPgoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIvPgoJCQkJCQkJPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQk8dGFyZ2V0U2l0ZUNvZGUgY29kZT0iNDE2OTQ5MDA4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIGRpc3BsYXlOYW1lPSJBYmRvbWVuIGFuZCBwZWx2aXMiLz4KCQkJCQkJCTxwZXJmb3JtZXI+CgkJCQkJCQkJPGFzc2lnbmVkRW50aXR5PgoJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNSIgZXh0ZW5zaW9uPSIxMjM0Ii8+CgkJCQkJCQkJCTxhZGRyPgoJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjE3IERhd3MgUmQuPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCTxjaXR5PkJsdWUgQmVsbDwvY2l0eT4KCQkJCQkJCQkJCTxzdGF0ZT5NQTwvc3RhdGU+CgkJCQkJCQkJCQk8cG9zdGFsQ29kZT4wMjM2ODwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJCQkJCQk8L2FkZHI+CgkJCQkJCQkJCTx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSIoNTU1KTU1NS01NTUtMTIzNCIvPgoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNSIvPgoJCQkJCQkJCQkJPG5hbWU+Q29tbXVuaXR5IEhlYWx0aCBhbmQgSG9zcGl0YWxzPC9uYW1lPgoJCQkJCQkJCQkJPHRlbGVjb20gbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8YWRkciBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5PgoJCQkJCQkJPC9wZXJmb3JtZXI+CgkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+CgkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4KCQkJCQkJCQkJPCEtLSAqKiBTZXJ2aWNlIGRlbGl2ZXJ5IGxvY2F0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMyIi8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IjExMTgtOSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTkiCgkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iSGVhbHRoY2FyZVNlcnZpY2VMb2NhdGlvbiIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJHYXN0cm9lbnRlcm9sb2d5IENsaW5pYyIvPgoJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xNyBEYXdzIFJkLjwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQkJCQkJCQk8Y2l0eT5CbHVlIEJlbGw8L2NpdHk+CgkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJPHBvc3RhbENvZGU+MDIzNjg8L3Bvc3RhbENvZGU+CgkJCQkJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQk8dGVsZWNvbSBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPgoJCQkJCQkJCQkJPG5hbWU+Q29tbXVuaXR5IEdhc3Ryb2VudGVyb2xvZ3kgQ2xpbmljPC9uYW1lPgoJCQkJCQkJCQk8L3BsYXlpbmdFbnRpdHk+CgkJCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+CgkJCQkJCQk8L3BhcnRpY2lwYW50PgoJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5PgoJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4KCQkJCQkJCTwhLS0gUHJvY2VkdXJlIGFjdGl2aXR5IGFjdCAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTIiLz4KCQkJCQkJCTxpZCByb290PSIxLjIuMy40LjUuNi43LjgiIGV4dGVuc2lvbj0iMTIzNDU2NyIvPgoJCQkJCQkJPGNvZGUgY29kZT0iMjc0MDI1MDA1IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIGRpc3BsYXlOYW1lPSJDb2xvbmljIHBvbHlwZWN0b215Ij4KCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjUHJvYzEiLz4KCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4KCQkJCQkJCTwvY29kZT4KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTEwMjAzIi8+CgkJCQkJCQk8cHJpb3JpdHlDb2RlIGNvZGU9IkNSIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjciCgkJCQkJCQkJY29kZVN5c3RlbU5hbWU9IkFjdFByaW9yaXR5IiBkaXNwbGF5TmFtZT0iQ2FsbGJhY2sgcmVzdWx0cyIvPgoJCQkJCQkJPHBlcmZvcm1lcj4KCQkJCQkJCQk8YXNzaWduZWRFbnRpdHk+CgkJCQkJCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOSIgZXh0ZW5zaW9uPSIxMjM0Ii8+CgkJCQkJCQkJCTxhZGRyPgoJCQkJCQkJCQkJPHN0cmVldEFkZHJlc3NMaW5lPjE3IERhd3MgUmQuPC9zdHJlZXRBZGRyZXNzTGluZT4KCQkJCQkJCQkJCTxjaXR5PkJsdWUgQmVsbDwvY2l0eT4KCQkJCQkJCQkJCTxzdGF0ZT5NQTwvc3RhdGU+CgkJCQkJCQkJCQk8cG9zdGFsQ29kZT4wMjM2ODwvcG9zdGFsQ29kZT4KCQkJCQkJCQkJCTxjb3VudHJ5PlVTPC9jb3VudHJ5PgoJCQkJCQkJCQk8L2FkZHI+CgkJCQkJCQkJCTx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSIoNTU1KTU1NS01NTUtMTIzNCIvPgoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+CgkJCQkJCQkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNSIvPgoJCQkJCQkJCQkJPG5hbWU+Q29tbXVuaXR5IEhlYWx0aCBhbmQgSG9zcGl0YWxzPC9uYW1lPgoJCQkJCQkJCQkJPHRlbGVjb20gbnVsbEZsYXZvcj0iVU5LIi8+CgkJCQkJCQkJCQk8YWRkciBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4KCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5PgoJCQkJCQkJPC9wZXJmb3JtZXI+CgkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+CgkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4KCQkJCQkJCQkJPCEtLSAqKiBTZXJ2aWNlIGRlbGl2ZXJ5IGxvY2F0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMyIi8+CgkJCQkJCQkJCTxjb2RlIGNvZGU9IjExMTgtOSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTkiCgkJCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iSGVhbHRoY2FyZVNlcnZpY2VMb2NhdGlvbiIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJHYXN0cm9lbnRlcm9sb2d5IENsaW5pYyIvPgoJCQkJCQkJCQk8YWRkcj4KCQkJCQkJCQkJCTxzdHJlZXRBZGRyZXNzTGluZT4xNyBEYXdzIFJkLjwvc3RyZWV0QWRkcmVzc0xpbmU+CgkJCQkJCQkJCQk8Y2l0eT5CbHVlIEJlbGw8L2NpdHk+CgkJCQkJCQkJCQk8c3RhdGU+TUE8L3N0YXRlPgoJCQkJCQkJCQkJPHBvc3RhbENvZGU+MDIzNjg8L3Bvc3RhbENvZGU+CgkJCQkJCQkJCQk8Y291bnRyeT5VUzwvY291bnRyeT4KCQkJCQkJCQkJPC9hZGRyPgoJCQkJCQkJCQk8dGVsZWNvbSBudWxsRmxhdm9yPSJVTksiLz4KCQkJCQkJCQkJPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPgoJCQkJCQkJCQkJPG5hbWU+Q29tbXVuaXR5IEdhc3Ryb2VudGVyb2xvZ3kgQ2xpbmljPC9uYW1lPgoJCQkJCQkJCQk8L3BsYXlpbmdFbnRpdHk+CgkJCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+CgkJCQkJCQk8L3BhcnRpY2lwYW50PgoJCQkJCQk8L2FjdD4KCQkJCQk8L2VudHJ5PgoJCQkJPC9zZWN0aW9uPgoJCQk8L2NvbXBvbmVudD4KCQkJPCEtLSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFJFU1VMVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAtLT4KCQkJPGNvbXBvbmVudD4KCQkJCTxzZWN0aW9uPgoJCQkJCTwhLS0gY29uZm9ybXMgdG8gUmVzdWx0cyBzZWN0aW9uIHdpdGggZW50cmllcyBvcHRpb25hbCAtLT4KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjMiLz4KCQkJCQk8IS0tIFJlc3VsdHMgc2VjdGlvbiB3aXRoIGVudHJpZXMgcmVxdWlyZWQgLS0+CgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4zLjEiLz4KCQkJCQk8Y29kZSBjb2RlPSIzMDk1NC0yIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJZGlzcGxheU5hbWU9IlJFU1VMVFMiLz4KCQkJCQk8dGl0bGU+UkVTVUxUUzwvdGl0bGU+CgkJCQkJPHRleHQ+CgkJCQkJCTx0YWJsZT4KCQkJCQkJCTx0Ym9keT4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZCBjb2xzcGFuPSIyIj5MQUJPUkFUT1JZIElORk9STUFUSU9OPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkIGNvbHNwYW49IjIiPkNoZW1pc3RyaWVzIGFuZCBkcnVnIGxldmVsczwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJyZXN1bHQxIj5IR0IgKE0gMTMtMTggZy9kbDsgRiAxMi0xNgoJCQkJCQkJCQkJCWcvZGwpPC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+MTMuMjwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJyZXN1bHQyIj5XQkMgKDQuMy0xMC44IDEwKzMvdWwpPC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+Ni43PC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InJlc3VsdDMiPlBMVCAoMTM1LTE0NSBtZXEvbCk8L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJCTx0ZD4xMjMgKEwpPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkIGNvbHNwYW49IjIiPkxpdmVyIEZ1bmN0aW9ucyBhbmQgT3RoZXIgTGFib3JhdG9yeSBWYWx1ZXM8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+QUxUIChTR1BUKTwvdGQ+CgkJCQkJCQkJCTx0ZD4zMS4wPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPkFTVCAoU0dPVCk8L3RkPgoJCQkJCQkJCQk8dGQ+MTguMDwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5HR1Q8L3RkPgoJCQkJCQkJCQk8dGQ+MjguMCBBbGs8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+UGhvczwvdGQ+CgkJCQkJCQkJCTx0ZD44Ni4wPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPlRvdGFsIEJpbGk8L3RkPgoJCQkJCQkJCQk8dGQ+MC4xPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPkFsYnVtaW48L3RkPgoJCQkJCQkJCQk8dGQ+My4yPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkIGNvbHNwYW49IjIiPkJsb29kIENvdW50PC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPldoaXRlIENvdW50PC90ZD4KCQkJCQkJCQkJPHRkPjcuNzwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0ZD5QbGF0ZWxldHM8L3RkPgoJCQkJCQkJCQk8dGQ+MTg3LjA8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+SGVtYXRvY3JpdDwvdGQ+CgkJCQkJCQkJCTx0ZD4yMy43PC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPkhlbW9nbG9iaW48L3RkPgoJCQkJCQkJCQk8dGQ+OC4xPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkIGNvbHNwYW49IjIiPkVMRUNUUk9DQVJESU9HUkFNIChFS0cpIElORk9STUFUSU9OPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPkVLRzwvdGQ+CgkJCQkJCQkJCTx0ZD5TaW51cyByaHl0aG0gd2l0aG91dCBhY3V0ZSBjaGFuZ2VzPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90Ym9keT4KCQkJCQkJPC90YWJsZT4KCQkJCQk8L3RleHQ+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPG9yZ2FuaXplciBjbGFzc0NvZGU9IkJBVFRFUlkiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBSZXN1bHQgb3JnYW5pemVyICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xIi8+CgkJCQkJCQk8aWQgcm9vdD0iN2Q1YTAyYjAtNjdhNC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSI0Mzc4OTAwOSIgZGlzcGxheU5hbWU9IkNCQyBXTyBESUZGRVJFTlRJQUwiCgkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIvPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8Y29tcG9uZW50PgoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCTwhLS0gKiogUmVzdWx0IG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiLz4KCQkJCQkJCQkJPGlkIHJvb3Q9IjEwN2MyZGMwLTY3YTUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMDMxMy0xIiBkaXNwbGF5TmFtZT0iSEdCIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0MSIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDAzMjMxNDMwIi8+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSIxMy4yIiB1bml0PSJnL2RsIi8+CgkJCQkJCQkJCTxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIvPgoJCQkJCQkJCQk8cmVmZXJlbmNlUmFuZ2U+CgkJCQkJCQkJCQk8b2JzZXJ2YXRpb25SYW5nZT4KCQkJCQkJCQkJCQk8dGV4dD5NIDEzLTE4IGcvZGw7IEYgMTItMTYgZy9kbDwvdGV4dD4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb25SYW5nZT4KCQkJCQkJCQkJPC9yZWZlcmVuY2VSYW5nZT4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9jb21wb25lbnQ+CgkJCQkJCQk8Y29tcG9uZW50PgoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCTwhLS0gKiogUmVzdWx0IG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiLz4KCQkJCQkJCQkJPGlkIHJvb3Q9IjEwN2MyZGMwLTY3YTUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMzc2NS05IiBkaXNwbGF5TmFtZT0iV0JDIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0MiIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDAzMjMxNDMwIi8+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSI2LjciIHVuaXQ9IjEwKzMvdWwiLz4KCQkJCQkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIi8+CgkJCQkJCQkJCTxyZWZlcmVuY2VSYW5nZT4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvblJhbmdlPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSVZMX1BRIj4KCQkJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iNC4zIiB1bml0PSIxMCszL3VsIi8+CgkJCQkJCQkJCQkJCTxoaWdoIHZhbHVlPSIxMC44IiB1bml0PSIxMCszL3VsIi8+CgkJCQkJCQkJCQkJPC92YWx1ZT4KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb25SYW5nZT4KCQkJCQkJCQkJPC9yZWZlcmVuY2VSYW5nZT4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9jb21wb25lbnQ+CgkJCQkJCQk8Y29tcG9uZW50PgoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQkJCTwhLS0gKiogUmVzdWx0IG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiLz4KCQkJCQkJCQkJPGlkIHJvb3Q9IjEwN2MyZGMwLTY3YTUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSIyNjUxNS03IiBkaXNwbGF5TmFtZT0iUExUIgoJCQkJCQkJCQkJY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0MyIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDAzMjMxNDMwIi8+CgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSIxMjMiIHVuaXQ9IjEwKzMvdWwiLz4KCQkJCQkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJMIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIi8+CgkJCQkJCQkJCTxyZWZlcmVuY2VSYW5nZT4KCQkJCQkJCQkJCTxvYnNlcnZhdGlvblJhbmdlPgoJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSVZMX1BRIj4KCQkJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMTUwIiB1bml0PSIxMCszL3VsIi8+CgkJCQkJCQkJCQkJCTxoaWdoIHZhbHVlPSIzNTAiIHVuaXQ9IjEwKzMvdWwiLz4KCQkJCQkJCQkJCQk8L3ZhbHVlPgoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvblJhbmdlPgoJCQkJCQkJCQk8L3JlZmVyZW5jZVJhbmdlPgoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJCQk8L2NvbXBvbmVudD4KCQkJCQkJPC9vcmdhbml6ZXI+CgkJCQkJPC9lbnRyeT4KCQkJCTwvc2VjdGlvbj4KCQkJPC9jb21wb25lbnQ+CgkJCTwhLS0gKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogU09DSUFMIEhJU1RPUlkgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBTb2NpYWwgaGlzdG9yeSBzZWN0aW9uIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMTciLz4KCQkJCQk8Y29kZSBjb2RlPSIyOTc2Mi0yIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiCgkJCQkJCWRpc3BsYXlOYW1lPSJTb2NpYWwgSGlzdG9yeSIvPgoJCQkJCTx0aXRsZT5TT0NJQUwgSElTVE9SWTwvdGl0bGU+CgkJCQkJPHRleHQ+CgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4KCQkJCQkJCTx0aGVhZD4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aD5Tb2NpYWwgSGlzdG9yeSBFbGVtZW50PC90aD4KCQkJCQkJCQkJPHRoPkRlc2NyaXB0aW9uPC90aD4KCQkJCQkJCQkJPHRoPkVmZmVjdGl2ZSBEYXRlczwvdGg+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGhlYWQ+CgkJCQkJCQk8dGJvZHk+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+CgkJCQkJCQkJCQk8Y29udGVudCBJRD0ic29jMSIvPiBzbW9raW5nIDwvdGQ+CgkJCQkJCQkJCTx0ZD4xIHBhY2sgcGVyIGRheTwvdGQ+CgkJCQkJCQkJCTx0ZD4yMDA1MDUwMSB0byAyMDA5MDIyNzEzMDAwMCswNTAwPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InNvYzIiLz4gc21va2luZyA8L3RkPgoJCQkJCQkJCQk8dGQ+Tm9uZTwvdGQ+CgkJCQkJCQkJCTx0ZD4yMDA5MDIyNzEzMDAwMCswNTAwIC0gdG9kYXk8L3RkPgoJCQkJCQkJCTwvdHI+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGQ+CgkJCQkJCQkJCQk8Y29udGVudCBJRD0ic29jMyIvPiBBbGNvaG9sIGNvbnN1bXB0aW9uIDwvdGQ+CgkJCQkJCQkJCTx0ZD5Ob25lPC90ZD4KCQkJCQkJCQkJPHRkPjIwMDUwNTAxIC0gPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90Ym9keT4KCQkJCQkJPC90YWJsZT4KCQkJCQk8L3RleHQ+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4KCQkJCQkJCTwhLS0gKiogU21va2luZyBzdGF0dXMgb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljc4Ii8+CgkJCQkJCQk8aWQgZXh0ZW5zaW9uPSIxMjM0NTY3ODkiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA1MDUwMSIvPgoJCQkJCQkJCTxoaWdoIHZhbHVlPSIyMDA5MDIyNzEzMDAwMCswNTAwIi8+CgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSI4NTE3MDA2IiBkaXNwbGF5TmFtZT0iRm9ybWVyIHNtb2tlciIKCQkJCQkJCQljb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2Ii8+CgkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJPC9lbnRyeT4KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPgoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBTb2NpYWwgaGlzdG9yeSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzgiLz4KCQkJCQkJCTxpZCByb290PSI5YjU2YzI1ZC05MTA0LTQ1ZWUtOWZhNC1lMGYzYWZhYTAxYzEiLz4KCQkJCQkJCTxjb2RlIGNvZGU9IjIyOTgxOTAwNyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQlkaXNwbGF5TmFtZT0iVG9iYWNjbyB1c2UgYW5kIGV4cG9zdXJlIj4KCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjc29jMSIvPgoJCQkJCQkJCTwvb3JpZ2luYWxUZXh0PgoJCQkJCQkJPC9jb2RlPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA1MDUwMSIvPgoJCQkJCQkJCTxoaWdoIHZhbHVlPSIyMDA5MDIyNzEzMDAwMCswNTAwIi8+CgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlNUIj4xIHBhY2sgcGVyIGRheTwvdmFsdWU+CgkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJPC9lbnRyeT4KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPgoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBTb2NpYWwgaGlzdG9yeSBvYnNlcnZhdGlvbiAqKiAtLT4KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzgiLz4KCQkJCQkJCTxpZCByb290PSI0NWVmYjYwNC03MDQ5LTRhMmUtYWQzMy1kMzg1NTZjOTYzNmMiLz4KCQkJCQkJCTxjb2RlIGNvZGU9IjIyOTgxOTAwNyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQlkaXNwbGF5TmFtZT0iVG9iYWNjbyB1c2UgYW5kIGV4cG9zdXJlIj4KCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjc29jMiIvPgoJCQkJCQkJCTwvb3JpZ2luYWxUZXh0PgoJCQkJCQkJPC9jb2RlPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA5MDIyNzEzMDAwMCswNTAwIi8+CgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+CgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlNUIj5Ob25lPC92YWx1ZT4KCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQk8L2VudHJ5PgoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+CgkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+CgkJCQkJCQk8IS0tICoqIFNvY2lhbCBoaXN0b3J5IG9ic2VydmF0aW9uICoqIC0tPgoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zOCIvPgoJCQkJCQkJPGlkIHJvb3Q9IjM3Zjc2YzUxLTY0MTEtNGUxZC04YTM3LTk1N2ZkNDlkMmNlZiIvPgoJCQkJCQkJPGNvZGUgY29kZT0iMTYwNTczMDAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IgoJCQkJCQkJCWRpc3BsYXlOYW1lPSJBbGNvaG9sIGNvbnN1bXB0aW9uIj4KCQkJCQkJCQk8b3JpZ2luYWxUZXh0PgoJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjc29jMyIvPgoJCQkJCQkJCTwvb3JpZ2luYWxUZXh0PgoJCQkJCQkJPC9jb2RlPgoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDA1MDUwMSIvPgoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPgoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJTVCI+Tm9uZTwvdmFsdWU+CgkJCQkJCTwvb2JzZXJ2YXRpb24+CgkJCQkJPC9lbnRyeT4KCQkJCTwvc2VjdGlvbj4KCQkJPC9jb21wb25lbnQ+CgkJCTwhLS0gKioqKioqKioqKioqKioqKioqKiogVklUQUwgU0lHTlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC0tPgoJCQk8Y29tcG9uZW50PgoJCQkJPHNlY3Rpb24+CgkJCQkJPCEtLSBjb25mb3JtcyB0byBWaXRhbCBTaWducyBzZWN0aW9uIHdpdGggZW50cmllcyBvcHRpb25hbCAtLT4KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjQiLz4KCQkJCQk8IS0tIFZpdGFsIFNpZ25zIHNlY3Rpb24gd2l0aCBlbnRyaWVzIHJlcXVpcmVkIC0tPgoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuNC4xIi8+CgkJCQkJPGNvZGUgY29kZT0iODcxNi0zIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJZGlzcGxheU5hbWU9IlZJVEFMIFNJR05TIi8+CgkJCQkJPHRpdGxlPlZJVEFMIFNJR05TPC90aXRsZT4KCQkJCQk8dGV4dD4KCQkJCQkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPgoJCQkJCQkJPHRoZWFkPgoJCQkJCQkJCTx0cj4KCQkJCQkJCQkJPHRoIGFsaWduPSJyaWdodCI+RGF0ZSAvIFRpbWU6IDwvdGg+CgkJCQkJCQkJCTx0aD5Ob3YgMTQsIDE5OTk8L3RoPgoJCQkJCQkJCQk8dGg+QXByaWwgNywgMjAwMDwvdGg+CgkJCQkJCQkJPC90cj4KCQkJCQkJCTwvdGhlYWQ+CgkJCQkJCQk8dGJvZHk+CgkJCQkJCQkJPHRyPgoJCQkJCQkJCQk8dGggYWxpZ249ImxlZnQiPkhlaWdodDwvdGg+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJ2aXQxIj4xNzcgY208L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJ2aXQyIj4xNzcgY208L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aCBhbGlnbj0ibGVmdCI+V2VpZ2h0PC90aD4KCQkJCQkJCQkJPHRkPgoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InZpdDMiPjg2IGtnPC9jb250ZW50PgoJCQkJCQkJCQk8L3RkPgoJCQkJCQkJCQk8dGQ+CgkJCQkJCQkJCQk8Y29udGVudCBJRD0idml0NCI+ODgga2c8L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJPC90cj4KCQkJCQkJCQk8dHI+CgkJCQkJCQkJCTx0aCBhbGlnbj0ibGVmdCI+Qmxvb2QgUHJlc3N1cmU8L3RoPgoJCQkJCQkJCQk8dGQ+CgkJCQkJCQkJCQk8Y29udGVudCBJRD0idml0NSI+MTMyLzg2IG1tSGc8L2NvbnRlbnQ+CgkJCQkJCQkJCTwvdGQ+CgkJCQkJCQkJCTx0ZD4KCQkJCQkJCQkJCTxjb250ZW50IElEPSJ2aXQ2Ij4xNDUvODggbW1IZzwvY29udGVudD4KCQkJCQkJCQkJPC90ZD4KCQkJCQkJCQk8L3RyPgoJCQkJCQkJPC90Ym9keT4KCQkJCQkJPC90YWJsZT4KCQkJCQk8L3RleHQ+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPG9yZ2FuaXplciBjbGFzc0NvZGU9IkNMVVNURVIiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBWaXRhbCBzaWducyBvcmdhbml6ZXIgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI2Ii8+CgkJCQkJCQk8aWQgcm9vdD0iYzZmODgzMjAtNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSI0NjY4MDAwNSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIC1DVCIgZGlzcGxheU5hbWU9IlZpdGFsIHNpZ25zIi8+CgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIxOTk5MTExNCIvPgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIFZpdGFsIHNpZ24gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImM2Zjg4MzIxLTY3YWQtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI4MzAyLTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9IkhlaWdodCIvPgoJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiN2aXQxIi8+CgkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIxOTk5MTExNCIvPgoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlBRIiB2YWx1ZT0iMTc3IiB1bml0PSJjbSIvPgoJCQkJCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiCgkJCQkJCQkJCS8+CgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCTwvY29tcG9uZW50PgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIFZpdGFsIHNpZ24gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImM2Zjg4MzIxLTY3YWQtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMTQxLTkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJQYXRpZW50IEJvZHkgV2VpZ2h0IC0gTWVhc3VyZWQiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjdml0MyIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMTk5OTExMTQiLz4KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9Ijg2IiB1bml0PSJrZyIvPgoJCQkJCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiCgkJCQkJCQkJCS8+CgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCTwvY29tcG9uZW50PgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIFZpdGFsIHNpZ24gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImM2Zjg4MzIxLTY3YWQtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI4NDgwLTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9IkludHJhdmFzY3VsYXIgU3lzdG9saWMiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjdml0NSIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMTk5OTExMTQiLz4KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjEzMiIgdW5pdD0ibW1bSGddIi8+CgkJCQkJCQkJCTxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIKCQkJCQkJCQkJLz4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9jb21wb25lbnQ+CgkJCQkJCTwvb3JnYW5pemVyPgoJCQkJCTwvZW50cnk+CgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4KCQkJCQkJPG9yZ2FuaXplciBjbGFzc0NvZGU9IkNMVVNURVIiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJPCEtLSAqKiBWaXRhbCBzaWducyBvcmdhbml6ZXIgKiogLS0+CgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI2Ii8+CgkJCQkJCQk8aWQgcm9vdD0iYzZmODgzMjAtNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+CgkJCQkJCQk8Y29kZSBjb2RlPSI0NjY4MDAwNSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIKCQkJCQkJCQljb2RlU3lzdGVtTmFtZT0iU05PTUVEIC1DVCIgZGlzcGxheU5hbWU9IlZpdGFsIHNpZ25zIi8+CgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDAwMDQwNyIvPgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIFZpdGFsIHNpZ24gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImM2Zjg4MzIxLTY3YWQtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI4MzAyLTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9IkhlaWdodCIvPgoJCQkJCQkJCQk8dGV4dD4KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiN2aXQyIi8+CgkJCQkJCQkJCTwvdGV4dD4KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+CgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDAwMDQwNyIvPgoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlBRIiB2YWx1ZT0iMTc3IiB1bml0PSJjbSIvPgoJCQkJCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiCgkJCQkJCQkJCS8+CgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCTwvY29tcG9uZW50PgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIFZpdGFsIHNpZ24gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImM2Zjg4MzIxLTY3YWQtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMTQxLTkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIKCQkJCQkJCQkJCWRpc3BsYXlOYW1lPSJQYXRpZW50IEJvZHkgV2VpZ2h0IC0gTWVhc3VyZWQiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjdml0NCIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDA0MDciLz4KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9Ijg4IiB1bml0PSJrZyIvPgoJCQkJCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiCgkJCQkJCQkJCS8+CgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4KCQkJCQkJCTwvY29tcG9uZW50PgoJCQkJCQkJPGNvbXBvbmVudD4KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPgoJCQkJCQkJCQk8IS0tICoqIFZpdGFsIHNpZ24gb2JzZXJ2YXRpb24gKiogLS0+CgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciLz4KCQkJCQkJCQkJPGlkIHJvb3Q9ImM2Zjg4MzIxLTY3YWQtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPgoJCQkJCQkJCQk8Y29kZSBjb2RlPSI4NDgwLTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIKCQkJCQkJCQkJCWNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9IkludHJhdmFzY3VsYXIgU3lzdG9saWMiLz4KCQkJCQkJCQkJPHRleHQ+CgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjdml0NiIvPgoJCQkJCQkJCQk8L3RleHQ+CgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPgoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDA0MDciLz4KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjE0NSIgdW5pdD0ibW1bSGddIi8+CgkJCQkJCQkJCTxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIKCQkJCQkJCQkJLz4KCQkJCQkJCQk8L29ic2VydmF0aW9uPgoJCQkJCQkJPC9jb21wb25lbnQ+CgkJCQkJCTwvb3JnYW5pemVyPgoJCQkJCTwvZW50cnk+CgkJCQk8L3NlY3Rpb24+CgkJCTwvY29tcG9uZW50PgoJCTwvc3RydWN0dXJlZEJvZHk+Cgk8L2NvbXBvbmVudD4KPC9DbGluaWNhbERvY3VtZW50Pgo=","base64").toString();
        var result = bb.parseString(data);

        // check validation
        var val = bb.validator.validateDocumentModel(result);
        expect(val).to.be.true;

        // generate ccda
        var xml = bbg.generateCCD(result);

        // parse generated ccda
        var result2 = bb.parseString(xml);
        var val2 = bb.validator.validateDocumentModel(result2);
        expect(val2).to.be.true;

        // re-generate
        var xml2 = bbg.generateCCD(result2);

        delete result.errors;
        delete result2.errors;

        assert.deepEqual(result2, result);
    });

    it('Vitera_CCDA_SMART_Sample.xml should still be same', function () {
        var data = Buffer("PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4NCjw/eG1sLXN0eWxlc2hlZXQgdHlwZT0ndGV4dC94c2wnIGhyZWY9J0NDRC54c2wnPz4NCjxDbGluaWNhbERvY3VtZW50IHhtbG5zPSJ1cm46aGw3LW9yZzp2MyIgeG1sbnM6c2R0Yz0idXJuOmhsNy1vcmc6c2R0YyIgeG1sbnM6dm9jPSJ1cm46aGw3LW9yZzp2My92b2MiIHhtbG5zOnhzaT0iaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UiIHhzaTpzY2hlbWFMb2NhdGlvbj0idXJuOmhsNy1vcmc6djMgQ0RBLnhzZCI+DQogIDxyZWFsbUNvZGUgY29kZT0iVVMiIC8+DQogIDx0eXBlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMS4zIiBleHRlbnNpb249IlBPQ0RfSEQwMDAwNDAiIC8+DQogIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjEuMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iVVMgUmVhbG0gQ2xpbmljYWwgRG9jdW1lbnQgSGVhZGVyIiAvPg0KICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4xLjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNvbnNvbGlkYXRlZCBDREEgLSBDQ0QgRG9jdW1lbnQiIC8+DQogIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xLjEzMDkyNTk3LjEyNDU2MTM5IiAvPg0KICA8Y29kZSBjb2RlPSIzNDEzMy05IiBkaXNwbGF5TmFtZT0iU3VtbWFyaXphdGlvbiBvZiBFcGlzb2RlIE5vdGUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICA8dGl0bGU+RnVsbCBDaGFydCAtIE1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L3RpdGxlPg0KICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAxMzA5MjUxMzI3MzYtMDQwMCIgLz4NCiAgPGNvbmZpZGVudGlhbGl0eUNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4yNSIgY29kZVN5c3RlbU5hbWU9IkNvbmZpZGVudGlhbGl0eSBDb2RlIiAvPg0KICA8bGFuZ3VhZ2VDb2RlIGNvZGU9ImVuZyIgLz4NCiAgPHJlY29yZFRhcmdldD4NCiAgICA8cGF0aWVudFJvbGU+DQogICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNCIgZXh0ZW5zaW9uPSIxMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iSW50ZXJneSBQYXRpZW50IE51bWJlciIgLz4NCiAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjEiIGV4dGVuc2lvbj0iNjQzLTAwLTU2MzkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IlNTTiIgLz4NCiAgICAgIDxhZGRyPg0KICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQ1NiBXZXN0IFBhbG08L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+QXB0LiAjMzQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICA8L2FkZHI+DQogICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMzI5MyIgdXNlPSJIUCIgLz4NCiAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS01NTQ0IiB1c2U9IldQIiAvPg0KICAgICAgPHRlbGVjb20gdmFsdWU9Im1haWx0bzpjYXJsc29uc2FAZTRoZWFsdGguY29tIiAvPg0KICAgICAgPHBhdGllbnQ+DQogICAgICAgIDxuYW1lPg0KICAgICAgICAgIDxnaXZlbj5TaGFyb248L2dpdmVuPg0KICAgICAgICAgIDxnaXZlbj5BPC9naXZlbj4NCiAgICAgICAgICA8ZmFtaWx5PkNhcmxzb248L2ZhbWlseT4NCiAgICAgICAgPC9uYW1lPg0KICAgICAgICA8YWRtaW5pc3RyYXRpdmVHZW5kZXJDb2RlIGNvZGU9IkYiIGRpc3BsYXlOYW1lPSJGZW1hbGUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMSIgY29kZVN5c3RlbU5hbWU9IkFkbWluaXN0cmF0aXZlR2VuZGVyIiAvPg0KICAgICAgICA8YmlydGhUaW1lIHZhbHVlPSIxOTM4MTIxMiIgLz4NCiAgICAgICAgPG1hcml0YWxTdGF0dXNDb2RlIGNvZGU9Ik0iIGRpc3BsYXlOYW1lPSJNYXJyaWVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjIiIGNvZGVTeXN0ZW1OYW1lPSJNYXJpdGFsU3RhdHVzIiAvPg0KICAgICAgICA8cmFjZUNvZGUgY29kZT0iMjEwNi0zIiBkaXNwbGF5TmFtZT0iV2hpdGUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjM4IiBjb2RlU3lzdGVtTmFtZT0iQ0RDIFJhY2UgYW5kIEV0aG5pY2l0eSIgLz4NCiAgICAgICAgPGV0aG5pY0dyb3VwQ29kZSBjb2RlPSIyMTM1LTIiIGRpc3BsYXlOYW1lPSJIaXNwYW5pYyBvciBMYXRpbm8iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjM4IiBjb2RlU3lzdGVtTmFtZT0iQ0RDIFJhY2UgYW5kIEV0aG5pY2l0eSIgLz4NCiAgICAgICAgPGxhbmd1YWdlQ29tbXVuaWNhdGlvbj4NCiAgICAgICAgICA8bGFuZ3VhZ2VDb2RlIGNvZGU9ImVuZyIgLz4NCiAgICAgICAgICA8cHJlZmVyZW5jZUluZCB2YWx1ZT0idHJ1ZSIgLz4NCiAgICAgICAgPC9sYW5ndWFnZUNvbW11bmljYXRpb24+DQogICAgICA8L3BhdGllbnQ+DQogICAgICA8cHJvdmlkZXJPcmdhbml6YXRpb24+DQogICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgPGFkZHI+DQogICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgIDwvYWRkcj4NCiAgICAgIDwvcHJvdmlkZXJPcmdhbml6YXRpb24+DQogICAgPC9wYXRpZW50Um9sZT4NCiAgPC9yZWNvcmRUYXJnZXQ+DQogIDxhdXRob3I+DQogICAgPHRpbWUgdmFsdWU9IjIwMTMwOTI1MTMyNzM2LTA0MDAiIC8+DQogICAgPGFzc2lnbmVkQXV0aG9yPg0KICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMDU4NzAwIiAvPg0KICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICA8YWRkcj4NCiAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgIDwvYWRkcj4NCiAgICAgIDx0ZWxlY29tIHVzZT0iV1AiIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiAvPg0KICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICA8bmFtZT4NCiAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgIDwvbmFtZT4NCiAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgPC9hdXRob3I+DQogIDxjdXN0b2RpYW4+DQogICAgPGFzc2lnbmVkQ3VzdG9kaWFuPg0KICAgICAgPHJlcHJlc2VudGVkQ3VzdG9kaWFuT3JnYW5pemF0aW9uPg0KICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgPGFkZHI+DQogICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgIDwvYWRkcj4NCiAgICAgIDwvcmVwcmVzZW50ZWRDdXN0b2RpYW5Pcmdhbml6YXRpb24+DQogICAgPC9hc3NpZ25lZEN1c3RvZGlhbj4NCiAgPC9jdXN0b2RpYW4+DQogIDxpbmZvcm1hdGlvblJlY2lwaWVudD4NCiAgICA8aW50ZW5kZWRSZWNpcGllbnQ+DQogICAgICA8aW5mb3JtYXRpb25SZWNpcGllbnQ+DQogICAgICAgIDxuYW1lPlNoYXJvbiBBLiBDYXJsc29uPC9uYW1lPg0KICAgICAgPC9pbmZvcm1hdGlvblJlY2lwaWVudD4NCiAgICA8L2ludGVuZGVkUmVjaXBpZW50Pg0KICA8L2luZm9ybWF0aW9uUmVjaXBpZW50Pg0KICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IklORCI+DQogICAgPHRpbWUgdmFsdWU9IjIwMTMwOTI1MTMyNzM2LTA0MDAiIC8+DQogICAgPGFzc29jaWF0ZWRFbnRpdHkgY2xhc3NDb2RlPSJFQ09OIj4NCiAgICAgIDxpZCByb290PSI0YmM4MGUxZC00OWVkLTQyNjUtYjg5Zi01NTkyYTk0YmJlNjciIC8+DQogICAgICA8Y29kZSBjb2RlPSJIVVNCIiBkaXNwbGF5TmFtZT0iSHVzYmFuZCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgIDxhZGRyPg0KICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQ1NiBXZXN0IFBhbG08L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+QXB0LiAjMzQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICA8Y2l0eT5Vbmtub3duPC9jaXR5Pg0KICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgPHBvc3RhbENvZGU+MTIzPC9wb3N0YWxDb2RlPg0KICAgICAgPC9hZGRyPg0KICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTMyOTMiIHVzZT0iSFAiIC8+DQogICAgICA8YXNzb2NpYXRlZFBlcnNvbj4NCiAgICAgICAgPG5hbWU+DQogICAgICAgICAgPGdpdmVuPlN0ZXZlbjwvZ2l2ZW4+DQogICAgICAgICAgPGdpdmVuPlc8L2dpdmVuPg0KICAgICAgICAgIDxmYW1pbHk+Q2FybHNvbjwvZmFtaWx5Pg0KICAgICAgICA8L25hbWU+DQogICAgICA8L2Fzc29jaWF0ZWRQZXJzb24+DQogICAgPC9hc3NvY2lhdGVkRW50aXR5Pg0KICA8L3BhcnRpY2lwYW50Pg0KICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IklORCI+DQogICAgPHRpbWUgdmFsdWU9IjIwMTMwOTI1MTMyNzM2LTA0MDAiIC8+DQogICAgPGFzc29jaWF0ZWRFbnRpdHkgY2xhc3NDb2RlPSJOT0siPg0KICAgICAgPGlkIHJvb3Q9IjViZjlkOGE0LTUzMjctNDUwYi1iMWJkLTg2ZDc2MWJlMjU1MSIgLz4NCiAgICAgIDxjb2RlIGNvZGU9IkhVU0IiIGRpc3BsYXlOYW1lPSJIdXNiYW5kIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMSIgY29kZVN5c3RlbU5hbWU9IlJvbGVDb2RlIiAvPg0KICAgICAgPGFkZHI+DQogICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zNDU2IFdlc3QgUGFsbTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5BcHQuICMzNDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgIDxjaXR5PlVua25vd248L2NpdHk+DQogICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICA8cG9zdGFsQ29kZT4xMjM8L3Bvc3RhbENvZGU+DQogICAgICA8L2FkZHI+DQogICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMzI5MyIgdXNlPSJIUCIgLz4NCiAgICAgIDxhc3NvY2lhdGVkUGVyc29uPg0KICAgICAgICA8bmFtZT4NCiAgICAgICAgICA8Z2l2ZW4+U3RldmVuPC9naXZlbj4NCiAgICAgICAgICA8Z2l2ZW4+VzwvZ2l2ZW4+DQogICAgICAgICAgPGZhbWlseT5DYXJsc29uPC9mYW1pbHk+DQogICAgICAgIDwvbmFtZT4NCiAgICAgIDwvYXNzb2NpYXRlZFBlcnNvbj4NCiAgICA8L2Fzc29jaWF0ZWRFbnRpdHk+DQogIDwvcGFydGljaXBhbnQ+DQogIDxkb2N1bWVudGF0aW9uT2Y+DQogICAgPHNlcnZpY2VFdmVudCBjbGFzc0NvZGU9IlBDUFIiPg0KICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgIDxsb3cgdmFsdWU9IjIwMDEwMTAxIiAvPg0KICAgICAgICA8aGlnaCB2YWx1ZT0iMjAxMzA5MjUiIC8+DQogICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICA8dGltZT4NCiAgICAgICAgICA8bG93IG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICA8L3RpbWU+DQogICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42IiBleHRlbnNpb249IjIyNTAwNzQxMDAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5QSSIgLz4NCiAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgPGdpdmVuPldlbmR5PC9naXZlbj4NCiAgICAgICAgICAgICAgPGdpdmVuPk08L2dpdmVuPg0KICAgICAgICAgICAgICA8ZmFtaWx5PlBlcmV6PC9mYW1pbHk+DQogICAgICAgICAgICAgIDxzdWZmaXg+UEE8L3N1ZmZpeD4NCiAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgLz4NCiAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgPHRpbWU+DQogICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgPC90aW1lPg0KICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMTU1MjAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgIDxnaXZlbj5HYXJ5PC9naXZlbj4NCiAgICAgICAgICAgICAgPGZhbWlseT5NYWRkZXI8L2ZhbWlseT4NCiAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiAvPg0KICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgPC9wZXJmb3JtZXI+DQogICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICA8dGltZT4NCiAgICAgICAgICA8bG93IG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICA8L3RpbWU+DQogICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42IiBleHRlbnNpb249IjkwODAwODkwMDAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5QSSIgLz4NCiAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xMTU1NCBXZWVkc2lkZSBMYW5lPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgIDxnaXZlbj5KYW1lczwvZ2l2ZW4+DQogICAgICAgICAgICAgIDxnaXZlbj5UPC9naXZlbj4NCiAgICAgICAgICAgICAgPGZhbWlseT5Nb25yb2U8L2ZhbWlseT4NCiAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiAvPg0KICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgPC9wZXJmb3JtZXI+DQogICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICA8dGltZT4NCiAgICAgICAgICA8bG93IG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICA8L3RpbWU+DQogICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42IiBleHRlbnNpb249Ijk5OTAwNTQ4MDAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5QSSIgLz4NCiAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NjIwIFBhbG1ldHRvIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgIDxnaXZlbj5EZXBhazwvZ2l2ZW4+DQogICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgPGZhbWlseT5TaGFoPC9mYW1pbHk+DQogICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgLz4NCiAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgPHRpbWU+DQogICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgPC90aW1lPg0KICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMDU4NzAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiAvPg0KICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgPC9wZXJmb3JtZXI+DQogICAgPC9zZXJ2aWNlRXZlbnQ+DQogIDwvZG9jdW1lbnRhdGlvbk9mPg0KICA8YXV0aG9yaXphdGlvbiB0eXBlQ29kZT0iQVVUSCI+DQogICAgPGNvbnNlbnQgY2xhc3NDb2RlPSJDT05TIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgIDxpZCByb290PSJlZGI0YTZmMS0xODgzLTQ4MzItOTIxNC1iODllMTFjZDhjMmYiIC8+DQogICAgICA8Y29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4yMTM2Ny4xMDAuMSIgY29kZVN5c3RlbU5hbWU9IkNvbm5lY3RhdGhvbiBDb25maWRlbnRpYWxpdHkgQ29kZXMiIC8+DQogICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgPC9jb25zZW50Pg0KICA8L2F1dGhvcml6YXRpb24+DQogIDxjb21wb25lbnQ+DQogICAgPHN0cnVjdHVyZWRCb2R5Pg0KICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHNlY3Rpb24+DQogICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi41LjEiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWN0aXZlIFByb2JsZW1zIFNlY3Rpb24gKEVudHJpZXMgUmVxdWlyZWQpIiAvPg0KICAgICAgICAgIDxpZCByb290PSJlYWE0MTk0MS0wMmJiLTQxMmMtOGYyMC1lMGRjOGJiN2I1YzMiIC8+DQogICAgICAgICAgPGNvZGUgY29kZT0iMTE0NTAtNCIgZGlzcGxheU5hbWU9IlByb2JsZW0gbGlzdCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgPHRpdGxlPlByb2JsZW1zPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGg+QWxsIFZpc2l0czwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+RWZmZWN0aXZlIERhdGUocyk8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlByb3ZpZGVyPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5Db25kaXRpb24gU3RhdHVzPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJwcm9ibGVtRGVzY3JpcHRpb25pZDAiPkNPTU4gTUlHUk5FIFdPIE5UUkMgTUdSTjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTIvMDIvMjAwMjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGF2aWQgRSBGb3JkIE1EPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icHJvYmxlbVN0YXR1c0lkMCI+QWN0aXZlPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InByb2JsZW1Db21tZW50c0lkMCIgY29sc3Bhbj0iMyI+Tm90ZTogVW5jaGFuZ2VkIC0gTmVnYXRpdmUgTVJJIG9mIHNrdWxsIG9uIDIvMTAvMjAwMzwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC43IiBleHRlbnNpb249IjM2ODUiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkNPTkMiIGRpc3BsYXlOYW1lPSJDb25jZXJuIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjYiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDbGFzcyIgLz4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iYWN0aXZlIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDAyMTIwMiIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTk5MDA1ODcwMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTlBJIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMjIzNTJhMjEtYTI3Zi00YTJmLWE3OWYtZTYyMDVjZmVmMzg5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNwcm9ibGVtRGVzY3JpcHRpb25pZDAiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwMjEyMDIiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNwcm9ibGVtRGVzY3JpcHRpb25pZDAiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMzQ2LjEwIiBkaXNwbGF5TmFtZT0iQ09NTiBNSUdSTkUgV08gTlRSQyBNR1JOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRDlDTSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImY5ZmNhNDhiLWY3NTMtNDk5Ni04ZTgyLWUyZjE5Njk5MWNmZiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBTdGF0dXMgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzM5OTktNCIgZGlzcGxheU5hbWU9IlN0YXR1cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjcHJvYmxlbVN0YXR1c0lkMCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjY0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIENvbW1lbnQgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI0ODc2Ny04IiBkaXNwbGF5TmFtZT0iQW5ub3RhdGlvbiBjb21tZW50IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjcHJvYmxlbUNvbW1lbnRzSWQwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgPC9zZWN0aW9uPg0KICAgICAgPC9jb21wb25lbnQ+DQogICAgICA8Y29tcG9uZW50Pg0KICAgICAgICA8c2VjdGlvbj4NCiAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjEwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFBsYW4gb2YgQ2FyZSBTZWN0aW9uIiAvPg0KICAgICAgICAgIDxpZCByb290PSIxOTQ4MzFhZi04YzI1LTQwZGYtYWQzNC1kM2M1ZWI0YzA4ZDUiIC8+DQogICAgICAgICAgPGNvZGUgY29kZT0iMTg3NzYtNSIgZGlzcGxheU5hbWU9IlRSRUFUTUVOVCBQTEFOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+UGxhbiBvZiBDYXJlPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGg+UGVuZGluZyBUZXN0czwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+T3JkZXI8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPkRpYWdub3NpczwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+UmVzdWx0cyBEdWU8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPk9yZGVyaW5nIFByb3ZpZGVyPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJwZW5kaW5nVGVzdFR5cGVEZXNjcmlwdGlvbklEMCI+TGFiPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icGVuZGluZ1Rlc3REZXNjcmlwdGlvbklEMCI+TWV0YWJvbGljIFBhbmVsPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icGVuZGluZ1Rlc3REaWFnbm9zaXNJRDAiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wMS8wMy8wODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+SmFtZXMgVCBNb25yb2UgTUQ8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aD5GdXR1cmUgVGVzdHM8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPk9yZGVyPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5EaWFnbm9zaXM8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlJlc3VsdHMgRHVlPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5PcmRlcmluZyBQcm92aWRlcjwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90aGVhZD4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iZnV0dXJlVGVzdFR5cGVEZXNjcmlwdGlvbklEMCI+UmFkaW9sb2d5IC0gQ1QgU2NhbnM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJmdXR1cmVUZXN0RGVzY3JpcHRpb25JRDAiPkNUIFNDQU4gSEVBRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9ImZ1dHVyZVRlc3REaWFnbm9zaXNJRDAiPkNPTU4gTUlHUk5FIFdPIE5UUkMgTUdSTjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMjIvMDg8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRlcGFrIEUgU2hhaCBNRDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgIDxlbnRyeT4NCiAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40MSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQbGFuIG9mIENhcmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMjEiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3BlbmRpbmdUZXN0RGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAxMzA5MjUiIC8+DQogICAgICAgICAgICAgICAgPGhpZ2ggdmFsdWU9IjIwMDgwMTAzIiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5MDgwMDg5MDAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjExNTU0IFdlZWRzaWRlIExhbmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkphbWVzPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+VDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Nb25yb2U8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeT4NCiAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40MSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQbGFuIG9mIENhcmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMjEiIGV4dGVuc2lvbj0iNDYiIC8+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNmdXR1cmVUZXN0RGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAxMzA5MjUiIC8+DQogICAgICAgICAgICAgICAgPGhpZ2ggdmFsdWU9IjIwMDgwMTIyIiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMDU0ODAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg2MjAgUGFsbWV0dG8gRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRlcGFrPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5TaGFoPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiIgbmVnYXRpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9ibGVtIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImQ4YWMyODhiLWFiYTAtNGU5Ni1iMzk4LTllNmQyNDA5NzhjZiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjI4MjI5MTAwOSIgZGlzcGxheU5hbWU9IkRpYWdub3NpcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZnV0dXJlVGVzdERlc2NyaXB0aW9uSUQwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjM0Ni4xMCIgZGlzcGxheU5hbWU9IkNPTU4gTUlHUk5FIFdPIE5UUkMgTUdSTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0Q5Q00iIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2Z1dHVyZVRlc3REZXNjcmlwdGlvbklEMCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L3ZhbHVlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICA8L3NlY3Rpb24+DQogICAgICA8L2NvbXBvbmVudD4NCiAgICAgIDxjb21wb25lbnQ+DQogICAgICAgIDxzZWN0aW9uPg0KICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuNDUiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIFNlY3Rpb24iIC8+DQogICAgICAgICAgPGlkIHJvb3Q9IjVkNzVmMTEwLTQ0ZmYtNGNhYi1hNzJiLTJjOGY2MjU0OGUxYiIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSI2OTczMC0wIiBkaXNwbGF5TmFtZT0iSU5TVFJVQ1RJT05TIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+SW5zdHJ1Y3Rpb25zPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDxjb250ZW50Pk5vIEluc3RydWN0aW9ucyBSZWNvcmRlZDwvY29udGVudD4NCiAgICAgICAgICA8L3RleHQ+DQogICAgICAgIDwvc2VjdGlvbj4NCiAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHNlY3Rpb24+DQogICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4xLjEiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbnMgU2VjdGlvbiAoRW50cmllcyBSZXF1aXJlZCkiIC8+DQogICAgICAgICAgPGlkIHJvb3Q9IjVhMjg4NDg2LTJjYTQtNGRmMi04OTg4LWJhYjJmNjJlYjNlZCIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSIxMDE2MC0wIiBkaXNwbGF5TmFtZT0iSElTVE9SWSBPRiBNRURJQ0FUSU9OIFVTRSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgPHRpdGxlPk1lZGljYXRpb25zPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSIgY2VsbHNwYWNpbmc9IjAiPg0KICAgICAgICAgICAgICA8dGhlYWQ+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJsZWZ0Ij5DdXJyZW50IE1lZGljYXRpb25zIChjb250aW51ZSBhcyBwcmVzY3JpYmVkKTwvdGg+DQogICAgICAgICAgICAgICAgICA8dGggLz4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0icmlnaHQiPg0KICAgICAgICAgICAgICAgICAgPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjMiIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSI0MCUiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EZXNjcmlwdGlvbklEMCI+MTIgSG91ciBEZWNvbmdlc3RhbnQgMTIwIE1HIENQMTI8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAyLzIzLzIwMTA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRpYWdub3Npczo8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGlhZ25vc2lzLTAiPk1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiIElEPSJtZWRpY2F0aW9uRGlyZWN0aW9ucy0wIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSIgY2VsbHNwYWNpbmc9IjAiPg0KICAgICAgICAgICAgICA8dGhlYWQ+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJsZWZ0Ij5QYXN0IE1lZGljYXRpb25zIG9uIGZpbGU8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoIC8+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249InJpZ2h0Ij4NCiAgICAgICAgICAgICAgICAgIDwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90aGVhZD4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIzIiAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjFweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iNDAlIiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDEiPjJuZCBTa2luIEJsaXN0ZXIgS2l0IE1JU0M8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAxLzEzLzIwMTI8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRpYWdub3Npczo8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGlhZ25vc2lzLTEiPk1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiIElEPSJtZWRpY2F0aW9uRGlyZWN0aW9ucy0xIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjQwJSIgLz4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQyIj4xMiBIb3VyIE5hc2FsIFJlbGllZiBTcHJheSAwLjA1ICUgU09MTjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMTMvMjAxMjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgICAgPHRkIHJvd3NwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIiBJRD0ibWVkaWNhdGlvbkRpcmVjdGlvbnMtMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSI0MCUiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EZXNjcmlwdGlvbklEMyI+UHJhc2FkIFNjaGVkdWxlIDQgRHJ1ZyBUQkRSPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wMi8xNi8yMDEwPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5EaWFnbm9zaXM6PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRpYWdub3Npcy0zIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiIElEPSJtZWRpY2F0aW9uRGlyZWN0aW9ucy0zIj4yIHR3aWNlIGEgZGF5ICwgVGVzdCBjYXNlIDEgZGlyZWN0aW9ucyBnbyBoZXJlLiBBbGwgaW5mb3JtYXRpb24gZXhpc3RpbmcuPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjFweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iNDAlIiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDQiPjUtSHlkcm94eS1MLVRyeXB0b3BoYW4gUE9XRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTEvMDIvMjAwOTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtNCI+TWlncmFpbmUgSGVhZGFjaGUsIFVuc3BlY2lmaWVkPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZCByb3dzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiIgSUQ9Im1lZGljYXRpb25EaXJlY3Rpb25zLTQiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjFweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iNDAlIiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDUiPkdpbmtvIEJpbG9iYSAxIEdyYW0gQ1BTUDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDgvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtNSI+TWlncmFpbmUgSGVhZGFjaGUsIFVuc3BlY2lmaWVkPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZCByb3dzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiIgSUQ9Im1lZGljYXRpb25EaXJlY3Rpb25zLTUiPlRha2Ugb25lIGNhcHN1bGUgd2l0aCB0ZWEgdHdpY2UgYSBkYXkgYnkgbW91dGguPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjFweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iNDAlIiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDYiPlByb21ldGhhemluZSBIQ2wgMjUgTUcgVEFCUzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDgvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtNiI+TkFVU0VBIEFMT05FPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZCByb3dzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiIgSUQ9Im1lZGljYXRpb25EaXJlY3Rpb25zLTYiPlRha2Ugb25lIHRhYmxldCBieSBtb3V0aCBldmVyeSBmb3VyIHRvIHNpeCBob3VycyBhcyBuZWVkZWQuPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjFweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iNDAlIiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDciPk5hcHJveGVuIFNvZGl1bSA1NTAgTUcgVEFCUzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDgvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtNyI+Q09NTiBNSUdSTkUgV08gTlRSQyBNR1JOPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZCByb3dzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiIgSUQ9Im1lZGljYXRpb25EaXJlY3Rpb25zLTciPlRha2Ugb25lIHRhYmxldCBieSBtb3V0aCBldmVyeSBzaXggaG91cnMgYXMgbmVlZGVkLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjQwJSIgLz4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQ4Ij5JbWl0cmV4IDI1IE1HIFRBQlM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAxLzAzLzIwMDggLSAwMS8wOC8yMDA4PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5EaWFnbm9zaXM6PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRpYWdub3Npcy04Ij5NaWdyYWluZSBIZWFkYWNoZSwgVW5zcGVjaWZpZWQ8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgICAgPHRkIHJvd3NwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIiBJRD0ibWVkaWNhdGlvbkRpcmVjdGlvbnMtOCI+VGFrZSAxIHRhYmxldCBieSBtb3V0aCBhdCBvbnNldCBvZiBzeW1wdG9tcy4gIERvIG5vdCBleGNlZWQgMiB0YWJsZXRzIGRhaWx5LjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjQwJSIgLz4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQ5Ij5WYWxpdW0gNSBNRyBUQUJTPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4xMS8wMi8yMDA3IC0gMDIvMDEvMjAwNzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtOSI+TWlncmFpbmUgSGVhZGFjaGUsIFVuc3BlY2lmaWVkPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZCByb3dzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiIgSUQ9Im1lZGljYXRpb25EaXJlY3Rpb25zLTkiPlRha2UgMSB0YWJsZXQgYXQgYmVkdGltZS48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSI0MCUiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EZXNjcmlwdGlvbklEMTAiPkltaXRyZXggMjUgTUcgVEFCUzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTEvMDIvMjAwNzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtMTAiPk1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiIElEPSJtZWRpY2F0aW9uRGlyZWN0aW9ucy0xMCI+VGFrZSAxIHRhYmxldCBhcyBuZWVkZWQgZnJvciBtaWdyYWluZSBoZWFkYWNoZS48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSI0MCUiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EZXNjcmlwdGlvbklEMTEiPkltaXRyZXggMjUgTUcgVEFCUzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTAvMDUvMjAwNyAtIDExLzAyLzIwMDc8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRpYWdub3Npczo8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGlhZ25vc2lzLTExIj5NaWdyYWluZSBIZWFkYWNoZSwgVW5zcGVjaWZpZWQ8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgICAgPHRkIHJvd3NwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIiBJRD0ibWVkaWNhdGlvbkRpcmVjdGlvbnMtMTEiPlRha2UgMSB0YWJsZXQgYXMgZGlyZWN0ZWQgYXQgb25zZXQgb2YgaGVhZGFjaGUuPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjFweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iNDAlIiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDEyIj5TdHJlc3MgRm9ybXVsYSBQbHVzIElyb24gVEFCUzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTAvMDUvMjAwNzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtMTIiPk1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiIElEPSJtZWRpY2F0aW9uRGlyZWN0aW9ucy0xMiI+VGFrZSAxIHRhYmxldCBvbmNlIGEgZGF5IGJ5IG1vdXRoLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjQwJSIgLz4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxMyI+SW1pdHJleCAyNSBNRyBUQUJTPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wOS8wMy8yMDA3IC0gMTAvMDUvMjAwNzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGlhZ25vc2lzOjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EaWFnbm9zaXMtMTMiPk1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj0iMiI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiIElEPSJtZWRpY2F0aW9uRGlyZWN0aW9ucy0xMyI+VGFrZSAxIHRhYmxldCBhcyBkaXJlY3RlZCBhdCBvbnNldCBvZiBoZWFkYWNoZS48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSI0MCUiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9Im1lZGljYXRpb25EZXNjcmlwdGlvbklEMTQiPkZpb3JpbmFsL0NvZGVpbmUgIzMgNTAtMzI1LTQwLTMwIE1HIENBUFM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjA5LzAzLzIwMDcgLSAxMC8wNS8yMDA3PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5EaWFnbm9zaXM6PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRpYWdub3Npcy0xNCI+TWlncmFpbmUgSGVhZGFjaGUsIFVuc3BlY2lmaWVkPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZCByb3dzcGFuPSIyIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iMiIgSUQ9Im1lZGljYXRpb25EaXJlY3Rpb25zLTE0Ij4xLTIgdGFicyBldmVyeSA2IGhvdXJzIGZvciBwYWluLCBub3QgdG8gZXhjZWVkIDYgdGFibGV0cyBhIGRheTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjQwJSIgLz4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxNSI+VmFsaXVtIDUgTUcgVEFCUzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDIvMDEvMjAwNyAtIDAxLzA4LzIwMDg8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRpYWdub3Npczo8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJtZWRpY2F0aW9uRGlhZ25vc2lzLTE1Ij5NaWdyYWluZSBIZWFkYWNoZSwgVW5zcGVjaWZpZWQ8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgICAgPHRkIHJvd3NwYW49IjIiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSIyIiBJRD0ibWVkaWNhdGlvbkRpcmVjdGlvbnMtMTUiPlRha2UgMSB0YWJsZXQgYXQgYmVkdGltZS48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMTA5MCIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+MiBQdWZmcyBxNmhycyBwcm48L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgb3BlcmF0b3I9IkEiIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMTAwMjIzIiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9Ijg2Njc5IiBkaXNwbGF5TmFtZT0iMTIgSG91ciBEZWNvbmdlc3RhbnQgMTIwIE1HIENQMTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4xMiBIb3VyIERlY29uZ2VzdGFudDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICA8L2NvbnN1bWFibGU+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjYzZWVmMTE0LTY0NzgtNDExNS05YWM1LWU0M2MzNWZhMjU1OCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjczNjM5MDAwIiBkaXNwbGF5TmFtZT0iUHJlc2NyaXB0aW9uIERydWciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBJbnN0cnVjdGlvbnMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQSU5TVFJVQ1QiIGRpc3BsYXlOYW1lPSJJbnN0cnVjdGlvbnMiIGNvZGVTeXN0ZW09IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjIiIGNvZGVTeXN0ZW1OYW1lPSJJSEVBY3RDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlyZWN0aW9ucy0wIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDNmOGJlOGEtMzU5Mi00ODE4LWFhNjItMjE3ZGU1OWVjMGE5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMTAwMjIzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjQ1ZTIyNWFlLTU3NzAtNDM5Mi04YmEzLWUwMDI2ZWYzYWQ4YyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0wIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDEwMDIyMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIzNDYuOSIgZGlzcGxheU5hbWU9Ik1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0Q5Q00iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMGQ4YTU1YmUtMTEzZC00Yjk0LWJmN2YtZTk2ZDYwMjA2MmY5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gU3VwcGx5IE9yZGVyIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMTA5MCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8cmVwZWF0TnVtYmVyIHZhbHVlPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHF1YW50aXR5IHZhbHVlPSI0NSIgdW5pdD0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEMCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI4NjY3OSIgZGlzcGxheU5hbWU9IjEyIEhvdXIgRGVjb25nZXN0YW50IDEyMCBNRyBDUDEyIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4xMiBIb3VyIERlY29uZ2VzdGFudDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8YXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAxMDAyMjMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBEaXNwZW5zZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI1MjFjNmI4Yi01ODU0LTRhZTEtYTFhOC1mM2QwNmQ3ZDRlNjUiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IlVua25vd24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iODY2NzkiIGRpc3BsYXlOYW1lPSIxMiBIb3VyIERlY29uZ2VzdGFudCAxMjAgTUcgQ1AxMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+MTIgSG91ciBEZWNvbmdlc3RhbnQ8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0NjkgQWx0YW1vbnRlIFNwcmluZ3MgVGVycmFjZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MjQ1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy43OSIgZXh0ZW5zaW9uPSIzMTIzNDYyIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOQ1BEUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkFsdGFtb250ZSBNZWRpY2FsIENlbnRlciBQaGFybWFjeTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NzgyIiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zNDY5IEFsdGFtb250ZSBTcHJpbmdzIFRlcnJhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MjQ1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSI5ODAxMjkxIiAvPg0KICAgICAgICAgICAgICA8dGV4dD40IG9uY2UgYSBkYXk8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgb3BlcmF0b3I9IkEiIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMTIwMTEzIiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjEzODc5NiIgZGlzcGxheU5hbWU9IjJuZCBTa2luIEJsaXN0ZXIgS2l0IE1JU0MiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4ybmQgU2tpbiBCbGlzdGVyIEtpdDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICA8L2NvbnN1bWFibGU+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjZlNTNhN2EyLTg2ZGItNDEzMy04NGVlLWMwOWViMGM1NmNlYiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjczNjM5MDAwIiBkaXNwbGF5TmFtZT0iUHJlc2NyaXB0aW9uIERydWciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBJbnN0cnVjdGlvbnMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQSU5TVFJVQ1QiIGRpc3BsYXlOYW1lPSJJbnN0cnVjdGlvbnMiIGNvZGVTeXN0ZW09IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjIiIGNvZGVTeXN0ZW1OYW1lPSJJSEVBY3RDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlyZWN0aW9ucy0xIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNTY3ZmQ2ZDAtOWQ0MS00ZTNjLTlhYTYtNjkwNTVhMDhhZGRlIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMTIwMTEzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjAyMDI3ZDI3LTEzN2YtNDgzZC04NTk3LTJlMWNkNjZhOGViMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0xIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDEyMDExMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIzNDYuOSIgZGlzcGxheU5hbWU9Ik1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0Q5Q00iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMmMxMWMwZGQtYjBlMS00NGIwLTk2OTUtMDMwOTcyOGNhZjVmIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gU3VwcGx5IE9yZGVyIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMTI5MSIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8cmVwZWF0TnVtYmVyIHZhbHVlPSIzIiAvPg0KICAgICAgICAgICAgICAgICAgPHF1YW50aXR5IHZhbHVlPSIyIiB1bml0PSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVua25vd24iIGRpc3BsYXlOYW1lPSJVbmtub3duIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjEzODc5NiIgZGlzcGxheU5hbWU9IjJuZCBTa2luIEJsaXN0ZXIgS2l0IE1JU0MiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPjJuZCBTa2luIEJsaXN0ZXIgS2l0PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDwvcHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDxhdXRob3I+DQogICAgICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDEyMDExMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4zIiBleHRlbnNpb249IjM2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPC9hdXRob3I+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIERpc3BlbnNlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjQwMjdlNGFkLWVjNDctNDg4My05MTVkLWEwMDBlNDVhMTEwNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIxMzg3OTYiIGRpc3BsYXlOYW1lPSIybmQgU2tpbiBCbGlzdGVyIEtpdCBNSVNDIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4ybmQgU2tpbiBCbGlzdGVyIEtpdDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iNzcwMDA2MyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTIzIFRlc3QgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PlR3aW5zYnVyZzwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5PSDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT40NDA4NzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iNzcwMDA2MyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5TZWxmVGVzdCBORVdSWCBpbiBSRUZSRVEgb3V0PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS04ODgtNTU1LTEyMTIiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjEyMyBUZXN0IFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PlR3aW5zYnVyZzwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPk9IPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+NDQwODc8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJNZWRpY2F0aW9uIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMzOTk5LTQiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjczNDI1MDA3IiBkaXNwbGF5TmFtZT0iTm8gTG9uZ2VyIEFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSI5ODAxMjkwIiAvPg0KICAgICAgICAgICAgICA8dGV4dD4zIHRocmVlIHRpbWVzIGEgZGF5PC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDEyMDExMyIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IlVua25vd24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIzMTkzNSIgZGlzcGxheU5hbWU9IjEyIEhvdXIgTmFzYWwgUmVsaWVmIFNwcmF5IDAuMDUgJSBTT0xOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+MTIgSG91ciBOYXNhbCBSZWxpZWYgU3ByYXk8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgPC9jb25zdW1hYmxlPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIzMzE2ZjdhMy01OTA2LTRjZjMtOTE5OS1hMjdkOTUwZDVhY2YiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYzOTAwMCIgZGlzcGxheU5hbWU9IlByZXNjcmlwdGlvbiBEcnVnIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUElOU1RSVUNUIiBkaXNwbGF5TmFtZT0iSW5zdHJ1Y3Rpb25zIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4yIiBjb2RlU3lzdGVtTmFtZT0iSUhFQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpcmVjdGlvbnMtMiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gU3VwcGx5IE9yZGVyIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMTI5MCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8cmVwZWF0TnVtYmVyIHZhbHVlPSIzIiAvPg0KICAgICAgICAgICAgICAgICAgPHF1YW50aXR5IHZhbHVlPSIyIiB1bml0PSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVua25vd24iIGRpc3BsYXlOYW1lPSJVbmtub3duIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjMxOTM1IiBkaXNwbGF5TmFtZT0iMTIgSG91ciBOYXNhbCBSZWxpZWYgU3ByYXkgMC4wNSAlIFNPTE4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPjEyIEhvdXIgTmFzYWwgUmVsaWVmIFNwcmF5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDwvcHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDxhdXRob3I+DQogICAgICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDEyMDExMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4zIiBleHRlbnNpb249IjM2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPC9hdXRob3I+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIERpc3BlbnNlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImU2ODc0Nzk3LWNiMmUtNDk3Mi05ZGIzLTQxODA5YzMwYjVkNyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIzMTkzNSIgZGlzcGxheU5hbWU9IjEyIEhvdXIgTmFzYWwgUmVsaWVmIFNwcmF5IDAuMDUgJSBTT0xOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4xMiBIb3VyIE5hc2FsIFJlbGllZiBTcHJheTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iNzcwMDA2MyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTIzIFRlc3QgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PlR3aW5zYnVyZzwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5PSDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT40NDA4NzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iNzcwMDA2MyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5TZWxmVGVzdCBORVdSWCBpbiBSRUZSRVEgb3V0PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS04ODgtNTU1LTEyMTIiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjEyMyBUZXN0IFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PlR3aW5zYnVyZzwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPk9IPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+NDQwODc8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJNZWRpY2F0aW9uIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMzOTk5LTQiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjczNDI1MDA3IiBkaXNwbGF5TmFtZT0iTm8gTG9uZ2VyIEFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSI5ODAxMDc4IiAvPg0KICAgICAgICAgICAgICA8dGV4dD4yIHR3aWNlIGEgZGF5PC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDEwMDIxNiIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IlVua25vd24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQzIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSJNMDAwMDYiIGRpc3BsYXlOYW1lPSJQcmFzYWQgU2NoZWR1bGUgNCBEcnVnIFRCRFIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5QcmFzYWQgU2NoZWR1bGUgNCBEcnVnPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgIDwvY29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iODIyOTc5NGMtMWM1Ni00YmJhLWI1NGMtYzZhMzM2YTAyMGFiIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBJbnN0cnVjdGlvbnMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQSU5TVFJVQ1QiIGRpc3BsYXlOYW1lPSJJbnN0cnVjdGlvbnMiIGNvZGVTeXN0ZW09IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjIiIGNvZGVTeXN0ZW1OYW1lPSJJSEVBY3RDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlyZWN0aW9ucy0zIiAvPjIgdHdpY2UgYSBkYXkgLCBUZXN0IGNhc2UgMSBkaXJlY3Rpb25zIGdvIGhlcmUuIEFsbCBpbmZvcm1hdGlvbiBleGlzdGluZy48L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIFN1cHBseSBPcmRlciIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249Ijk4MDEwNzgiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHJlcGVhdE51bWJlciB2YWx1ZT0iMyIgLz4NCiAgICAgICAgICAgICAgICAgIDxxdWFudGl0eSB2YWx1ZT0iMSIgdW5pdD0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSJNMDAwMDYiIGRpc3BsYXlOYW1lPSJQcmFzYWQgU2NoZWR1bGUgNCBEcnVnIFRCRFIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPlByYXNhZCBTY2hlZHVsZSA0IERydWc8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPGF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMTAwMjE2IiAvPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICA8L2F1dGhvcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE4IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gRGlzcGVuc2UiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iN2MxNjA3MDMtZmY0MS00YjIxLTg5NzEtZGU1NGJiYTk5Y2IzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVua25vd24iIGRpc3BsYXlOYW1lPSJVbmtub3duIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQzIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9Ik0wMDAwNiIgZGlzcGxheU5hbWU9IlByYXNhZCBTY2hlZHVsZSA0IERydWcgVEJEUiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+UHJhc2FkIFNjaGVkdWxlIDQgRHJ1ZzwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iMzEyMzQ2MCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTE5MSBNYWluIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTQ8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+U3Vuc2hpbmUgRHJ1Z3M8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNjU2NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTE5MSBNYWluIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1NDwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik1lZGljYXRpb24gc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzM5OTktNCIgZGlzcGxheU5hbWU9IlN0YXR1cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNzM0MjUwMDciIGRpc3BsYXlOYW1lPSJObyBMb25nZXIgQWN0aXZlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0UiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgIDwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE2IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249Ijk4MDEwMjYiIC8+DQogICAgICAgICAgICAgIDx0ZXh0PnR3aWNlIGEgZGF5PC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA5MTEwMiIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IlVua25vd24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQ0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI1NTM4NSIgZGlzcGxheU5hbWU9IjUtSHlkcm94eS1MLVRyeXB0b3BoYW4gUE9XRCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPjUtSHlkcm94eS1MLVRyeXB0b3BoYW48L25hbWU+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgPC9jb25zdW1hYmxlPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI5NWU2Njg3ZC03Nzk3LTRlNmEtOTkxYS02YWU3Yzk3NjI1MzYiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYzOTAwMCIgZGlzcGxheU5hbWU9IlByZXNjcmlwdGlvbiBEcnVnIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUElOU1RSVUNUIiBkaXNwbGF5TmFtZT0iSW5zdHJ1Y3Rpb25zIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4yIiBjb2RlU3lzdGVtTmFtZT0iSUhFQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpcmVjdGlvbnMtNCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSU09OIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9ibGVtIENvbmNlcm4gQWN0IiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjU0MGFlYjAzLTI2ZmUtNDFlZS1iOThlLTAzMmZlYmQ1NTJiZiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkNPTkMiIGRpc3BsYXlOYW1lPSJDb25jZXJuIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjYiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDbGFzcyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA5MTEwMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9ibGVtIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI2YjI5ZWY1My01M2ViLTQ4Y2UtODY0My0xN2JiYmU3Y2RjYzgiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaWFnbm9zaXMtNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwOTExMDIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy00IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMzQ2LjkiIGRpc3BsYXlOYW1lPSJNaWdyYWluZSBIZWFkYWNoZSwgVW5zcGVjaWZpZWQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNEOUNNIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImIwN2Q4N2EyLTljOGUtNDc1MS04M2IzLWU1ZmMwNjhmNzg1NiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIFN1cHBseSBPcmRlciIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249Ijk4MDEwMjYiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHJlcGVhdE51bWJlciB2YWx1ZT0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxxdWFudGl0eSB2YWx1ZT0iMTAiIHVuaXQ9IjEiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IlVua25vd24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNTUzODUiIGRpc3BsYXlOYW1lPSI1LUh5ZHJveHktTC1UcnlwdG9waGFuIFBPV0QiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPjUtSHlkcm94eS1MLVRyeXB0b3BoYW48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPGF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDkxMTAyIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICA8L2F1dGhvcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI3MzQyNTAwNyIgZGlzcGxheU5hbWU9Ik5vIExvbmdlciBBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDU4NiIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+dHdpY2UgYSBkYXk8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgb3BlcmF0b3I9IkEiIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9Ik0wMDAwMSIgZGlzcGxheU5hbWU9IkdpbmtvIEJpbG9iYSAxIEdyYW0gQ1BTUCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkdpbmtvIEJpbG9iYTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICA8L2NvbnN1bWFibGU+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIwNTQ4NTExLTZlMTUtNDQzNy1hMjAwLTkyMjczMDYyOWIxNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjczNjM5MDAwIiBkaXNwbGF5TmFtZT0iUHJlc2NyaXB0aW9uIERydWciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBJbnN0cnVjdGlvbnMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQSU5TVFJVQ1QiIGRpc3BsYXlOYW1lPSJJbnN0cnVjdGlvbnMiIGNvZGVTeXN0ZW09IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjIiIGNvZGVTeXN0ZW1OYW1lPSJJSEVBY3RDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlyZWN0aW9ucy01IiAvPlRha2Ugb25lIGNhcHN1bGUgd2l0aCB0ZWEgdHdpY2UgYSBkYXkgYnkgbW91dGguPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMjk4NTNmMDAtNzM4Ni00YzdjLTk3MjUtMDBhYzk2MTcwMWYzIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImUxZTc4YjIyLTcxZTYtNDIzYy1hNzNhLWYwOWVmYjVjYzJhNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy01IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA4MDEwOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIzNDYuOSIgZGlzcGxheU5hbWU9Ik1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0Q5Q00iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDc4MmUxOGQtODhmNy00MDFmLTlmMmMtMjBlMDJjYzNlNTE3IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gU3VwcGx5IE9yZGVyIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDU4NiIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8cmVwZWF0TnVtYmVyIHZhbHVlPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHF1YW50aXR5IHZhbHVlPSI2MCIgdW5pdD0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVbmtub3duIiBkaXNwbGF5TmFtZT0iVW5rbm93biIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklENSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSJNMDAwMDEiIGRpc3BsYXlOYW1lPSJHaW5rbyBCaWxvYmEgMSBHcmFtIENQU1AiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkdpbmtvIEJpbG9iYTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8YXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAwODAxMDgiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBEaXNwZW5zZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0ZjQ5OWExMC1mOWY2LTQzZDAtODY3Mi0xNDBiYzk5ZDg4OTciIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IlVua25vd24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iTTAwMDAxIiBkaXNwbGF5TmFtZT0iR2lua28gQmlsb2JhIDEgR3JhbSBDUFNQIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5HaW5rbyBCaWxvYmE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy43OSIgZXh0ZW5zaW9uPSIzMTIzNDU5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOQ1BEUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkV2YW4ncyBEaXNjb3VudCBEcnVnczwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMTE4IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zMTcwIE5XIFZpcmdpbmlhIFBsYWNlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI3MzQyNTAwNyIgZGlzcGxheU5hbWU9Ik5vIExvbmdlciBBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDU4NSIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+MSBldmVyeSA0IHRvIDYgaG91cnM8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgb3BlcmF0b3I9IkEiIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI5OTI0NDciIGRpc3BsYXlOYW1lPSJQcm9tZXRoYXppbmUgSHlkcm9jaGxvcmlkZSAyNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjE3ODkxIiBkaXNwbGF5TmFtZT0iUHJvbWV0aGF6aW5lIEhDbCAyNSBNRyBUQUJTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+UHJvbWV0aGF6aW5lIEhDbDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICA8L2NvbnN1bWFibGU+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImVjMTdlM2VkLWVmNWMtNDRjMC1hODhmLTg1ODVmZmY0MjI3NyIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjczNjM5MDAwIiBkaXNwbGF5TmFtZT0iUHJlc2NyaXB0aW9uIERydWciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBJbnN0cnVjdGlvbnMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQSU5TVFJVQ1QiIGRpc3BsYXlOYW1lPSJJbnN0cnVjdGlvbnMiIGNvZGVTeXN0ZW09IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjIiIGNvZGVTeXN0ZW1OYW1lPSJJSEVBY3RDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlyZWN0aW9ucy02IiAvPlRha2Ugb25lIHRhYmxldCBieSBtb3V0aCBldmVyeSBmb3VyIHRvIHNpeCBob3VycyBhcyBuZWVkZWQuPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOTExOWMwNjQtMjdjOS00NjM2LTk2ZjctZTUxZmM0NDRkYTdhIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImNkYjljNzY3LThlNzQtNDUwNS1iMTIzLWU0MjE0NjM2ODI2YiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy02IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA4MDEwOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI3ODcuMDIiIGRpc3BsYXlOYW1lPSJOQVVTRUEgQUxPTkUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNEOUNNIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImU4MGQ1NGYxLTdiMzEtNDQ3Zi1iMmU5LWNjYWUxYmE1NTA5MSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIFN1cHBseSBPcmRlciIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249Ijk4MDA1ODUiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHJlcGVhdE51bWJlciB2YWx1ZT0iMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxxdWFudGl0eSB2YWx1ZT0iMTIwIiB1bml0PSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijk5MjQ0NyIgZGlzcGxheU5hbWU9IlByb21ldGhhemluZSBIeWRyb2NobG9yaWRlIDI1IE1HIE9yYWwgVGFibGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQ2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjE3ODkxIiBkaXNwbGF5TmFtZT0iUHJvbWV0aGF6aW5lIEhDbCAyNSBNRyBUQUJTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5Qcm9tZXRoYXppbmUgSENsPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDwvcHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDxhdXRob3I+DQogICAgICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDA4MDEwOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4zIiBleHRlbnNpb249IjM2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPC9hdXRob3I+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIERpc3BlbnNlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjU2YjAwMGUzLTQwZGQtNGZjNy04MWU5LTM1ZThhYmU0ZGE4NyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI5OTI0NDciIGRpc3BsYXlOYW1lPSJQcm9tZXRoYXppbmUgSHlkcm9jaGxvcmlkZSAyNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklENiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIxNzg5MSIgZGlzcGxheU5hbWU9IlByb21ldGhhemluZSBIQ2wgMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+UHJvbWV0aGF6aW5lIEhDbDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iMzEyMzQ1OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzE3MCBOVyBWaXJnaW5pYSBQbGFjZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+RXZhbidzIERpc2NvdW50IERydWdzPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAxMTgiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJNZWRpY2F0aW9uIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMzOTk5LTQiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjczNDI1MDA3IiBkaXNwbGF5TmFtZT0iTm8gTG9uZ2VyIEFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSI5ODAwNTg0IiAvPg0KICAgICAgICAgICAgICA8dGV4dD4xIGV2ZXJ5IDYgaG91cnM8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgb3BlcmF0b3I9IkEiIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI4NDk0MzEiIGRpc3BsYXlOYW1lPSJOYXByb3hlbiBzb2RpdW0gNTUwIE1HIE9yYWwgVGFibGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklENyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMTQ0MzQiIGRpc3BsYXlOYW1lPSJOYXByb3hlbiBTb2RpdW0gNTUwIE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5OYXByb3hlbiBTb2RpdW08L25hbWU+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgPC9jb25zdW1hYmxlPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmYjAxZTNiNy0zNzlmLTQwNDItODVhYi05Zjg1YzU1MTE0ZmQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYzOTAwMCIgZGlzcGxheU5hbWU9IlByZXNjcmlwdGlvbiBEcnVnIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUElOU1RSVUNUIiBkaXNwbGF5TmFtZT0iSW5zdHJ1Y3Rpb25zIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4yIiBjb2RlU3lzdGVtTmFtZT0iSUhFQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpcmVjdGlvbnMtNyIgLz5UYWtlIG9uZSB0YWJsZXQgYnkgbW91dGggZXZlcnkgc2l4IGhvdXJzIGFzIG5lZWRlZC48L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBDb25jZXJuIEFjdCIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI4ZjViMWU2MC0wZTIyLTQ1ODktOWQ4MC04N2M5MmVlMmNiYzkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJDT05DIiBkaXNwbGF5TmFtZT0iQ29uY2VybiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS42IiBjb2RlU3lzdGVtTmFtZT0iSEw3QWN0Q2xhc3MiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwODAxMDgiIC8+DQogICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiIgbmVnYXRpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNzAwYjQ2YWUtYWE0Zi00Yjg5LTgyNTktZmYzNjIyMzE3YWRmIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTciIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaWFnbm9zaXMtNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjM0Ni4xMCIgZGlzcGxheU5hbWU9IkNPTU4gTUlHUk5FIFdPIE5UUkMgTUdSTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0Q5Q00iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYzRkODEwNzYtZjgzNy00Y2ZmLWIxMzYtZDMwMzM0NDZhZTJlIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gU3VwcGx5IE9yZGVyIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDU4NCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8cmVwZWF0TnVtYmVyIHZhbHVlPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgPHF1YW50aXR5IHZhbHVlPSIxMjAiIHVuaXQ9IjEiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iODQ5NDMxIiBkaXNwbGF5TmFtZT0iTmFwcm94ZW4gc29kaXVtIDU1MCBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklENyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIxNDQzNCIgZGlzcGxheU5hbWU9Ik5hcHJveGVuIFNvZGl1bSA1NTAgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TmFwcm94ZW4gU29kaXVtPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDwvcHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDxhdXRob3I+DQogICAgICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDA4MDEwOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4zIiBleHRlbnNpb249IjM2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPC9hdXRob3I+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIERpc3BlbnNlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjgyMTQxNzcyLTNjMDQtNDc0YS05NjYxLWFmNzNkZmVjZTY2YyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI4NDk0MzEiIGRpc3BsYXlOYW1lPSJOYXByb3hlbiBzb2RpdW0gNTUwIE1HIE9yYWwgVGFibGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQ3IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjE0NDM0IiBkaXNwbGF5TmFtZT0iTmFwcm94ZW4gU29kaXVtIDU1MCBNRyBUQUJTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5OYXByb3hlbiBTb2RpdW08L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy43OSIgZXh0ZW5zaW9uPSIzMTIzNDU5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOQ1BEUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkV2YW4ncyBEaXNjb3VudCBEcnVnczwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMTE4IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zMTcwIE5XIFZpcmdpbmlhIFBsYWNlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI3MzQyNTAwNyIgZGlzcGxheU5hbWU9Ik5vIExvbmdlciBBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDU3OSIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+YXMgbmVlZGVkPC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA4MDEwMyIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwODAxMDgiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE1MjIzIiBkaXNwbGF5TmFtZT0iU3VtYXRyaXB0YW4gMjUgTUcgT3JhbCBUYWJsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQ4IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTc3MTMiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MDk2NCIgZGlzcGxheU5hbWU9IkltaXRyZXggMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkltaXRyZXg8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgPC9jb25zdW1hYmxlPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI4NGIxZjcwOS1kNWY5LTQyZjgtYTE2YS0zMDEwYzE0NTMxYmQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYzOTAwMCIgZGlzcGxheU5hbWU9IlByZXNjcmlwdGlvbiBEcnVnIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUElOU1RSVUNUIiBkaXNwbGF5TmFtZT0iSW5zdHJ1Y3Rpb25zIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4yIiBjb2RlU3lzdGVtTmFtZT0iSUhFQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpcmVjdGlvbnMtOCIgLz5UYWtlIDEgdGFibGV0IGJ5IG1vdXRoIGF0IG9uc2V0IG9mIHN5bXB0b21zLiAgRG8gbm90IGV4Y2VlZCAyIHRhYmxldHMgZGFpbHkuPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZjlkNmFlZDUtY2FiZS00NmU2LTg1MjMtY2Q3ZjE1NzlkMjcxIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTAzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwODAxMDgiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImIzMGI1YWVlLTRkODktNDQ0Yy1iMTBjLTg1ZTE4NmQwZWNlNSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy04IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA4MDEwMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTgiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIzNDYuOSIgZGlzcGxheU5hbWU9Ik1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0Q5Q00iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDE2ZjYxZjItZTE4MS00OWM0LWJiYzEtMWI1ZWI1MTVkY2IxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gU3VwcGx5IE9yZGVyIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDU3OSIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8cmVwZWF0TnVtYmVyIHZhbHVlPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHF1YW50aXR5IHZhbHVlPSIzMCIgdW5pdD0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMTUyMjMiIGRpc3BsYXlOYW1lPSJTdW1hdHJpcHRhbiAyNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTc3MTMiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNDA5NjQiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IDI1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkltaXRyZXg8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPGF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDgwMTAzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iNDIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTE1NTQgV2VlZHNpZGUgTGFuZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+SmFtZXM8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+VDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPC9hdXRob3I+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIERpc3BlbnNlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImMzM2NhYjA3LTAzMTktNGE0Yi1hMDJhLWYwNzBjNDkyMDcwZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMTUyMjMiIGRpc3BsYXlOYW1lPSJTdW1hdHJpcHRhbiAyNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTc3MTMiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNDA5NjQiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IDI1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkltaXRyZXg8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy43OSIgZXh0ZW5zaW9uPSIzMTIzNDU5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOQ1BEUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkV2YW4ncyBEaXNjb3VudCBEcnVnczwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMTE4IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zMTcwIE5XIFZpcmdpbmlhIFBsYWNlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI3MzQyNTAwNyIgZGlzcGxheU5hbWU9Ik5vIExvbmdlciBBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iMTA5MzkwNSIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+MSBldmVyeSBldmVuaW5nPC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTEwMiIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwNzAyMDEiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTk3NTkxIiBkaXNwbGF5TmFtZT0iRGlhemVwYW0gNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjIwMjQ3MiIgZGlzcGxheU5hbWU9IlZhbGl1bSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMjMwNjAiIGRpc3BsYXlOYW1lPSJWYWxpdW0gNSBNRyBUQUJTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+VmFsaXVtPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgIDwvY29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMjU5OWQ2YTctNmE1NS00OWQxLTg4MTEtZGVlODcwMzM5Njg3IiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzM2MzkwMDAiIGRpc3BsYXlOYW1lPSJQcmVzY3JpcHRpb24gRHJ1ZyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEluc3RydWN0aW9ucyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlBJTlNUUlVDVCIgZGlzcGxheU5hbWU9Ikluc3RydWN0aW9ucyIgY29kZVN5c3RlbT0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMiIgY29kZVN5c3RlbU5hbWU9IklIRUFjdENvZGUiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaXJlY3Rpb25zLTkiIC8+VGFrZSAxIHRhYmxldCBhdCBiZWR0aW1lLjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSU09OIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9ibGVtIENvbmNlcm4gQWN0IiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjZjYzE1MDVlLTNjNjQtNDcxOC1hMzc2LWI2MjU0MDZiYmY3OSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkNPTkMiIGRpc3BsYXlOYW1lPSJDb25jZXJuIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjYiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDbGFzcyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTEwMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggdmFsdWU9IjIwMDcwMjAxIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9ibGVtIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIwYzVhYTUwOS1lZWQ5LTQyNDMtYWU3Ni1iNmEzN2I3MmNhNjQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaWFnbm9zaXMtOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzExMDIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy05IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMzQ2LjkiIGRpc3BsYXlOYW1lPSJNaWdyYWluZSBIZWFkYWNoZSwgVW5zcGVjaWZpZWQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNEOUNNIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjI3NTNiM2NlLWFmY2ItNGYyMS05MTFmLTk3OWRkZTQ5MTliYiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIFN1cHBseSBPcmRlciIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249IjEwOTM5MDUiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHJlcGVhdE51bWJlciB2YWx1ZT0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxxdWFudGl0eSB2YWx1ZT0iMzAiIHVuaXQ9IjEiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTk3NTkxIiBkaXNwbGF5TmFtZT0iRGlhemVwYW0gNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMDI0NzIiIGRpc3BsYXlOYW1lPSJWYWxpdW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMzA2MCIgZGlzcGxheU5hbWU9IlZhbGl1bSA1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPlZhbGl1bTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8YXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAwNzExMDIiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBEaXNwZW5zZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyMjQ2NDE5YS00NDM5LTQyOTQtYTNhZS1jYzg5ZTRhODk1OTIiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTk3NTkxIiBkaXNwbGF5TmFtZT0iRGlhemVwYW0gNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMDI0NzIiIGRpc3BsYXlOYW1lPSJWYWxpdW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMzA2MCIgZGlzcGxheU5hbWU9IlZhbGl1bSA1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPlZhbGl1bTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iMzEyMzQ1OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzE3MCBOVyBWaXJnaW5pYSBQbGFjZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+RXZhbidzIERpc2NvdW50IERydWdzPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAxMTgiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJNZWRpY2F0aW9uIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMzOTk5LTQiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjczNDI1MDA3IiBkaXNwbGF5TmFtZT0iTm8gTG9uZ2VyIEFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSIxMDkzOTA0IiAvPg0KICAgICAgICAgICAgICA8dGV4dD5hcyBuZWVkZWQ8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgb3BlcmF0b3I9IkEiIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcxMTAyIiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMTUyMjMiIGRpc3BsYXlOYW1lPSJTdW1hdHJpcHRhbiAyNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDEwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTc3MTMiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MDk2NCIgZGlzcGxheU5hbWU9IkltaXRyZXggMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkltaXRyZXg8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgPC9jb25zdW1hYmxlPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI5MTZkYTRhMy1jZGRkLTQxMDItYjViMS05ZGFjYTVjMmVkYzQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYzOTAwMCIgZGlzcGxheU5hbWU9IlByZXNjcmlwdGlvbiBEcnVnIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUElOU1RSVUNUIiBkaXNwbGF5TmFtZT0iSW5zdHJ1Y3Rpb25zIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4yIiBjb2RlU3lzdGVtTmFtZT0iSUhFQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpcmVjdGlvbnMtMTAiIC8+VGFrZSAxIHRhYmxldCBhcyBuZWVkZWQgZnJvciBtaWdyYWluZSBoZWFkYWNoZS48L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBDb25jZXJuIEFjdCIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJlMTY2ZmU5Ni01YTI0LTRkYjYtODI3Yi05Y2QxZGVhYWM4YTUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJDT05DIiBkaXNwbGF5TmFtZT0iQ29uY2VybiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS42IiBjb2RlU3lzdGVtTmFtZT0iSEw3QWN0Q2xhc3MiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzExMDIiIC8+DQogICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiIgbmVnYXRpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDZlYzBkNDAtYWQxYy00NDZkLWFlOWItZTI4MzgxMTQxNzM4IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTEwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTEwMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTEwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMzQ2LjkiIGRpc3BsYXlOYW1lPSJNaWdyYWluZSBIZWFkYWNoZSwgVW5zcGVjaWZpZWQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNEOUNNIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjNjYjZhMzlhLWViNTUtNGJlOS04MTU3LTgwZDBmYjU0NjE5NSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIFN1cHBseSBPcmRlciIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249IjEwOTM5MDQiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHJlcGVhdE51bWJlciB2YWx1ZT0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxxdWFudGl0eSB2YWx1ZT0iMTUiIHVuaXQ9IjEiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE1MjIzIiBkaXNwbGF5TmFtZT0iU3VtYXRyaXB0YW4gMjUgTUcgT3JhbCBUYWJsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDEwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjIxNzcxMyIgZGlzcGxheU5hbWU9IkltaXRyZXgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MDk2NCIgZGlzcGxheU5hbWU9IkltaXRyZXggMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+SW1pdHJleDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8YXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAwNzExMDIiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBEaXNwZW5zZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI1YTEzZGRiMC0yM2I1LTRmZTktYWFhMC0xNzU0NTk3NDk1OGQiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE1MjIzIiBkaXNwbGF5TmFtZT0iU3VtYXRyaXB0YW4gMjUgTUcgT3JhbCBUYWJsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDEwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjIxNzcxMyIgZGlzcGxheU5hbWU9IkltaXRyZXgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MDk2NCIgZGlzcGxheU5hbWU9IkltaXRyZXggMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+SW1pdHJleDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iMzEyMzQ1OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzE3MCBOVyBWaXJnaW5pYSBQbGFjZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+RXZhbidzIERpc2NvdW50IERydWdzPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAxMTgiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJNZWRpY2F0aW9uIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMzOTk5LTQiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjczNDI1MDA3IiBkaXNwbGF5TmFtZT0iTm8gTG9uZ2VyIEFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSIxMDkzOTAyIiAvPg0KICAgICAgICAgICAgICA8dGV4dD5hcyBuZWVkZWQ8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgb3BlcmF0b3I9IkEiIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcxMDA1IiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIHZhbHVlPSIyMDA3MTEwMiIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMTUyMjMiIGRpc3BsYXlOYW1lPSJTdW1hdHJpcHRhbiAyNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTc3MTMiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MDk2NCIgZGlzcGxheU5hbWU9IkltaXRyZXggMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkltaXRyZXg8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgPC9jb25zdW1hYmxlPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmM2M5ODRiNS1jNjZkLTQ4MmMtYjhlOC1lMjIwODJjMGZmODAiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYzOTAwMCIgZGlzcGxheU5hbWU9IlByZXNjcmlwdGlvbiBEcnVnIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUElOU1RSVUNUIiBkaXNwbGF5TmFtZT0iSW5zdHJ1Y3Rpb25zIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4yIiBjb2RlU3lzdGVtTmFtZT0iSUhFQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpcmVjdGlvbnMtMTEiIC8+VGFrZSAxIHRhYmxldCBhcyBkaXJlY3RlZCBhdCBvbnNldCBvZiBoZWFkYWNoZS48L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBDb25jZXJuIEFjdCIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJhM2ZmMjg5MC0wZGFmLTQ1NTMtOTM5MC05M2E4ODk2MWJkNGEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJDT05DIiBkaXNwbGF5TmFtZT0iQ29uY2VybiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS42IiBjb2RlU3lzdGVtTmFtZT0iSEw3QWN0Q2xhc3MiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzEwMDUiIC8+DQogICAgICAgICAgICAgICAgICAgIDxoaWdoIHZhbHVlPSIyMDA3MTEwMiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiIgbmVnYXRpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNTY0NDM3YjAtODkyYy00NTA5LWI2YTYtMmMwMThjNzQxNjg2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTAwNSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NjA3MDA2IiBkaXNwbGF5TmFtZT0iUHJvYmxlbSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlhZ25vc2lzLTExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMzQ2LjkiIGRpc3BsYXlOYW1lPSJNaWdyYWluZSBIZWFkYWNoZSwgVW5zcGVjaWZpZWQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNEOUNNIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImEwZGI1OGIyLTAyMTgtNDEzZC1iZjBiLWNlMDVhY2RhMWQ1NSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIFN1cHBseSBPcmRlciIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249IjEwOTM5MDIiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHJlcGVhdE51bWJlciB2YWx1ZT0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxxdWFudGl0eSB2YWx1ZT0iMTUiIHVuaXQ9IjEiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE1MjIzIiBkaXNwbGF5TmFtZT0iU3VtYXRyaXB0YW4gMjUgTUcgT3JhbCBUYWJsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjIxNzcxMyIgZGlzcGxheU5hbWU9IkltaXRyZXgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MDk2NCIgZGlzcGxheU5hbWU9IkltaXRyZXggMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+SW1pdHJleDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8YXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAwNzEwMDUiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBEaXNwZW5zZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyM2NjZjgxZS1iODZkLTQxNDEtOGZhZC0xZDdlYjRhNmRhNmIiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE1MjIzIiBkaXNwbGF5TmFtZT0iU3VtYXRyaXB0YW4gMjUgTUcgT3JhbCBUYWJsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjIxNzcxMyIgZGlzcGxheU5hbWU9IkltaXRyZXgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MDk2NCIgZGlzcGxheU5hbWU9IkltaXRyZXggMjUgTUcgVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+SW1pdHJleDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iMzEyMzQ1OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzE3MCBOVyBWaXJnaW5pYSBQbGFjZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+RXZhbidzIERpc2NvdW50IERydWdzPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAxMTgiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTU8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJNZWRpY2F0aW9uIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMzOTk5LTQiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjczNDI1MDA3IiBkaXNwbGF5TmFtZT0iTm8gTG9uZ2VyIEFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICA8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSIxMDkzOTAzIiAvPg0KICAgICAgICAgICAgICA8dGV4dD5vbmNlIGEgZGF5PC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTAwNSIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IlVua25vd24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNDU0ODAiIGRpc3BsYXlOYW1lPSJTdHJlc3MgRm9ybXVsYSBQbHVzIElyb24gVEFCUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPlN0cmVzcyBGb3JtdWxhIFBsdXMgSXJvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICA8L2NvbnN1bWFibGU+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijc5Mzc2OTM3LTUyNDAtNGVhMi1hNzNhLTFlZmExMzczNjkxOCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjczNjM5MDAwIiBkaXNwbGF5TmFtZT0iUHJlc2NyaXB0aW9uIERydWciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBJbnN0cnVjdGlvbnMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQSU5TVFJVQ1QiIGRpc3BsYXlOYW1lPSJJbnN0cnVjdGlvbnMiIGNvZGVTeXN0ZW09IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjIiIGNvZGVTeXN0ZW1OYW1lPSJJSEVBY3RDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGlyZWN0aW9ucy0xMiIgLz5UYWtlIDEgdGFibGV0IG9uY2UgYSBkYXkgYnkgbW91dGguPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMTkxN2ZhMWMtZjM4NS00ZjUzLWE4NWEtMDIyMGZjY2JlOTdhIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcxMDA1IiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjcwZmYyMmM1LWEzZTYtNGQ5Yi04MWU3LTRmYTRmZDI3N2Y1OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0xMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzEwMDUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0xMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjM0Ni45IiBkaXNwbGF5TmFtZT0iTWlncmFpbmUgSGVhZGFjaGUsIFVuc3BlY2lmaWVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRDlDTSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIxNWE0YjVjYi1hYzBlLTRhOTEtOGEyMS0yNGRlNjhmOWJiMjkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBTdXBwbHkgT3JkZXIiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSIxMDkzOTAzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgIDxyZXBlYXROdW1iZXIgdmFsdWU9IjMiIC8+DQogICAgICAgICAgICAgICAgICA8cXVhbnRpdHkgdmFsdWU9IjMwIiB1bml0PSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVua25vd24iIGRpc3BsYXlOYW1lPSJVbmtub3duIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0NTQ4MCIgZGlzcGxheU5hbWU9IlN0cmVzcyBGb3JtdWxhIFBsdXMgSXJvbiBUQUJTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5TdHJlc3MgRm9ybXVsYSBQbHVzIElyb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPGF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcxMDA1IiAvPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICA8L2F1dGhvcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI3MzQyNTAwNyIgZGlzcGxheU5hbWU9Ik5vIExvbmdlciBBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iMTA5MzkwMSIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+YXMgbmVlZGVkPC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MDkwMyIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwNzEwMDUiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE1MjIzIiBkaXNwbGF5TmFtZT0iU3VtYXRyaXB0YW4gMjUgTUcgT3JhbCBUYWJsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMjE3NzEzIiBkaXNwbGF5TmFtZT0iSW1pdHJleCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNDA5NjQiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IDI1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5JbWl0cmV4PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgIDwvY29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZmJhMzUyNmMtZWJhNS00NTFkLTgyMDAtZTIzZmVlZTExODgxIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzM2MzkwMDAiIGRpc3BsYXlOYW1lPSJQcmVzY3JpcHRpb24gRHJ1ZyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEluc3RydWN0aW9ucyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlBJTlNUUlVDVCIgZGlzcGxheU5hbWU9Ikluc3RydWN0aW9ucyIgY29kZVN5c3RlbT0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMiIgY29kZVN5c3RlbU5hbWU9IklIRUFjdENvZGUiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaXJlY3Rpb25zLTEzIiAvPlRha2UgMSB0YWJsZXQgYXMgZGlyZWN0ZWQgYXQgb25zZXQgb2YgaGVhZGFjaGUuPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMDhhZWY0ZTctZDhkNS00Yzc4LTk2YzctNTYxN2MyOTY0MDM4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcwOTAzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwNzEwMDUiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImQ2MDVhODE3LThlODQtNDNhYS04NTJmLTY0OWQ4NGEyN2I4ZSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0xMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzA5MDMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0xMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjM0Ni45IiBkaXNwbGF5TmFtZT0iTWlncmFpbmUgSGVhZGFjaGUsIFVuc3BlY2lmaWVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRDlDTSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJiMjk2MGZkNy00OGFiLTQ2YzItODBlMi01N2FlOWVlYjBhMGUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBTdXBwbHkgT3JkZXIiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSIxMDkzOTAxIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgIDxyZXBlYXROdW1iZXIgdmFsdWU9IjEiIC8+DQogICAgICAgICAgICAgICAgICA8cXVhbnRpdHkgdmFsdWU9IjE1IiB1bml0PSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMxNTIyMyIgZGlzcGxheU5hbWU9IlN1bWF0cmlwdGFuIDI1IE1HIE9yYWwgVGFibGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTc3MTMiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNDA5NjQiIGRpc3BsYXlOYW1lPSJJbWl0cmV4IDI1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkltaXRyZXg8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPGF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcwOTAzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICA8L2F1dGhvcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI3MzQyNTAwNyIgZGlzcGxheU5hbWU9Ik5vIExvbmdlciBBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDcwNiIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+YXMgbmVlZGVkPC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIG9wZXJhdG9yPSJBIiB4c2k6dHlwZT0iSVZMX1RTIj4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MDkwMyIgLz4NCiAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwNzEwMDUiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzA5NDcxIiBkaXNwbGF5TmFtZT0iQXNwaXJpbiAzMjUgTUcgLyBidXRhbGJpdGFsIDUwIE1HIC8gQ2FmZmVpbmUgNDAgTUcgLyBDb2RlaW5lIDMwIE1HIE9yYWwgQ2Fwc3VsZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDE0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTcxMjciIGRpc3BsYXlOYW1lPSJGaW9yaW5hbCB3aXRoIENvZGVpbmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9Ijg0MzAiIGRpc3BsYXlOYW1lPSJGaW9yaW5hbC9Db2RlaW5lICMzIDUwLTMyNS00MC0zMCBNRyBDQVBTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+RmlvcmluYWwgd2l0aCBDb2RlaW5lPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgIDwvY29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZWM3MjY1M2EtZGFlOC00Y2UzLWIyMTYtOTI4MmUxNWE3MDczIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzM2MzkwMDAiIGRpc3BsYXlOYW1lPSJQcmVzY3JpcHRpb24gRHJ1ZyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEluc3RydWN0aW9ucyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlBJTlNUUlVDVCIgZGlzcGxheU5hbWU9Ikluc3RydWN0aW9ucyIgY29kZVN5c3RlbT0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMiIgY29kZVN5c3RlbU5hbWU9IklIRUFjdENvZGUiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaXJlY3Rpb25zLTE0IiAvPjEtMiB0YWJzIGV2ZXJ5IDYgaG91cnMgZm9yIHBhaW4sIG5vdCB0byBleGNlZWQgNiB0YWJsZXRzIGEgZGF5PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gQ29uY2VybiBBY3QiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iN2ZkYTlkYWQtMWM3MS00YjA0LWI4YjctYmNlZTc5MGFjMGI4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQ09OQyIgZGlzcGxheU5hbWU9IkNvbmNlcm4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNiIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENsYXNzIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcwOTAzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwNzEwMDUiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImExNWY4YjJiLTBkZDAtNGMzMS04MTg3LWRiZTZjMTg5ZWIwNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0xNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzA5MDMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpYWdub3Npcy0xNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjM0Ni45IiBkaXNwbGF5TmFtZT0iTWlncmFpbmUgSGVhZGFjaGUsIFVuc3BlY2lmaWVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRDlDTSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIzM2E4YzBmYS0xMjAyLTRmOTUtOGU4Ny1jNTk4ZTU2MDBhZWYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBTdXBwbHkgT3JkZXIiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuOCIgZXh0ZW5zaW9uPSI5ODAwNzA2IiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgIDxyZXBlYXROdW1iZXIgdmFsdWU9IjEiIC8+DQogICAgICAgICAgICAgICAgICA8cXVhbnRpdHkgdmFsdWU9IjMwIiB1bml0PSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMwOTQ3MSIgZGlzcGxheU5hbWU9IkFzcGlyaW4gMzI1IE1HIC8gYnV0YWxiaXRhbCA1MCBNRyAvIENhZmZlaW5lIDQwIE1HIC8gQ29kZWluZSAzMCBNRyBPcmFsIENhcHN1bGUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2F0aW9uRGVzY3JpcHRpb25JRDE0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjIxNzEyNyIgZGlzcGxheU5hbWU9IkZpb3JpbmFsIHdpdGggQ29kZWluZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9Ijg0MzAiIGRpc3BsYXlOYW1lPSJGaW9yaW5hbC9Db2RlaW5lICMzIDUwLTMyNS00MC0zMCBNRyBDQVBTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5GaW9yaW5hbCB3aXRoIENvZGVpbmU8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPGF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcwOTAzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iNDIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTE1NTQgV2VlZHNpZGUgTGFuZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+SmFtZXM8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+VDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPC9hdXRob3I+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQogICAgICAgICAgICAgICAgPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIERpc3BlbnNlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjdlOTRiMDEzLTc1ZDgtNDVjNC1iYjM1LTQ0YWJiMGMyZTU4YyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMDk0NzEiIGRpc3BsYXlOYW1lPSJBc3BpcmluIDMyNSBNRyAvIGJ1dGFsYml0YWwgNTAgTUcgLyBDYWZmZWluZSA0MCBNRyAvIENvZGVpbmUgMzAgTUcgT3JhbCBDYXBzdWxlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMTcxMjciIGRpc3BsYXlOYW1lPSJGaW9yaW5hbCB3aXRoIENvZGVpbmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI4NDMwIiBkaXNwbGF5TmFtZT0iRmlvcmluYWwvQ29kZWluZSAjMyA1MC0zMjUtNDAtMzAgTUcgQ0FQUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNTMiIGNvZGVTeXN0ZW1OYW1lPSJNZWRpU3BhbiBERElEIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+RmlvcmluYWwgd2l0aCBDb2RlaW5lPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDwvcHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy43OSIgZXh0ZW5zaW9uPSIzMTIzNDU5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOQ1BEUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zMTcwIE5XIFZpcmdpbmlhIFBsYWNlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1NTwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuNzkiIGV4dGVuc2lvbj0iMzEyMzQ1OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTkNQRFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5FdmFuJ3MgRGlzY291bnQgRHJ1Z3M8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDExOCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzE3MCBOVyBWaXJnaW5pYSBQbGFjZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1NTwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9zdXBwbHk+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik1lZGljYXRpb24gc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzM5OTktNCIgZGlzcGxheU5hbWU9IlN0YXR1cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNzM0MjUwMDciIGRpc3BsYXlOYW1lPSJObyBMb25nZXIgQWN0aXZlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0UiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgIDwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJJTlQiPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE2IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC44IiBleHRlbnNpb249Ijk4MDA4MTQiIC8+DQogICAgICAgICAgICAgIDx0ZXh0PjEgZXZlcnkgZXZlbmluZzwvdGV4dD4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSBvcGVyYXRvcj0iQSIgeHNpOnR5cGU9IklWTF9UUyI+DQogICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzAyMDEiIC8+DQogICAgICAgICAgICAgICAgPGhpZ2ggdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxjb25zdW1hYmxlPg0KICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZWRQcm9kdWN0IGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjE5NzU5MSIgZGlzcGxheU5hbWU9IkRpYXplcGFtIDUgTUcgT3JhbCBUYWJsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxNSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMjAyNDcyIiBkaXNwbGF5TmFtZT0iVmFsaXVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMzA2MCIgZGlzcGxheU5hbWU9IlZhbGl1bSA1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5WYWxpdW08L25hbWU+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgIDwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCiAgICAgICAgICAgICAgPC9jb25zdW1hYmxlPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI2ZjFkMmVkNC1lYTUwLTRlNmEtOTk5My0wODIxMjZlMDU0MjAiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYzOTAwMCIgZGlzcGxheU5hbWU9IlByZXNjcmlwdGlvbiBEcnVnIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iSU5UIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW5zdHJ1Y3Rpb25zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUElOU1RSVUNUIiBkaXNwbGF5TmFtZT0iSW5zdHJ1Y3Rpb25zIiBjb2RlU3lzdGVtPSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4yIiBjb2RlU3lzdGVtTmFtZT0iSUhFQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRpcmVjdGlvbnMtMTUiIC8+VGFrZSAxIHRhYmxldCBhdCBiZWR0aW1lLjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSU09OIj4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9ibGVtIENvbmNlcm4gQWN0IiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImFmMWIyNDEyLTVkNDQtNGI5YS04NTQ3LWFiYzY5ZWZiMTgzMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkNPTkMiIGRpc3BsYXlOYW1lPSJDb25jZXJuIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjYiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDbGFzcyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MDIwMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGhpZ2ggdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9ibGVtIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyYjRkMjVmYy1hZDZiLTQ4NzgtYWI0NC1hMjZiMzQ3NzRiMjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaWFnbm9zaXMtMTUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcwMjAxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EaWFnbm9zaXMtMTUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIzNDYuOSIgZGlzcGxheU5hbWU9Ik1pZ3JhaW5lIEhlYWRhY2hlLCBVbnNwZWNpZmllZCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0Q5Q00iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZjZkMmZlYjEtMmM0ZC00YWI2LThiNzAtMWE1MjI4MzBkOTJkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICA8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IklOVCI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gU3VwcGx5IE9yZGVyIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjgiIGV4dGVuc2lvbj0iOTgwMDgxNCIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8cmVwZWF0TnVtYmVyIHZhbHVlPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgPHF1YW50aXR5IHZhbHVlPSIzMCIgdW5pdD0iMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjMiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBJbmZvcm1hdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIxOTc1OTEiIGRpc3BsYXlOYW1lPSJEaWF6ZXBhbSA1IE1HIE9yYWwgVGFibGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhdGlvbkRlc2NyaXB0aW9uSUQxNSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMDI0NzIiIGRpc3BsYXlOYW1lPSJWYWxpdW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiIGNvZGVTeXN0ZW1OYW1lPSJSeE5vcm0iIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSIyMzA2MCIgZGlzcGxheU5hbWU9IlZhbGl1bSA1IE1HIFRBQlMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjUzIiBjb2RlU3lzdGVtTmFtZT0iTWVkaVNwYW4gRERJRCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPlZhbGl1bTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8L3Byb2R1Y3Q+DQogICAgICAgICAgICAgICAgICA8YXV0aG9yPg0KICAgICAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAwNzAyMDEiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICAgIDwvc3VwcGx5Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgIDxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBEaXNwZW5zZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJiMWQ1YmExZS03MjE0LTRkZmEtYjZlNy00ZmE2MTBmNjdkNzIiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8cHJvZHVjdD4NCiAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIzIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTk3NTkxIiBkaXNwbGF5TmFtZT0iRGlhemVwYW0gNSBNRyBPcmFsIFRhYmxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgY29kZVN5c3RlbU5hbWU9IlJ4Tm9ybSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25EZXNjcmlwdGlvbklEMTUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMjAyNDcyIiBkaXNwbGF5TmFtZT0iVmFsaXVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMjMwNjAiIGRpc3BsYXlOYW1lPSJWYWxpdW0gNSBNRyBUQUJTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5WYWxpdW08L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPC9wcm9kdWN0Pg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjc5IiBleHRlbnNpb249IjMxMjM0NTkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5DUERQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjMxNzAgTlcgVmlyZ2luaWEgUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy43OSIgZXh0ZW5zaW9uPSIzMTIzNDU5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOQ1BEUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkV2YW4ncyBEaXNjb3VudCBEcnVnczwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMTE4IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zMTcwIE5XIFZpcmdpbmlhIFBsYWNlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3N1cHBseT4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI3MzQyNTAwNyIgZGlzcGxheU5hbWU9Ik5vIExvbmdlciBBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICA8L3NlY3Rpb24+DQogICAgICA8L2NvbXBvbmVudD4NCiAgICAgIDxjb21wb25lbnQ+DQogICAgICAgIDxzZWN0aW9uPg0KICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMzgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbnMgQWRtaW5pc3RlcmVkIFNlY3Rpb24iIC8+DQogICAgICAgICAgPGlkIHJvb3Q9ImJiMTBjMjQ1LTY1NjItNGU3MC1hNTVlLWEwZGE0NWQ2OGMzYyIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSIyOTU0OS0zIiBkaXNwbGF5TmFtZT0iTUVESUNBVElPTlMgQURNSU5JU1RFUkVEIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+TWVkaWNhdGlvbnMgQWRtaW5pc3RlcmVkPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDxjb250ZW50IElEPSJtZWRpY2F0aW9uQWRtaW5pc3RlcmVkRGVzY3JpcHRpb25JRDAiPk5vIEFkbWluaXN0ZXJlZCBNZWRpY2F0aW9ucyBSZWNvcmRlZDwvY29udGVudD4NCiAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iSU5UIiBuZWdhdGlvbkluZD0idHJ1ZSI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgTWVkaWNhdGlvbiBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjQxMzAzYjViLTk1N2QtNDVkMS04NjhkLTYxODk2ODg5MjE4YSIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25BZG1pbmlzdGVyZWREZXNjcmlwdGlvbklEMCIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPg0KICAgICAgICAgICAgICAgIDxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8Y29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkUHJvZHVjdCBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yMyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBNZWRpY2F0aW9uIEluZm9ybWF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJOb25lIiBkaXNwbGF5TmFtZT0iTm8gTWVkaWNhdGlvbnMgQWRtaW5pc3RlcmVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI21lZGljYXRpb25BZG1pbmlzdGVyZWREZXNjcmlwdGlvbklEMCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgIDwvY29uc3VtYWJsZT4NCiAgICAgICAgICAgIDwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgPC9zZWN0aW9uPg0KICAgICAgPC9jb21wb25lbnQ+DQogICAgICA8Y29tcG9uZW50Pg0KICAgICAgICA8c2VjdGlvbj4NCiAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjQuMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWducyBTZWN0aW9uIChFbnRyaWVzIFJlcXVpcmVkKSIgLz4NCiAgICAgICAgICA8aWQgcm9vdD0iN2FlODVkMDgtZGQxNi00YWQ4LWI3NjEtOGIwMzlkNzQwMzY4IiAvPg0KICAgICAgICAgIDxjb2RlIGNvZGU9Ijg3MTYtMyIgZGlzcGxheU5hbWU9IlZJVEFMIFNJR05TIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+Vml0YWwgU2lnbnM8L3RpdGxlPg0KICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0iY2VudGVyIj5WaXRhbCBOYW1lPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD4xMS8wMi8yMDA3IDEwOjA3QTwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+MTAvMDUvMjAwNyAxMDowNkE8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPjA5LzAzLzIwMDcgMTA6MDVBPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZD5TeXN0b2xpYyBCUC1TaXR0aW5nIChtbUhnKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMCI+MTMzPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQ5Ij4xMzE8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJWaXRhbC1JRDE4Ij4xMzA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkPkRpYXN0b2xpYyBCUC1TaXR0aW5nIChtbUhnKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMSI+NzY8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJWaXRhbC1JRDEwIj43NTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMTkiPjc2PC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZD5QdWxzZSBSYXRlIChicG0pPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQyIj44NjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMTEiPjgyPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQyMCI+ODI8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkPlJlc3BpcmF0aW9uIFJhdGUgKGJyZWF0aHMvbWluKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMyI+Mjk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJWaXRhbC1JRDEyIj4zMDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMjEiPjMwPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZD5UZW1wLU9yYWwgKEYpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQ0Ij45OC42PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQxMyI+OTguNjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMjIiPjk4LjY8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkPkhlaWdodCAoaW4pPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQ1Ij42NjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMTQiPjY2PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQyMyI+NjY8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkPldlaWdodCAobGIpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQ2Ij4xNjA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJWaXRhbC1JRDE1Ij4xNjA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJWaXRhbC1JRDI0Ij4xNjY8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkPkJvZHkgTWFzcyBJbmRleCAoa2cvbTIpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQ3Ij4yNS44PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQxNiI+MjUuODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IlZpdGFsLUlEMjUiPjI2Ljg8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkPkJvZHkgU3VyZmFjZSBBcmVhIChtMik8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJWaXRhbC1JRDgiPjEuODI8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJWaXRhbC1JRDE3Ij4xLjgyPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iVml0YWwtSUQyNiI+MS44NTwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8b3JnYW5pemVyIGNsYXNzQ29kZT0iQ0xVU1RFUiIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbnMgT3JnYW5pemVyIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQiIGV4dGVuc2lvbj0iNDQiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ2NjgwMDA1IiBkaXNwbGF5TmFtZT0iVml0YWwgc2lnbnMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTAwNzAwLTA0MDAiIC8+DQogICAgICAgICAgICAgIDxhdXRob3IgdHlwZUNvZGU9IkFVVCI+DQogICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcxMTAyMTAwNzAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iNDQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+V2VuZHk8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5NPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PlBlcmV6PC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5QQTwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjOGU0ZjcxYy0zZWQxLTQ1YjktODdlOC1iNWViNzA2MDA1MWQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0NC0xOCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijg0ODAtNiIgZGlzcGxheU5hbWU9IkJsb29kIFByZXNzdXJlIFN5c3RvbGljIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTAwNzAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjEzMyIgdW5pdD0ibW1bSGddIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBjb2RlPSJTaXR0aW5nIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJiOTU2ZGEzOS04MjEyLTQ2ZTUtOThkMS1jYzhkZGE0YzE3NDEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDQtMTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI4NDYyLTQiIGRpc3BsYXlOYW1lPSJCbG9vZCBQcmVzc3VyZSBEaWFzdG9saWMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNWaXRhbC1JRDEiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxMDA3MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNzYiIHVuaXQ9Im1tW0hnXSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgY29kZT0iU2l0dGluZyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMzlmN2Q2MjUtNzU2MC00NzE0LWIzNDItZmUxMDI2OWUxOGMxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbiBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNC4xIiBleHRlbnNpb249IjQ0LTEwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iODg2Ny00IiBkaXNwbGF5TmFtZT0iSGVhcnQgUmF0ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjEwMDcwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI4NiIgdW5pdD0iL21pbiIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjZhZmRhMDYyLTgyMzUtNDljYy05YWJmLTBhYjcwYmFkM2NiYSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0NC01IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iOTI3OS0xIiBkaXNwbGF5TmFtZT0iUmVzcGlyYXRvcnkgUmF0ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjEwMDcwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyOSIgdW5pdD0iL21pbiIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImRjNmJjMjAzLWNhNzgtNDkwMi04MmVhLTIyNWFlZGVhZjBiNSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0NC0xNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjgzMTAtNSIgZGlzcGxheU5hbWU9IkJvZHkgVGVtcGVyYXR1cmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNWaXRhbC1JRDQiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxMDA3MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iOTguNiIgdW5pdD0iW2RlZ0ZdIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBjb2RlPSJPcmFsIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIxZGRjYTEzMi1kM2I0LTRiZTMtYmVmMC01MDlmN2M1ZThjMDUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDQtMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjgzMDItMiIgZGlzcGxheU5hbWU9IkhlaWdodCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlENSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjEwMDcwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI2NiIgdW5pdD0iW2luX3VzXSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImIyNTI5NGZiLWFiODQtNDE5MS1iMWY2LWY3NTliMTc4NTYyNSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0NC0xIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE0MS05IiBkaXNwbGF5TmFtZT0iV2VpZ2h0IE1lYXN1cmVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQ2IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTAwNzAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjE2MCIgdW5pdD0iW2xiX2F2XSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjFmYzVjMjhjLWE3OGMtNGU2Yy04OWI2LWE0MTUzNTE0ZGZlMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0NC04IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzkxNTYtNSIgZGlzcGxheU5hbWU9IkJNSSAoQm9keSBNYXNzIEluZGV4KSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlENyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjEwMDcwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyNS44IiB1bml0PSJrZy9tMiIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjI5OGJmMDY3LWVhOTQtNGEyOS05MjEyLTI4YzJmZGMxOTk4YSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0NC05IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE0MC0xIiBkaXNwbGF5TmFtZT0iQlNBIChCb2R5IFN1cmZhY2UgQXJlYSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNWaXRhbC1JRDgiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxMDA3MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMS44MiIgdW5pdD0ibTIiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmZTFkZDRmMS0wYTcxLTRjNjUtYTFjOS0xMzg4MTI4MGYyZmIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgIDwvb3JnYW5pemVyPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxvcmdhbml6ZXIgY2xhc3NDb2RlPSJDTFVTVEVSIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWducyBPcmdhbml6ZXIiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNCIgZXh0ZW5zaW9uPSI0MyIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNDY2ODAwMDUiIGRpc3BsYXlOYW1lPSJWaXRhbCBzaWducyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgPGF1dGhvciB0eXBlQ29kZT0iQVVUIj4NCiAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSI0NCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5XZW5keTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPk08L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+UGVyZXo8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4PlBBPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEF1dGhvcj4NCiAgICAgICAgICAgICAgPC9hdXRob3I+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjZmODBlNTlkLTk3OGItNGQwOS04NGYzLTY0YzI5OGEwOWU4MyIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbiBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNC4xIiBleHRlbnNpb249IjQzLTE4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iODQ4MC02IiBkaXNwbGF5TmFtZT0iQmxvb2QgUHJlc3N1cmUgU3lzdG9saWMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNWaXRhbC1JRDkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMTMxIiB1bml0PSJtbVtIZ10iIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIGNvZGU9IlNpdHRpbmciIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImE5NmY3MTBmLTM1NGUtNDcwNC05ZjUxLWRiYzVlMDA1ZDc0YSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0My0xOSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijg0NjItNCIgZGlzcGxheU5hbWU9IkJsb29kIFByZXNzdXJlIERpYXN0b2xpYyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMTAiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNzUiIHVuaXQ9Im1tW0hnXSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgY29kZT0iU2l0dGluZyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMTE4MDM2NGEtMDU5MS00MjIxLTlhMmQtODUzYmJlNTNmYmUyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbiBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNC4xIiBleHRlbnNpb249IjQzLTEwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iODg2Ny00IiBkaXNwbGF5TmFtZT0iSGVhcnQgUmF0ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMTEiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iODIiIHVuaXQ9Ii9taW4iIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIzZjI4MGU1MC03YWJiLTQ3MTAtODBmZS02MjRkNGNkYzVmOWUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDMtNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjkyNzktMSIgZGlzcGxheU5hbWU9IlJlc3BpcmF0b3J5IFJhdGUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNWaXRhbC1JRDEyIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMDA1MTAwNjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjMwIiB1bml0PSIvbWluIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDQ3OTE4Y2ItNDQ2MC00YzlmLThjNjctMGFmNzY2ZTI5NDlmIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbiBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNC4xIiBleHRlbnNpb249IjQzLTE1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iODMxMC01IiBkaXNwbGF5TmFtZT0iQm9keSBUZW1wZXJhdHVyZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iOTguNiIgdW5pdD0iW2RlZ0ZdIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBjb2RlPSJPcmFsIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyNzdmZGViNS04ZjFiLTQzOTctYTFkNC0wYzNiMjE5ZmYxMDIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDMtMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjgzMDItMiIgZGlzcGxheU5hbWU9IkhlaWdodCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMTQiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNjYiIHVuaXQ9Iltpbl91c10iIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI5ZGI0NTk4Yi1kNDU1LTRmNDAtYmIwZS0xMTAzNGM2ZTc2NTQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDMtMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMxNDEtOSIgZGlzcGxheU5hbWU9IldlaWdodCBNZWFzdXJlZCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMTUiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUxMDA2MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMTYwIiB1bml0PSJbbGJfYXZdIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNzRjNDZjOTQtY2VmYy00MDZhLTgzN2QtZTZjZTg4OTBkZjNiIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbiBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNC4xIiBleHRlbnNpb249IjQzLTgiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzOTE1Ni01IiBkaXNwbGF5TmFtZT0iQk1JIChCb2R5IE1hc3MgSW5kZXgpIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQxNiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTAwNTEwMDYwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyNS44IiB1bml0PSJrZy9tMiIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImZjMGYyMWRiLTVlMDItNDczOS04MjRhLWEzNzdjMzBlNzIyOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0My05IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE0MC0xIiBkaXNwbGF5TmFtZT0iQlNBIChCb2R5IFN1cmZhY2UgQXJlYSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNWaXRhbC1JRDE3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMDA1MTAwNjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjEuODIiIHVuaXQ9Im0yIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDgxYWNlMTUtN2UwMy00NDFiLTllYzgtODU4MzMwOTRkNWZiIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICA8L29yZ2FuaXplcj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8b3JnYW5pemVyIGNsYXNzQ29kZT0iQ0xVU1RFUiIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjYiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbnMgT3JnYW5pemVyIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQiIGV4dGVuc2lvbj0iNDIiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ2NjgwMDA1IiBkaXNwbGF5TmFtZT0iVml0YWwgc2lnbnMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgIDxhdXRob3IgdHlwZUNvZGU9IkFVVCI+DQogICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkQXV0aG9yPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iNDQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+V2VuZHk8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5NPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PlBlcmV6PC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5QQTwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRBdXRob3I+DQogICAgICAgICAgICAgIDwvYXV0aG9yPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI3YzQxNDEyNi1mN2MwLTRjOWYtODc0ZC05MGViNTdjMmE3MmQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0Mi0xOCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijg0ODAtNiIgZGlzcGxheU5hbWU9IkJsb29kIFByZXNzdXJlIFN5c3RvbGljIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQxOCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIxMzAiIHVuaXQ9Im1tW0hnXSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgY29kZT0iU2l0dGluZyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMWMwNjk1ZjItYjg3OC00M2UzLTgzYzQtZTk1OGQyNWFiYjk2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbiBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNC4xIiBleHRlbnNpb249IjQyLTE5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iODQ2Mi00IiBkaXNwbGF5TmFtZT0iQmxvb2QgUHJlc3N1cmUgRGlhc3RvbGljIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQxOSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI3NiIgdW5pdD0ibW1bSGddIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBjb2RlPSJTaXR0aW5nIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyYWE5ODUzZi00MzdmLTRmNmItYTQxNi1iZTAyY2Q5NDlmMTIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDItMTAiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI4ODY3LTQiIGRpc3BsYXlOYW1lPSJIZWFydCBSYXRlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQyMCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI4MiIgdW5pdD0iL21pbiIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjVjMDFiNWY1LWM5OWMtNDkyNi05Y2M0LTY3M2IxYTllZTJkMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0Mi01IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iOTI3OS0xIiBkaXNwbGF5TmFtZT0iUmVzcGlyYXRvcnkgUmF0ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMjEiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDA1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMzAiIHVuaXQ9Ii9taW4iIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI2ZWI4ZTBiYS03MTBmLTQzOTUtYmIzYi1mM2ZkMzRhODgyYjAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDItMTUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI4MzEwLTUiIGRpc3BsYXlOYW1lPSJCb2R5IFRlbXBlcmF0dXJlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQyMiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI5OC42IiB1bml0PSJbZGVnRl0iIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIGNvZGU9Ik9yYWwiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImQ2M2MyNmNjLTYxYTgtNGQ5Yy1hMjVkLWIyMjIzOWYyM2VkOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0Mi0yIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iODMwMi0yIiBkaXNwbGF5TmFtZT0iSGVpZ2h0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQyMyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI2NiIgdW5pdD0iW2luX3VzXSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPG1ldGhvZENvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjdkMThlZWI0LTRlODUtNGViMy1iNzYxLTNhZjJkMzZmMzY5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFZpdGFsIFNpZ24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTQuMSIgZXh0ZW5zaW9uPSI0Mi0xIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzE0MS05IiBkaXNwbGF5TmFtZT0iV2VpZ2h0IE1lYXN1cmVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjVml0YWwtSUQyNCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIxNjYiIHVuaXQ9IltsYl9hdl0iIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJhMTZlZDlkNy01NTQ4LTQxZGQtOGU3Mi0wOWQ0MTk1ZTNkMGYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yNyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBWaXRhbCBTaWduIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE0LjEiIGV4dGVuc2lvbj0iNDItOCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjM5MTU2LTUiIGRpc3BsYXlOYW1lPSJCTUkgKEJvZHkgTWFzcyBJbmRleCkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNWaXRhbC1JRDI1IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjI2LjgiIHVuaXQ9ImtnL20yIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8bWV0aG9kQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMTRkMGEzZGItZDllNS00MmE4LWFkNWYtYzY2MWUyYjk0NGZiIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgVml0YWwgU2lnbiBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNC4xIiBleHRlbnNpb249IjQyLTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMTQwLTEiIGRpc3BsYXlOYW1lPSJCU0EgKEJvZHkgU3VyZmFjZSBBcmVhKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI1ZpdGFsLUlEMjYiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDA1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMS44NSIgdW5pdD0ibTIiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxtZXRob2RDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIzYzQ1OWRhNi02NTk0LTQ0NWItOTAzZC00OWRlODFiOTc4N2EiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgIDwvb3JnYW5pemVyPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgIDwvc2VjdGlvbj4NCiAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHNlY3Rpb24+DQogICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4zLjEiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0cyBTZWN0aW9uIChFbnRyaWVzIFJlcXVpcmVkKSIgLz4NCiAgICAgICAgICA8aWQgcm9vdD0iNWQ4YWIyODAtZjNlMS00YjhmLWEzNzYtNGUzY2ExYWUwM2ViIiAvPg0KICAgICAgICAgIDxjb2RlIGNvZGU9IjMwOTU0LTIiIGRpc3BsYXlOYW1lPSJSRVNVTFRTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+TGFiIFJlc3VsdHM8L3RpdGxlPg0KICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiIElEPSJsYWJUZXN0RGVzY3JpcHRpb240OTciPkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQ8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJyaWdodCI+TGFiQ29ycCBNYWRpc29uPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0ibGVmdCI+T3JkZXJlZCBieSBEYXZpZCBFIEZvcmQgTUQgb24gMDEvMDMvMjAwODwvdGg+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249InJpZ2h0Ij5Db2xsZWN0ZWQ6IDAxLzAzLzIwMDggUmVwb3J0ZWQ6IDAxLzAzLzIwMDg8L3RoPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjMwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjE5Ij5XaGl0ZSBCbG9vZCBDZWxsIChXQkMpIENvdW50PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD42Ljg8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+VEhPVVMvTUNMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxOSI+KDMuOC0xMC44KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjIwIj5SZWQgQmxvb2QgQ2VsbCAoUkJDKSBDb3VudDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+NC41MDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5NSUxML01DTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMjAiPigzLjgwLTUuMTApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjEiPkhlbW9nbG9iaW48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjEzLjc8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Ry9ETDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMjEiPigxMS43LTE1LjUpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjIiPkhlbWF0b2NyaXQ8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjQxLjA8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMjIiPigzNS4wLTQ1LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjMiPk1DVjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+ODAuMDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5GTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMjMiPiguMC0xMDAuMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24yNCI+TUNIPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4zMC4wPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPlBHPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UyNCI+KDI3LjAtMzMuMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24yNSI+TUNIQzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MzUuNTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5HL0RMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UyNSI+KDMyLjAtMzYuMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24yNiI+UG9seXM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjUyLjA8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMjYiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjciPkx5bXBoczwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MzIuNjwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4lPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UyNyI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24yOCI+TW9ub2N5dGVzPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD44LjM8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMjgiPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjkiPkVvczwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Ni4yPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPiU8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTI5Ij4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjMwIj5CYXNvczwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MC45PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPiU8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTMwIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjMxIj5QbGF0ZWxldHM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjM0OTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5USE9VUy9NQ0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTMxIj4oMTQwLTQwMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24zMiI+UG9seXMgKEFic29sdXRlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Mjg1MjwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5DRUxMUy9NQ0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTMyIj4oMTUwMC03ODAwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjMzIj5MeW1waHMgKEFic29sdXRlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MTkwMTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5DRUxMUy9NQ0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTMzIj4oODUwLTM5MDApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzQiPk1vbm9jeXRlcyhBYnNvbHV0ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjYwMTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5DRUxMUy9NQ0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTM0Ij4oMjAwLTk1MCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24zNSI+RW9zIChBYnNvbHV0ZSBWYWx1ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjQyMDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5DRUxMUy9NQ0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTM1Ij4oMTUtNTAwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjM2Ij5CYXNvKEFic29sdXRlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+NDU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Q0VMTFMvTUNMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UzNiI+KDAtMjAwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjM3Ij5SRFc8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjEyLjU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMzciPigxMS4wLTE1LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSI2Ij5SZXZpZXdlZCBieSBEYXZpZCBFIEZvcmQgTUQgb24gMDEvMDgvMjAwODsgQWxsIHRlc3QgcmVzdWx0cyBhcmUgZmluYWwgdW5sZXNzIG90aGVyd2lzZSBub3RlZC48L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHBhcmFncmFwaD4NCiAgICAgICAgICAgIDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiIElEPSJsYWJUZXN0RGVzY3JpcHRpb24xNzgiPkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVDwvdGg+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249InJpZ2h0Ij5MYWJDb3JwIE1hZGlzb248L3RoPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJsZWZ0Ij5PcmRlcmVkIGJ5IERhdmlkIEUgRm9yZCBNRCBvbiAxMS8wMi8yMDA3PC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0icmlnaHQiPkNvbGxlY3RlZDogMTEvMDIvMjAwNyBSZXBvcnRlZDogMTEvMDUvMjAwNzwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90aGVhZD4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMzAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzgiPldoaXRlIEJsb29kIENlbGwgKFdCQykgQ291bnQ8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjUuMzwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5YXzEwLTMvdUw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTM4Ij4oNC4wLTEwLjUpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzkiPlJlZCBCbG9vZCBDZWxsIChSQkMpIENvdW50PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4zLjg2PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPlhfMTAtNi91TDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMzkiPigzLjgwLTUuMTApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDAiPkhlbW9nbG9iaW48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjExLjU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Zy9kTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNDAiPigxMS41LTE1LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDEiPkhlbWF0b2NyaXQ8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjM0LjI8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNDEiPigzNC4wLTQ0LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDIiPk1DVjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+ODY8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Zkw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTQyIj4oODAtOTgpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDMiPk1DSDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MjguNjwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5wZzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNDMiPigyNy4wLTM0LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDQiPk1DSEM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjMzLjI8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Zy9kTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNDQiPigzMi4wLTM2LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDUiPlBvbHlzPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD41NzwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4lPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U0NSI+KDQwLTc0KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQ2Ij5MeW1waHM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjI5PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPiU8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTQ2Ij4oMTQtNDYpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDciPk1vbm9jeXRlczwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MTE8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNDciPig0LTEzKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQ4Ij5Fb3M8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjM8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNDgiPigwLTcpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDkiPkJhc29zPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4wPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPiU8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTQ5Ij4oMC0zKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjUwIj5QbGF0ZWxldHM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjI1ODwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5YXzEwLTMvdUw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTUwIj4oMTQwLTQxNSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk5vbmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241MSI+SGVtYXRvbG9neSBDb21tZW50czo8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgICA8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTUxIj4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5TdGF0dXM6IENhbm5vdCBiZSBkb25lPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNTIiPlBvbHlzIChBYnNvbHV0ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjMuMDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5YXzEwLTMvdUw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTUyIj4oMS44LTcuOCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk5vbmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241MyI+THltcGhzIChBYnNvbHV0ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjEuNTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5YXzEwLTMvdUw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTUzIj4oMC43LTQuNSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk5vbmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241NCI+TW9ub2N5dGVzKEFic29sdXRlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MC42PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPlhfMTAtMy91TDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNTQiPigwLjEtMS4wKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjU1Ij5Fb3MgKEFic29sdXRlIFZhbHVlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MC4yPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPlhfMTAtMy91TDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNTUiPigwLjAtMC40KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjU2Ij5CYXNvKEFic29sdXRlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MC4wPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPlhfMTAtMy91TDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNTYiPigwLjAtMC4yKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjU3Ij5SRFc8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjE0Ljg8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNTciPigxMS43LTE1LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSI2Ij5SZXZpZXdlZCBieSBEYXZpZCBFIEZvcmQgTUQgb24gMTEvMDUvMjAwNzsgQWxsIHRlc3QgcmVzdWx0cyBhcmUgZmluYWwgdW5sZXNzIG90aGVyd2lzZSBub3RlZC48L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHBhcmFncmFwaD4NCiAgICAgICAgICAgIDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiIElEPSJsYWJUZXN0RGVzY3JpcHRpb24xNzkiPkhGUDcrM0FDPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0icmlnaHQiPkxhYkNvcnAgTWFkaXNvbjwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiPk9yZGVyZWQgYnkgRGF2aWQgRSBGb3JkIE1EIG9uIDExLzAyLzIwMDc8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJyaWdodCI+Q29sbGVjdGVkOiAxMS8wMi8yMDA3IFJlcG9ydGVkOiAxMS8wNS8yMDA3PC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIzMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241OCI+Q2hvbGVzdGVyb2wsIFRvdGFsPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4yMjA8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+bWcvZEw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTU4Ij4oMTAwLTE5OSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPkggKEhpZ2gpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSI2IiBJRD0iY29tcG9uZW50MnRlc3Q1OCI+Tm90ZTogUGVyZm9ybWVkIEF0OiBNQQpMQUJDT1JQIE1BRElTT04KMTQ0NyBZT1JLIENPVVJUCk1BRElTT04sIENBIDk1NjUzMDAwMAo8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241OSI+UHJvdGVpbiwgVG90YWwsIFNlcnVtPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD42LjM8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Zy9kTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNTkiPig2LjAtOC41KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjYwIj5BbGJ1bWluLCBTZXJ1bTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+My43PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPmcvZEw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTYwIj4oMy42LTQuOCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk5vbmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb242MSI+QmlsaXJ1YmluLCBUb3RhbDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MC44PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPm1nL2RMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U2MSI+KDAuMS0xLjIpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNjIiPkFsa2FsaW5lIFBob3NwaGF0YXNlLCBTZXJ1bTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MTQyPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPklVL0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTYyIj4oMjUtMTY1KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjYzIj5MREg8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjEwODwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5JVS9MPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U2MyI+KDEwMC0yNTApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNjQiPkFTVCAoU0dPVCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjI3PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPklVL0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTY0Ij4oMC00MCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk5vbmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb242NSI+QmlsaXJ1YmluLCBEaXJlY3Q8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjAuMzE8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+bWcvZEw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTY1Ij4oMC4wMC0wLjQwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjY2Ij5BTFQgKFNHUFQpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4yMzwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5JVS9MPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U2NiI+KDAtNDApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob25lPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNjciPkdHVDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MzY8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+SVUvTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNjciPigwLTYwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+Tm9uZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iNiI+UmV2aWV3ZWQgYnkgRGF2aWQgRSBGb3JkIE1EIG9uIDExLzA1LzIwMDc7IEFsbCB0ZXN0IHJlc3VsdHMgYXJlIGZpbmFsIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQuPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDxwYXJhZ3JhcGg+DQogICAgICAgICAgICA8L3BhcmFncmFwaD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8dGhlYWQ+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJsZWZ0IiBJRD0ibGFiVGVzdERlc2NyaXB0aW9uMTYwIj5USFlST0lEIFBBTkVMIFdJVEggVFNIPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0icmlnaHQiPkxhYkNvcnAgTWFkaXNvbjwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiPk9yZGVyZWQgYnkgRGF2aWQgRSBGb3JkIE1EIG9uIDEwLzA1LzIwMDc8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJyaWdodCI+Q29sbGVjdGVkOiAxMC8wNS8yMDA3IFJlcG9ydGVkOiAxMC8wOC8yMDA3PC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIzMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb242OCI+VGh5cm94aW5lIChUNCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjUuMTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5tY2cvZEw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTY4Ij4oNC41LTEyLjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSI2IiBJRD0iY29tcG9uZW50M3Rlc3Q2OCI+Tm90ZTogICAgICAgICAgICAgICoqKkVGRkVDVElWRSBOT1ZFTUJFUiAyNiwgMjAwMSBUaGUgcmVmZXJlbmNlIGludGVydmFsKioqCiAgICAgICAgICAgICAgICB3aWxsIGJlIGNoYW5naW5nIHRvOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYWxlICAgICAgICAgICAgRmVtYWxlCiAgICAgICAgICAgICAgICAgICAgIENvcmQgQmxvb2QgICAgICAgICA2LjYtMTcuNSAgICAgICAgIDYuNi0xNy41CiAgICAgICAgICAgICAgICAgICAgIDEtICAzIERheXMgICAgICAgIDExLjAtMjEuNSAgICAgICAgMTEuMC0yMS41CiAgICAgICAgICAgICAgICAgICAgIDEtICA0IFdlZWtzICAgICAgICA4LjItMTYuNiAgICAgICAgIDguMi0xNi42CiAgICAgICAgICAgICAgICAgICAgIDEtIDExIE1vbnRocyAgICAgICA2LjQtMTMuOSAgICAgICAgIDQuOS0xMy43CiAgICAgICAgICAgICAgICAgICAgIDEtICAzIFllYXJzICAgICAgICA3LjAtMTMuMSAgICAgICAgIDcuMS0xNC4xCiAgICAgICAgICAgICAgICAgICAgIDQtICA2IFllYXJzICAgICAgICA2LjEtMTIuNiAgICAgICAgIDcuMi0xNC4wCiAgICAgICAgICAgICAgICAgICAgIDctIDEyIFllYXJzICAgICAgICA2LjctMTMuNCAgICAgICAgIDYuMS0xMi4xCiAgICAgICAgICAgICAgICAgICAgIDEzLTE1IFllYXJzICAgICAgICA0LjgtMTEuNSAgICAgICAgIDUuOC0xMS4yCiAgICAgICAgICAgICAgICAgICAgIEFkdWx0ICAgICAgICAgICAgICA0LjUtMTIuMCAgICAgICAgIDQuNS0xMi4wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4KPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNjkiPlQzIFVwdGFrZTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MzE8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNjkiPigyNC0zOSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243MCI+RnJlZSBUaHlyb3hpbmUgSW5kZXg8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjMuMjwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNzAiPigxLjItNC45KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjcxIj5UU0gsIEhpZ2ggU2Vuc2l0aXZpdHksIFNlcnVtPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD40LjIxPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPm1jSVUvbUw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTcxIj4oMC4zNS01LjUwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iNiIgSUQ9ImNvbXBvbmVudDN0ZXN0NzEiPk5vdGU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKipQbGVhc2UgTm90ZSBSZWZlcmVuY2UgSW50ZXJ2YWwgQ2hhbmdlKioKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4KPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSI2Ij5SZXZpZXdlZCBieSBEYXZpZCBFIEZvcmQgTUQgb24gMTAvMDgvMjAwNzsgQWxsIHRlc3QgcmVzdWx0cyBhcmUgZmluYWwgdW5sZXNzIG90aGVyd2lzZSBub3RlZC48L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHBhcmFncmFwaD4NCiAgICAgICAgICAgIDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiIElEPSJsYWJUZXN0RGVzY3JpcHRpb24xNjEiPkNsK0srTmE8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJyaWdodCI+TGFiQ29ycCBNYWRpc29uPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0ibGVmdCI+T3JkZXJlZCBieSBEYXZpZCBFIEZvcmQgTUQgb24gMTAvMDUvMjAwNzwvdGg+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249InJpZ2h0Ij5Db2xsZWN0ZWQ6IDEwLzA1LzIwMDcgUmVwb3J0ZWQ6IDEwLzA4LzIwMDc8L3RoPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjMwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjcyIj5Qb3Rhc3NpdW0sIFNlcnVtPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD40LjE8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+bW1vbC9MPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U3MiI+KDMuNS01LjUpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNzMiPlNvZGl1bSwgU2VydW08L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjEzOTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5tbW9sL0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTczIj4oMTM1LTE0OCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243NCI+Q2hsb3JpZGUsIFNlcnVtPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4xMDE8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+bW1vbC9MPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U3NCI+KDk2LTEwOSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjYiPlJldmlld2VkIGJ5IERhdmlkIEUgRm9yZCBNRCBvbiAxMC8wOC8yMDA3OyBBbGwgdGVzdCByZXN1bHRzIGFyZSBmaW5hbCB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLjwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8cGFyYWdyYXBoPg0KICAgICAgICAgICAgPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjFweCIgLz4NCiAgICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0ibGVmdCIgSUQ9ImxhYlRlc3REZXNjcmlwdGlvbjE2MiI+UlBSPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0icmlnaHQiPkxhYkNvcnAgTWFkaXNvbjwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiPk9yZGVyZWQgYnkgRGF2aWQgRSBGb3JkIE1EIG9uIDEwLzA1LzIwMDc8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJyaWdodCI+Q29sbGVjdGVkOiAxMC8wNS8yMDA3IFJlcG9ydGVkOiAxMC8wOC8yMDA3PC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIC8+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIzMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243NSI+UlBSPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5Ob24tUmVhY3RpdmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTc1Ij4oTm9uLVJlYWN0aXZlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iNiIgSUQ9ImNvbXBvbmVudDV0ZXN0NzUiPk5vdGU6IFBlcmZvcm1lZCBBdDogTUEKTEFCQ09SUCBNQURJU09OCjE0NDcgWU9SSyBDT1VSVApNQURJU09OLCBDQSA5NTY1MzAwMDAKPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPSI2Ij5SZXZpZXdlZCBieSBEYXZpZCBFIEZvcmQgTUQgb24gMTAvMDgvMjAwNzsgQWxsIHRlc3QgcmVzdWx0cyBhcmUgZmluYWwgdW5sZXNzIG90aGVyd2lzZSBub3RlZC48L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHBhcmFncmFwaD4NCiAgICAgICAgICAgIDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPGNvbCAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxcHgiIC8+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiIElEPSJsYWJUZXN0RGVzY3JpcHRpb240OTMiPkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQ8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJyaWdodCI+TGFiQ29ycCBNYWRpc29uPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0ibGVmdCI+T3JkZXJlZCBieSBEYXZpZCBFIEZvcmQgTUQgb24gMDkvMDMvMjAwNzwvdGg+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249InJpZ2h0Ij5Db2xsZWN0ZWQ6IDA5LzAzLzIwMDcgUmVwb3J0ZWQ6IDA5LzAzLzIwMDc8L3RoPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjMwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjAiPldoaXRlIEJsb29kIENlbGwgKFdCQykgQ291bnQ8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjUuODwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5USE9VUy9NQ0w8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTAiPigzLjgtMTAuOCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xIj5SZWQgQmxvb2QgQ2VsbCAoUkJDKSBDb3VudDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+NC4yMDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5NSUxML01DTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMSI+KDMuODAtNS4xMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24yIj5IZW1vZ2xvYmluPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4xMS43PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkcvREw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTIiPigxMS43LTE1LjUpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMyI+SGVtYXRvY3JpdDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MzYuMjwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4lPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UzIj4oMzUuMC00NS4wKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQiPk1DVjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+ODYuMTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5GTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNCI+KC4wLTEwMC4wKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjUiPk1DSDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+MjguMDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5QRzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNSI+KDI3LjAtMzMuMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb242Ij5NQ0hDPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4zMi41PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkcvREw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTYiPigzMi4wLTM2LjApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNyI+UG9seXM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjUxLjE8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNyI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244Ij5MeW1waHM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjMxLjg8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+JTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlOCI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb245Ij5Nb25vY3l0ZXM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjkuMTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4lPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U5Ij4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjEwIj5Fb3M8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjcuMjwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4lPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxMCI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xMSI+QmFzb3M8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjAuODwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4lPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxMSI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xMiI+UGxhdGVsZXRzPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4zNTQ8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+VEhPVVMvTUNMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxMiI+KDE0MC00MDApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMTMiPlBvbHlzIChBYnNvbHV0ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjI5NjQ8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Q0VMTFMvTUNMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxMyI+KDE1MDAtNzgwMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xNCI+THltcGhzIChBYnNvbHV0ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjE4NDQ8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Q0VMTFMvTUNMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxNCI+KDg1MC0zOTAwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjE1Ij5Nb25vY3l0ZXMoQWJzb2x1dGUpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD41Mjg8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Q0VMTFMvTUNMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxNSI+KDIwMC05NTApPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMTYiPkVvcyAoQWJzb2x1dGUgVmFsdWUpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD40MTg8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+Q0VMTFMvTUNMPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2UxNiI+KDE1LTUwMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xNyI+QmFzbyhBYnNvbHV0ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjQ2PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkNFTExTL01DTDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlMTciPigwLTIwMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xOCI+UkRXPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4xMy40PC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPiU8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTE4Ij4oMTEuMC0xNS4wKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iNiI+UmV2aWV3ZWQgYnkgRGF2aWQgRSBGb3JkIE1EIG9uIDAxLzA4LzIwMDg7IEFsbCB0ZXN0IHJlc3VsdHMgYXJlIGZpbmFsIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQuPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDxwYXJhZ3JhcGg+DQogICAgICAgICAgICA8L3BhcmFncmFwaD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8dGhlYWQ+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJsZWZ0IiBJRD0ibGFiVGVzdERlc2NyaXB0aW9uMzA4Ij5IZW1hdG9jcml0PC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0icmlnaHQiPk1hZGlzb24gTGFib3JhdG9yeTwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiPk9yZGVyZWQgYnkgSmFtZXMgVCBNb25yb2UgTUQgb24gMDkvMDMvMjAwNzwvdGg+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249InJpZ2h0Ij5Db2xsZWN0ZWQ6IDA5LzAzLzIwMDcgUmVwb3J0ZWQ6IDA5LzAzLzIwMDc8L3RoPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjMwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjc2Ij5GZW1hbGU8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjQwPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U3NiI+KDM3LTQ3KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjc3Ij5NYWxlPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4wMDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNzciPig0MC01NCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49IjYiPlJldmlld2VkIGJ5IEphbWVzIFQgTW9ucm9lIE1EIG9uIDA5LzAzLzIwMDc7IEFsbCB0ZXN0IHJlc3VsdHMgYXJlIGZpbmFsIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQuPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDxwYXJhZ3JhcGg+DQogICAgICAgICAgICA8L3BhcmFncmFwaD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMXB4IiAvPg0KICAgICAgICAgICAgICA8dGhlYWQ+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRoIGFsaWduPSJsZWZ0IiBJRD0ibGFiVGVzdERlc2NyaXB0aW9uMzA5Ij5VcmluYWx5c2lzPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aCBhbGlnbj0icmlnaHQiPk1hZGlzb24gTGFib3JhdG9yeTwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249ImxlZnQiPk9yZGVyZWQgYnkgSmFtZXMgVCBNb25yb2UgTUQgb24gMDkvMDMvMjAwNzwvdGg+DQogICAgICAgICAgICAgICAgICA8dGggYWxpZ249InJpZ2h0Ij5Db2xsZWN0ZWQ6IDA5LzAzLzIwMDcgUmVwb3J0ZWQ6IDA5LzAzLzIwMDc8L3RoPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgLz4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjMwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDxjb2wgd2lkdGg9IjEwMHB4IiAvPg0KICAgICAgICAgICAgICA8Y29sIHdpZHRoPSIxMDBweCIgLz4NCiAgICAgICAgICAgICAgPGNvbCB3aWR0aD0iMTAwcHgiIC8+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjc4Ij5BcHBlYXJhbmNlPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5DbGVhcjwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlNzgiPihDbGVhci1Nb2QgQ2xvdWQpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNzkiPkJpbGlydWJpbjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TmVnYXRpdmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTc5Ij4oTmVnYXRpdmUtU21hbGwpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uODAiPkJsb29kPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OZWdhdGl2ZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlODAiPihOZWdhdGl2ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244MSI+Q29sb3I8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPlllbGxvdzwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlODEiPihOb25lLVllbGxvdyk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244MiI+R2x1Y29zZTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TmVnYXRpdmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTgyIj4oTmVnYXRpdmUtMjUwKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjgzIj5TcGVjaWZpYyBHcmF2aXR5PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD4xLjAwNTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlODMiPigxLjAwMC0xLjAxMCk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244NCI+S2V0b25lPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OZWdhdGl2ZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlODQiPihOZWdhdGl2ZS1UcmFjZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244NSI+TGV1a29jeXRlczwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TmVnYXRpdmU8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJyZXN1bHRSYW5nZTg1Ij4oTmVnYXRpdmUtVHJhY2UpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OIChOb3JtYWwpPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0idGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uODYiPk5pdHJpdGVzPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgPHBhcmFncmFwaD5OZWdhdGl2ZTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlODYiPihOZWdhdGl2ZSk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk4gKE5vcm1hbCk8L3BhcmFncmFwaD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJ0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244NyI+cEggTGV2ZWw8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPjYuMDwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InJlc3VsdFJhbmdlODciPig1LjAtNi41KTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InRlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjg4Ij5Vcm9iaWxpbm9nZW48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICA8cGFyYWdyYXBoPk5lZ2F0aXZlPC9wYXJhZ3JhcGg+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0icmVzdWx0UmFuZ2U4OCI+KE5lZ2F0aXZlKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICAgIDxwYXJhZ3JhcGg+TiAoTm9ybWFsKTwvcGFyYWdyYXBoPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj0iNiI+UmV2aWV3ZWQgYnkgSmFtZXMgVCBNb25yb2UgTUQgb24gMDkvMDMvMjAwNzsgQWxsIHRlc3QgcmVzdWx0cyBhcmUgZmluYWwgdW5sZXNzIG90aGVyd2lzZSBub3RlZC48L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHBhcmFncmFwaD4NCiAgICAgICAgICAgIDwvcGFyYWdyYXBoPg0KICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICA8ZW50cnk+DQogICAgICAgICAgICA8b3JnYW5pemVyIGNsYXNzQ29kZT0iQkFUVEVSWSIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT3JnYW5pemVyIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMSIgZXh0ZW5zaW9uPSI0OTciIC8+DQogICAgICAgICAgICAgIDxjb2RlIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0Ij4NCiAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNzEzODgwMDIiIGRpc3BsYXlOYW1lPSJQcm9jZWR1cmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgPHNwZWNpbWVuIHR5cGVDb2RlPSJTUEMiPg0KICAgICAgICAgICAgICAgIDxzcGVjaW1lblJvbGUgY2xhc3NDb2RlPSJTUEVDIj4NCiAgICAgICAgICAgICAgICAgIDxzcGVjaW1lblBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkJMRCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuMTIuNzAiIGNvZGVTeXN0ZW1OYW1lPSJTcGVjaW1lbiBTb3VyY2UiIGRpc3BsYXlOYW1lPSJXaG9sZSBibG9vZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+V2hvbGUgYmxvb2Q8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3NwZWNpbWVuUGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3NwZWNpbWVuUm9sZT4NCiAgICAgICAgICAgICAgPC9zcGVjaW1lbj4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJBVVQiPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJSRVNQIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IlZSRiI+DQogICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0xIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNjY5MC0yIiBkaXNwbGF5TmFtZT0iV2hpdGUgQmxvb2QgQ2VsbCAoV0JDKSBDb3VudCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjE5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjYuOCIgdW5pdD0iVEhPVVMvTUNMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIxNjJhMjkwMy1jMTU5LTQxM2QtODM4Mi0yZTBmY2Y2MGI3MmEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMy44LTEwLjgpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMTkiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJlYWIwZGI5Yi02MTg5LTRiMjQtYWRjMC1kNzIzYzY5ZWFiYWEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0yIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzg5LTgiIGRpc3BsYXlOYW1lPSJSZWQgQmxvb2QgQ2VsbCAoUkJDKSBDb3VudCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjIwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjQuNTAiIHVuaXQ9Ik1JTEwvTUNMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJhMjNkZDVlMy1jMDgzLTRhNTktOWM1Yi05ZjcyZmEzZGUzYTMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMy44MC01LjEwKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTIwIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYTQxMGU0MDQtY2JhNS00NWIwLWJmYjEtNWUwNTE5ZWM1NmY4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTctNCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjcxOC03IiBkaXNwbGF5TmFtZT0iSGVtb2dsb2JpbiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjIxIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjEzLjciIHVuaXQ9IkcvREwiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjI4N2Y4MzE2LTY0NzUtNDM1Ni1hNjE0LTA5NjBjOGE0YTVmOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxMS43LTE1LjUpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMjEiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI1NWE5MDAzMC0xMmNjLTQzZGItYjE2ZS04MzU4YzI1YmFjNzEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny01IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNDU0NC0zIiBkaXNwbGF5TmFtZT0iSGVtYXRvY3JpdCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjIyIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjQxLjAiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjA0ODJiNDA2LTA4NGYtNDFkNC1iOGM0LTYxZmU5N2VhNmUwZiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigzNS4wLTQ1LjApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMjIiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmY2YyNWI1Yi05NjU0LTQwZTctYTE1My0wNGVmNDdkMzhlYmQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzg3LTIiIGRpc3BsYXlOYW1lPSJNQ1YiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24yMyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI4MC4wIiB1bml0PSJGTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMjJkZGEwMTMtODJjOS00ODMzLWFhODYtNmU5Mjg3M2Y5MzYyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KC4wLTEwMC4wKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTIzIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOTM3ZjI0NmUtNzRlMC00NTM2LThiMDctMDcxY2U4ZmNlZmQ4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTctNyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc4NS02IiBkaXNwbGF5TmFtZT0iTUNIIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjQiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMzAuMCIgdW5pdD0iUEciIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjA4ODhjMTZmLWE2OGQtNDNlZi04Y2VjLTJiNjE5N2Y1NjI4YyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigyNy4wLTMzLjApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMjQiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJhMWFlMWFmZS0wMGJjLTQ1ZDctYWI2ZC1hMjkwY2QxODAxMTIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny02IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzg2LTQiIGRpc3BsYXlOYW1lPSJNQ0hDIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjUiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMzUuNSIgdW5pdD0iRy9ETCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNGUxZjM0N2ItMzFmNS00NDgwLTkyMzItOWYzMGJmNjIzZjlkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDMyLjAtMzYuMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UyNSIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImY5YTAxZThmLTFiMmItNDUxMi1iNGU2LTVmN2I2ZGU3YTFkMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDk3LTgiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3NzAtOCIgZGlzcGxheU5hbWU9IlBvbHlzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMjYiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNTIuMCIgdW5pdD0iJSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOWU1OTRjMTUtYWFlYS00NDUyLWEyMWMtYWMwYzAyMzgzYzkxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImFlZWM5N2YwLTcwYTUtNDA4Mi05OTZlLTg4MDk3OTFiZjJlYiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDk3LTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MzYtOSIgZGlzcGxheU5hbWU9Ikx5bXBocyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjI3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjMyLjYiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijg5YzU1YjE1LTViNjctNDgwYS1iYmZjLTAyNmVlODA2ODliMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI3NDBkOWQyOS01N2ViLTRjZjUtOTAxYS0zOGI0ZDk3NmIxNDMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0xMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjU5MDUtNSIgZGlzcGxheU5hbWU9Ik1vbm9jeXRlcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjI4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjguMyIgdW5pdD0iJSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYjY3MzE1NjMtMTBiOC00NGQyLWExZmMtYzA1OWNhMTJjNGM2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjI2MzA3NzA0LWE2NmMtNDViNi05YTA2LTNmZDM5ZTA0MzdlZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDk3LTEzIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzEzLTgiIGRpc3BsYXlOYW1lPSJFb3MiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24yOSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI2LjIiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjZkYWI0ODE0LTY2MDQtNGE3Ni1iY2IyLTZiZWI0N2MxYzMxOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIwZjUyNGY1Ny1kNWI3LTQ1MDgtYThiZC02ZGIzMTIwYzE3NzciIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0xMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjcwNi0yIiBkaXNwbGF5TmFtZT0iQmFzb3MiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24zMCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIwLjkiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjdkYjhkMGNkLWQ4NmUtNDYwNi04ZGVhLTQ3ZmUzMmVlM2MxOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0MmM0OWQ5Zi1hMjY0LTQzMmQtYjJlYy04MGI1MDYwOTc2ZTIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0xMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc3Ny0zIiBkaXNwbGF5TmFtZT0iUGxhdGVsZXRzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzEiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMzQ5IiB1bml0PSJUSE9VUy9NQ0wiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjViYWQ5ZmRmLTVmMjgtNDVhNi04MGVjLWIxZjY0ZDA4YWZiNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxNDAtNDAwKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTMxIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMGIyZDM2YjgtNjdhNS00ZmIwLWEwM2EtMTQ5YThhN2U1YTU1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTctMTQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3NTEtOCIgZGlzcGxheU5hbWU9IlBvbHlzIChBYnNvbHV0ZSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24zMiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyODUyIiB1bml0PSJDRUxMUy9NQ0wiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjkwMWNmNjkxLWZjZWItNDczYS1iNTJmLTNkZDM4ZWQ1OWY0MSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxNTAwLTc4MDApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMzIiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI2MzM2Y2RiMi1jNGI4LTRlODktYWI2NC1kMmU5YTZjNjY5NTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0xNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjczMS0wIiBkaXNwbGF5TmFtZT0iTHltcGhzIChBYnNvbHV0ZSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24zMyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIxOTAxIiB1bml0PSJDRUxMUy9NQ0wiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImNiY2JjMTMwLWRkYzgtNDk4YS1hNGI2LWU5OGY4MzI3YzhhMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPig4NTAtMzkwMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UzMyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijc4M2JhZmE3LWQxNGEtNDNmZS1iMzVhLTU0YWRkYmFhYjZhZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDk3LTE2IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzQyLTciIGRpc3BsYXlOYW1lPSJNb25vY3l0ZXMoQWJzb2x1dGUpIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzQiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNjAxIiB1bml0PSJDRUxMUy9NQ0wiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImIwODI4NmJiLTAzMjItNGY4OC04NjMwLTI2ZGM4N2RjNjE5OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigyMDAtOTUwKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTM0IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMGQ2YmNmMWItYzBjMS00NjgzLTliYTAtYWVmOWQ1YWZlMDgxIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTciIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTctMTciIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MTEtMiIgZGlzcGxheU5hbWU9IkVvcyAoQWJzb2x1dGUgVmFsdWUpIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzUiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNDIwIiB1bml0PSJDRUxMUy9NQ0wiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImVhOWUzOTM3LWQ5ZGMtNDc1NC05ZGFhLTRmY2FjNGMwNzJkMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxNS01MDApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMzUiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIwMGQ1MGYwOC01ZWI5LTQ0OTctOTFhZC1iOTliMmMzMjgyMTEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0xOCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjcwNC03IiBkaXNwbGF5TmFtZT0iQmFzbyhBYnNvbHV0ZSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24zNiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI0NSIgdW5pdD0iQ0VMTFMvTUNMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI1ZDk1ZWM1Yy1iZGNiLTRhMmYtYTFmZC05NmJhNDg1MjhjNzciIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMC0yMDApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMzYiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJiNTgzMzdhNy1iZmM0LTQ1ZDctYjBmOS05YzhjMDk2MzBkY2MiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA4MDEwMzE0NTgwMC0wNTAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5Ny0xOSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc4OC0wIiBkaXNwbGF5TmFtZT0iUkRXIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzciIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwODAxMDMxNDU4MDAtMDUwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMTIuNSIgdW5pdD0iJSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMzZkOTczZDEtN2RkYy00OWIwLThhMWYtODM1YmEwNTc4YTViIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDExLjAtMTUuMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UzNyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjllMTdkM2ZkLWIzYzgtNGQ1OC1iYmJhLWI2NTE3NzBiYjg2YyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDk3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDgwMTAzMTQ1ODAwLTA1MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgPC9vcmdhbml6ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnk+DQogICAgICAgICAgICA8b3JnYW5pemVyIGNsYXNzQ29kZT0iQkFUVEVSWSIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT3JnYW5pemVyIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMSIgZXh0ZW5zaW9uPSIxNzgiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGRpc3BsYXlOYW1lPSJDQkMgV0lUSCBESUZGRVJFTlRJQUwvUExBVEVMRVQiPg0KICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI3MTM4ODAwMiIgZGlzcGxheU5hbWU9IlByb2NlZHVyZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICA8c3BlY2ltZW4gdHlwZUNvZGU9IlNQQyIgbnVsbEZsYXZvcj0iTkkiPg0KICAgICAgICAgICAgICAgIDxzcGVjaW1lblJvbGUgY2xhc3NDb2RlPSJTUEVDIiBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgPC9zcGVjaW1lbj4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJBVVQiPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJSRVNQIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IlZSRiI+DQogICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcxMTA1IiAvPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OC0xIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNjY5MC0yIiBkaXNwbGF5TmFtZT0iV2hpdGUgQmxvb2QgQ2VsbCAoV0JDKSBDb3VudCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjM4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjUuMyIgdW5pdD0iWF8xMC0zL3VMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjM1MjljNmIzLWQ1YjYtNGJmOC05ZTNjLThmMjVlZDJmMWYwMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDQuMC0xMC41KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTM4IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMThiODZiMTktY2E5OC00NDdiLTlkODUtMTVmN2U5NDZmMThkIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJiNjQzNzE3NC01YjQwLTQ5NzEtOGEwOC01MjEzODQ2N2E0YjQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3ODktOCIgZGlzcGxheU5hbWU9IlJlZCBCbG9vZCBDZWxsIChSQkMpIENvdW50IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMzkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMy44NiIgdW5pdD0iWF8xMC02L3VMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjczNDEyODIzLTVhYzYtNDdiNi05Y2NjLTE5NmJlYzI1N2UzNiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDMuODAtNS4xMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UzOSIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImZkNmI0ZDRkLWY2NDgtNGM2Yy04ZThjLThlNTAxZDA3MzkwYyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgV0lUSCBESUZGRVJFTlRJQUwvUExBVEVMRVQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMzQ3OTJkODgtZjcyNS00NzE0LTkyMDItZTY0YWVkYzBmOTFkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OC0zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzE4LTciIGRpc3BsYXlOYW1lPSJIZW1vZ2xvYmluIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDAiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMTEuNSIgdW5pdD0iZy9kTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDRhYWRhZTUtZDg3MC00ZGQ4LWJkMjQtZTU2NTU1ZGJjNzRjIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMTEuNS0xNS4wKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTQwIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDczMTNkMTktYjA2OC00NTgwLTk0MzItNTFiNTlmNTkwNzI2IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIxMWUzM2Y2ZC1jZDkwLTQ0OTAtYWE3Yy1jOGVhZTQ5Y2YwNGEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI0NTQ0LTMiIGRpc3BsYXlOYW1lPSJIZW1hdG9jcml0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNDEiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMzQuMiIgdW5pdD0iJSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iN2ZlOWJiMzItODg5YS00YzhmLTk3YmMtZDdhN2RhN2U0MzIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMzQuMC00NC4wKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTQxIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZmRmOTFlOWUtMTlmNS00OTI5LThmMTEtMGVjMTZjMzAwY2IxIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjMzZiYjhmOS0wM2M1LTQ3ODUtYjUxZC1kZWE4MzA1YmRlNDkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3ODctMiIgZGlzcGxheU5hbWU9Ik1DViIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQyIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9Ijg2IiB1bml0PSJmTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjNzAzNmVmYy1kZDk1LTQ0ZjUtYmIyNy02ZmVmYTk5OGNkYzIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPig4MC05OCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U0MiIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImNmNTVhMmQ2LTQwMGYtNGJhMC1iYTVlLWU0NzI2NWEwYjhhNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgV0lUSCBESUZGRVJFTlRJQUwvUExBVEVMRVQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMTM4ZWEyYTgtOWNlMy00MGYyLWFlMmItMjcyMzRlMmM4ZGEzIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OC02IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzg1LTYiIGRpc3BsYXlOYW1lPSJNQ0giIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb240MyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyOC42IiB1bml0PSJwZyIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI3ODI3MjMyZC1mOGFkLTRkOWEtODdhNy1jMTRkMTgzYTNmODMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigyNy4wLTM0LjApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNDMiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI3YTE2YzgzZi1kNmQwLTQ1YTItYjI4ZS1mMGJlOWMwNmIxMzYiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIFdJVEggRElGRkVSRU5USUFML1BMQVRFTEVUIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjcwMTkzMGRhLTAxMjctNDE4ZC1hYTQ5LTQ4MWZhMmI2MzY0NyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzgtNyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc4Ni00IiBkaXNwbGF5TmFtZT0iTUNIQyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQ0IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjMzLjIiIHVuaXQ9ImcvZEwiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNWZkYWZhMWMtZGI5NC00MWIwLTg2MDQtYzhhMzU3ZWU0YzY1IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMzIuMC0zNi4wKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTQ0IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYjdiNTdmZjUtZDExZC00NzA4LTgyNzQtNzY0ODNmNmNkOGY3IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI5MDFjOTY2OS1lMTMwLTQ3ZWYtYWJkOC05ZjMyNGU3ZGE5NDEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTEwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzcwLTgiIGRpc3BsYXlOYW1lPSJQb2x5cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQ1IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjU3IiB1bml0PSIlIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjdjYmVkYjkxLTE5ZGItNGIyYi04MGRiLTkyOTVmOGI5OGIxOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDQwLTc0KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTQ1IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNjhlZDE2MzYtY2RhNC00MjFjLWI2YjgtODBlMTIwNTQxMjUwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIzOTgzM2RmYy1lMGZiLTQ2MTItOTczYy00MmM1NzljYTVkYzkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTExIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzM2LTkiIGRpc3BsYXlOYW1lPSJMeW1waHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb240NiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyOSIgdW5pdD0iJSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmYjAzNTNjNi1iNDc3LTQ3NTMtOGQyZi04MzIyNTdmMWQyNGUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxNC00Nik8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U0NiIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImU4YWNiMGExLWZiMjktNDdlNC05NjcyLTRkM2NjOTFjZTEyZiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgV0lUSCBESUZGRVJFTlRJQUwvUExBVEVMRVQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYjIyZDYxNzktZTcxMC00Y2E0LWFkNjctNmRmM2NlMDVhZjcxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OC0xMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjU5MDUtNSIgZGlzcGxheU5hbWU9Ik1vbm9jeXRlcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQ3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjExIiB1bml0PSIlIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjVjYTRhNGU3LWRhOGQtNDMxNC05Y2Q0LTE5MDVhZGRiNzA4YSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDQtMTMpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNDciIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIwNjhjMGMxZi1jMTk5LTQ1MjctOTg4ZS1iNTgwYTNkNDNkNGQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIFdJVEggRElGRkVSRU5USUFML1BMQVRFTEVUIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjFhYTBmZTJlLTA1MTEtNDc5Ni04ZjNkLTZiMzcwNDA0MzE0NiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzgtMTMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MTMtOCIgZGlzcGxheU5hbWU9IkVvcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQ4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjMiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYTgzN2RjMWItMjg5Mi00ZDAzLWIxZGUtZjE2OTIxOTY1YzdhIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMC03KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTQ4IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMGUzOTc2YjAtZGY5Zi00YmRiLWFkN2ItMWY4NmJiMWE1ZDU5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0ZTk2MWI5MC0yZDNhLTRjODctODI2ZC0yMjdlNjNiYjU2YmMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTE0IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzA2LTIiIGRpc3BsYXlOYW1lPSJCYXNvcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQ5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjAiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNzc0ZTg1ODQtNGRkNC00MTM1LWJhMzQtYjEzMmZmYmE2ZDU2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMC0zKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTQ5IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOGUzZTE1YzctNWJjMS00OTZkLThhN2UtNWUyZmYyMjhkNWU5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0M2FmNTU5Yy00NmRlLTQ4MzctODQzOC04YmIzZWMyMDg0ZjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3NzctMyIgZGlzcGxheU5hbWU9IlBsYXRlbGV0cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjUwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjI1OCIgdW5pdD0iWF8xMC0zL3VMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImI1Y2I0Mzg4LTgzZTYtNGMxYy1hYjQ0LWEzZDRkZDEwZjRhZSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDE0MC00MTUpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNTAiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0ZjNhYmEwMC05M2NjLTQyMmQtODU4NC1iNjliMWE1ODI2ZjQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIFdJVEggRElGRkVSRU5USUFML1BMQVRFTEVUIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjA3N2JjYTBkLTczYzgtNDE2Mi04ZGRiLWQ1NzcxM2NkMTM2MCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzgtMjAiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIxODMxNC01IiBkaXNwbGF5TmFtZT0iSGVtYXRvbG9neSBDb21tZW50czoiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241MSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+Ti9BPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYzQxZmZkZjQtYjc1NS00MDhkLTg2NDAtZDQxZTZiNzc5MmYwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImVjMzg1MTc3LTg0YzMtNDE2ZS05OGYwLTY5M2I0NTYyYzYyNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgV0lUSCBESUZGRVJFTlRJQUwvUExBVEVMRVQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzgtMTUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3NTEtOCIgZGlzcGxheU5hbWU9IlBvbHlzIChBYnNvbHV0ZSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241MiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIzLjAiIHVuaXQ9IlhfMTAtMy91TCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmOTgxNGJmZi05OWM2LTQyNDctOTc5YS05MjdkNmEwNzBhYjMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxLjgtNy44KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTUyIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYjEwMTU1ODgtZDViMi00NGE4LWIwODItNzFiYmE5OGFkNjk4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJlN2I1MjhhZS1kZDQ2LTQyZGItYjAyZS1hYzRmZjEyYTdiNTkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTE2IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzMxLTAiIGRpc3BsYXlOYW1lPSJMeW1waHMgKEFic29sdXRlKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjUzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjEuNSIgdW5pdD0iWF8xMC0zL3VMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImM3ZDRlYTE1LTM0YTAtNDUwYS1iOWUwLWMyMjJiNzg3ZjI4NCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDAuNy00LjUpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNTMiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyNWRlOGI4OS1jNWUxLTQ3MzktYTZiNS04YTVmNGE0ZjUwZWYiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIFdJVEggRElGRkVSRU5USUFML1BMQVRFTEVUIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImMxODAwNmIzLTUwYTYtNDdmYS1hMWM0LWM0YTQ0OWUxYTYyZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzgtMTciIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3NDItNyIgZGlzcGxheU5hbWU9Ik1vbm9jeXRlcyhBYnNvbHV0ZSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241NCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIwLjYiIHVuaXQ9IlhfMTAtMy91TCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI2OTdmYjg5YS02ZGI0LTQ0NWEtYTcwNC1mZDQwNDc1OGE0MTAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigwLjEtMS4wKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTU0IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYzU0ZjM4MjMtYjJlYS00OGRhLWExZDEtYThmMWUxMWVjYWVjIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyBXSVRIIERJRkZFUkVOVElBTC9QTEFURUxFVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmNDQ4OWZmNC01OTRlLTQ3OGMtOWZkZC1iOGYyZGY2YjI0MDAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc4LTE4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzExLTIiIGRpc3BsYXlOYW1lPSJFb3MgKEFic29sdXRlIFZhbHVlKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjU1IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjAuMiIgdW5pdD0iWF8xMC0zL3VMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjM1NTAwMmVmLWJiMzYtNDVmZi05ZTk3LWYzZWVlN2M2MzA1OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDAuMC0wLjQpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNTUiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI3ZDRjYjZkZi03MWUxLTQzMjYtYmY0ZC02NzVkYjRjODJjNzEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIFdJVEggRElGRkVSRU5USUFML1BMQVRFTEVUIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjVhZmJiZWNlLWFhMGQtNDJmNi1hY2ZlLWI2ZWM5NDRiYmE5ZiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzgtMTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MDQtNyIgZGlzcGxheU5hbWU9IkJhc28oQWJzb2x1dGUpIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNTYiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMC4wIiB1bml0PSJYXzEwLTMvdUwiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOGYwZmE5OWEtYjg0OS00ZTJkLThlZTEtYjZmZmIyODBmYjI3IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMC4wLTAuMik8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U1NiIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjhiMWRlNTBkLTBkOGItNDI0Mi04OTNkLTU2YTU0ZjYxZGJiNyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgV0lUSCBESUZGRVJFTlRJQUwvUExBVEVMRVQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzgiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMTk3NmIxODktNTk2MC00MTFhLWFmYTMtNTQ4YmJlMWEzZDRiIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OC04IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzg4LTAiIGRpc3BsYXlOYW1lPSJSRFciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIxNC44IiB1bml0PSIlIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI2OTUxMzM2OC0wYjFmLTRhMGUtOTI0OC01YzMzMDRkOTg3YmIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxMS43LTE1LjApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNTciIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI5MDMzNWUyMy1mZGJkLTRkMWQtYjU5NC03NzFlYjZkYzhjMGQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIFdJVEggRElGRkVSRU5USUFML1BMQVRFTEVUIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjFlM2E5MzIyLWYwNTYtNDBiMi05OTA0LWFkNWFkMjZmZDJhNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICA8L29yZ2FuaXplcj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeT4NCiAgICAgICAgICAgIDxvcmdhbml6ZXIgY2xhc3NDb2RlPSJCQVRURVJZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPcmdhbml6ZXIiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4xIiBleHRlbnNpb249IjE3OSIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgZGlzcGxheU5hbWU9IkhGUDcrM0FDIj4NCiAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNzEzODgwMDIiIGRpc3BsYXlOYW1lPSJQcm9jZWR1cmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgPHNwZWNpbWVuIHR5cGVDb2RlPSJTUEMiIG51bGxGbGF2b3I9Ik5JIj4NCiAgICAgICAgICAgICAgICA8c3BlY2ltZW5Sb2xlIGNsYXNzQ29kZT0iU1BFQyIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgIDwvc3BlY2ltZW4+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQVVUIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iUkVTUCI+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJWUkYiPg0KICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDA3MTEwNSIgLz4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzktMTAiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIyMDkzLTMiIGRpc3BsYXlOYW1lPSJDaG9sZXN0ZXJvbCwgVG90YWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb241OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyMjAiIHVuaXQ9Im1nL2RMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9IkgiIGRpc3BsYXlOYW1lPSJIaWdoIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZmMzM2U0N2YtMDczMi00OTVkLWEwMzQtZGUzMDM0NzVjMTY2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC42NCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBDb21tZW50IEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY3LTgiIGRpc3BsYXlOYW1lPSJBbm5vdGF0aW9uIGNvbW1lbnQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2NvbXBvbmVudDJ0ZXN0NTgiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxMDAtMTk5KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTU4IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYTQ5NzBhMDQtM2NjMy00MjBkLWJiMGYtNmYzMDNmMTYxMjJjIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkhGUDcrM0FDIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImYwYzllZmQ2LWY4NjQtNGVhYi1hYmI3LTAzMzE0N2E4ZDBkYiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzktMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjI4ODUtMiIgZGlzcGxheU5hbWU9IlByb3RlaW4sIFRvdGFsLCBTZXJ1bSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjU5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjYuMyIgdW5pdD0iZy9kTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iODhjNTlkNzEtZjliNi00Mjk1LTg4NjQtZTc4MDEyNDMwZWMwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oNi4wLTguNSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U1OSIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImZkYjk1OWMxLTk4NTktNDY1OC1hMzE5LTA0MWUwNTU5ZjFmZiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJIRlA3KzNBQyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE3OSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjNmY4OGQwMS05MTQ1LTQ4MzgtYjhlNy0zMWIyY2NiNjhiMGIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTc5LTIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIxNzUxLTciIGRpc3BsYXlOYW1lPSJBbGJ1bWluLCBTZXJ1bSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjYwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjMuNyIgdW5pdD0iZy9kTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmNzgwZDFhZC01ZGY1LTRlODYtOThiOC0yYzE3Mjg3MmRhNmMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigzLjYtNC44KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTYwIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iODQ2YWNmN2QtMDYwYS00N2E5LTk3YzEtNDdjODNiZDUyNDM0IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkhGUDcrM0FDIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImM4NTlkMjQzLWFmZTItNDAxNC05NzViLWYxNjAyNjk4NDZiYyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzktMyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjE5NzUtMiIgZGlzcGxheU5hbWU9IkJpbGlydWJpbiwgVG90YWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb242MSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIwLjgiIHVuaXQ9Im1nL2RMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIwOWQ2OWVjLTQyOGUtNDMxNS05YzIwLWE3YzlhNmRiZjIzOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDAuMS0xLjIpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNjEiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyNzY5MzBlZC00YjBjLTRjZGUtOGYwNy03NTFlMGFlODVjNzIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iSEZQNyszQUMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDE1ZjE5YjctNTIxNy00NTY3LWJmOTMtNWZhNGVlNzRlNDYzIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OS01IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTI4MDUtOCIgZGlzcGxheU5hbWU9IkFsa2FsaW5lIFBob3NwaGF0YXNlLCBTZXJ1bSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjYyIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjE0MiIgdW5pdD0iSVUvTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI4YTk2ZWNlYS02OGE3LTRkNzYtYTRjNS1mYjFlYTUxMDY0YmIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigyNS0xNjUpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNjIiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI1MTE3YjFiYS05Zjk3LTRlMjMtOTBjYy01YTg3YTY2NWU0YzUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iSEZQNyszQUMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNTMzNTMzNzgtOWExZi00MjQxLTk1NDMtZjhjNDJjOTJjOWM1IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OS02IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMjUzMi0wIiBkaXNwbGF5TmFtZT0iTERIIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNjMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMTA4IiB1bml0PSJJVS9MIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImE4MDg3ODBlLTkxZDYtNGQ1Zi05ZDYyLWRhMjNhNDNjNjg2YyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDEwMC0yNTApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNjMiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI5MWRjZTVkYi04OGI4LTQ5NmItYmE4MS0zMWFiNDY1NzExOWUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iSEZQNyszQUMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYjk3Y2ExZDYtODgxYi00MzM5LWEwMmYtOGU1MDJlMWFiZWJiIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OS03IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTkyMC04IiBkaXNwbGF5TmFtZT0iQVNUIChTR09UKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjY0IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjI3IiB1bml0PSJJVS9MIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImRmNWQ1NjY4LThiZWYtNGY3Ni04ZTkxLTkyNjIyYWY4ZTc2YyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDAtNDApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNjQiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJhMzVhM2NjZi03YjYyLTQ3ODYtYmZlOS01MzgxZmY0YmMyYTciIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iSEZQNyszQUMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDc1NTg0ZTMtYjNhMS00MjVkLWE1ZjItZWEzYjEzNThkYmM2IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE3OS00IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTUxNTItMiIgZGlzcGxheU5hbWU9IkJpbGlydWJpbiwgRGlyZWN0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNjUiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMC4zMSIgdW5pdD0ibWcvZEwiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNTkzMTlkOGEtMGNkYi00NDliLTk3N2YtNGVhYzEzYWY0ZDI0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMC4wMC0wLjQwKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTY1IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYzE0MTZmM2YtMjU3Yy00MDgzLWE3NzMtNTQ2ZDViZTkxY2M3IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkhGUDcrM0FDIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImM0ZjQyZjMyLWI3YjAtNGQyNC1hYjJkLWNjZDhjNjJlYmU0MyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzktOCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjE3NDItNiIgZGlzcGxheU5hbWU9IkFMVCAoU0dQVCkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb242NiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTEwMjE1MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyMyIgdW5pdD0iSVUvTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJlMjAzNDY1MS0xZGYzLTRhNWYtYmQ0My05ZWU3ZDViM2EyZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigwLTQwKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTY2IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOTExMjYyYzMtZmFmOS00Y2IwLTgwOTQtYjYwOTI4MTcyNzI2IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkhGUDcrM0FDIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTc5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjY3NGE1YjI0LTRjNmEtNDk5My04YTIxLTE4ZDliN2VmYjdkNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNzktOSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjIzMjQtMiIgZGlzcGxheU5hbWU9IkdHVCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjY3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMTAyMTUwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjM2IiB1bml0PSJJVS9MIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjEzNDFmOTkyLWZkMTMtNGZmZS1hMTFjLWIxY2NmZTdkMmZmNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDAtNjApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNjciIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJkYWRjZjg3MS05NjQ3LTQ2MTktYjQ5Ni1lOTZmMTU2NjFiNTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iSEZQNyszQUMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNzkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzExMDIxNTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMGY0NGRjNmQtMDkxYy00N2E4LWFkMDQtNjM4ZWUxY2Q1N2M3IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgIDwvb3JnYW5pemVyPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5Pg0KICAgICAgICAgICAgPG9yZ2FuaXplciBjbGFzc0NvZGU9IkJBVFRFUlkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjEiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9yZ2FuaXplciIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjEiIGV4dGVuc2lvbj0iMTYwIiAvPg0KICAgICAgICAgICAgICA8Y29kZSBkaXNwbGF5TmFtZT0iVEhZUk9JRCBQQU5FTCBXSVRIIFRTSCI+DQogICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjcxMzg4MDAyIiBkaXNwbGF5TmFtZT0iUHJvY2VkdXJlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMDA1MDkwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgIDxzcGVjaW1lbiB0eXBlQ29kZT0iU1BDIiBudWxsRmxhdm9yPSJOSSI+DQogICAgICAgICAgICAgICAgPHNwZWNpbWVuUm9sZSBjbGFzc0NvZGU9IlNQRUMiIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICA8L3NwZWNpbWVuPg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkFVVCI+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4zIiBleHRlbnNpb249IjM2IiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IlJFU1AiPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iVlJGIj4NCiAgICAgICAgICAgICAgICA8dGltZSB2YWx1ZT0iMjAwNzEwMDgiIC8+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4zIiBleHRlbnNpb249IjM2IiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMTYwLTIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMDI2LTIiIGRpc3BsYXlOYW1lPSJUaHlyb3hpbmUgKFQ0KSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjY4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMDA1MDkwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjUuMSIgdW5pdD0ibWNnL2RMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIxZDY2Y2RhNi1mODY1LTRkZmUtYjEwYy0wZjljOTJmYmQ5NTkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjY0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIENvbW1lbnQgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNDg3NjctOCIgZGlzcGxheU5hbWU9IkFubm90YXRpb24gY29tbWVudCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjY29tcG9uZW50M3Rlc3Q2OCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDQuNS0xMi4wKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTY4IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYzAxZGQyM2QtNTMzMS00YmNmLTg4ZDctM2QyYjljZjg1ZDQ2IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IlRIWVJPSUQgUEFORUwgV0lUSCBUU0giIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjAiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjAiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYzg1OTkwMzAtNTM3ZS00NzgyLWI4ODgtZDQ3NTVlMzEwZGY5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE2MC0zIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzA1MC0yIiBkaXNwbGF5TmFtZT0iVDMgVXB0YWtlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNjkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMzEiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijg3ZTQzMzA4LTM5ODQtNDExYi05NjI3LTQzMTkzNjUzNmFlMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDI0LTM5KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTY5IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOTMxMDkyN2UtYTY2MS00NDU5LWI4ZmEtNGRjNTRkZTU2ZjY0IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IlRIWVJPSUQgUEFORUwgV0lUSCBUU0giIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjAiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjAiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDFlNTUzMWYtYzYzYS00YTIwLWExNGMtMWE1ZjEwZDg3NzVlIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE2MC00IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzAyMi0xIiBkaXNwbGF5TmFtZT0iRnJlZSBUaHlyb3hpbmUgSW5kZXgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243MCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTAwNTA5MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIzLjIiIHVuaXQ9IjEiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjU1MDkyNGIzLTI0MGUtNDVkZS05ZmE1LWY0YWQyYzM4MDI1MCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxLjItNC45KTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTcwIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNTM5ODk3OGMtZjllMC00NjM4LWE1YTQtM2Y1NDgzYjU2OTA4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IlRIWVJPSUQgUEFORUwgV0lUSCBUU0giIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjAiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjAiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNjAtMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjExNTc5LTAiIGRpc3BsYXlOYW1lPSJUU0gsIEhpZ2ggU2Vuc2l0aXZpdHksIFNlcnVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNzEiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNC4yMSIgdW5pdD0ibWNJVS9tTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZTgwZjY5YWMtYTdjMC00MDMzLWIzZDEtZDAzZDBiZTk4MTk1IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC42NCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBDb21tZW50IEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY3LTgiIGRpc3BsYXlOYW1lPSJBbm5vdGF0aW9uIGNvbW1lbnQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2NvbXBvbmVudDN0ZXN0NzEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigwLjM1LTUuNTApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNzEiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI3NTgzNzM1OC1lMDdhLTQzNmEtOWUwMy03YmNkOTQ4MjVhODAiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iVEhZUk9JRCBQQU5FTCBXSVRIIFRTSCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE2MCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE2MCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTAwNTA5MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0ZjIyMzc0Zi03Y2QyLTQ5ZmEtOGFjYS0xNWMxMjdmY2JhNGEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgPC9vcmdhbml6ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnk+DQogICAgICAgICAgICA8b3JnYW5pemVyIGNsYXNzQ29kZT0iQkFUVEVSWSIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT3JnYW5pemVyIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMSIgZXh0ZW5zaW9uPSIxNjEiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGRpc3BsYXlOYW1lPSJDbCtLK05hIj4NCiAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNzEzODgwMDIiIGRpc3BsYXlOYW1lPSJQcm9jZWR1cmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgPHNwZWNpbWVuIHR5cGVDb2RlPSJTUEMiIG51bGxGbGF2b3I9Ik5JIj4NCiAgICAgICAgICAgICAgICA8c3BlY2ltZW5Sb2xlIGNsYXNzQ29kZT0iU1BFQyIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgIDwvc3BlY2ltZW4+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQVVUIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iUkVTUCI+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJWUkYiPg0KICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDA3MTAwOCIgLz4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNjEtMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjI4MjMtMyIgZGlzcGxheU5hbWU9IlBvdGFzc2l1bSwgU2VydW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243MiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTAwNTA5MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI0LjEiIHVuaXQ9Im1tb2wvTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDQ2ODU2ZTQtZGE0Ny00MWVjLTkyNzMtY2U0NzA3NmVhNzNmIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMy41LTUuNSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U3MiIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjM4MjljYTk4LWUxNDEtNDJkNS1iZmMzLTlhMGIwOTQ4Njc2ZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDbCtLK05hIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTYxIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTYxIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMDA1MDkwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImI1OGNlNDEyLWNlNWUtNGFkYS04ZTUyLWE5MGZlNjM3ZjhkZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNjEtMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjI5NTEtMiIgZGlzcGxheU5hbWU9IlNvZGl1bSwgU2VydW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243MyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTAwNTA5MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIxMzkiIHVuaXQ9Im1tb2wvTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNzI0NmZjYTgtNjQzZC00OTE0LTkxNDMtODY3YjQxNzE1ZmExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC43IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMTM1LTE0OCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U3MyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImQxYTU1MjUxLTQ2MzAtNGNiYy1iYjk0LWY5MDEwYzg5OGRiMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDbCtLK05hIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTYxIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMTYxIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMDA1MDkwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijg3NDcwMDZlLWZhM2ItNDQwOS1hZjMwLWY2MTU5OGVkYzY5OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuNCIgZXh0ZW5zaW9uPSIxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIxNjEtMyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjIwNzUtMCIgZGlzcGxheU5hbWU9IkNobG9yaWRlLCBTZXJ1bSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjc0IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcxMDA1MDkwMDAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjEwMSIgdW5pdD0ibW1vbC9MIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmZjQwM2UxNi1hOWRmLTQzZWUtYTk5ZC1jNmVhMGI4NDJmMWUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPig5Ni0xMDkpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNzQiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0YTRlZjlmZC1kYTgxLTQ1MTgtODlhMy03N2Q4YjIyOTNiY2IiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ2wrSytOYSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE2MSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjE2MSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTAwNTA5MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyMTJhZWM4Ny1mMjRjLTRmMDItYjY3Zi1kMzg2MWMyYWNjNTQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjQiIGV4dGVuc2lvbj0iMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1BPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgPC9vcmdhbml6ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnk+DQogICAgICAgICAgICA8b3JnYW5pemVyIGNsYXNzQ29kZT0iQkFUVEVSWSIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT3JnYW5pemVyIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMSIgZXh0ZW5zaW9uPSIxNjIiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGRpc3BsYXlOYW1lPSJSUFIiPg0KICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI3MTM4ODAwMiIgZGlzcGxheU5hbWU9IlByb2NlZHVyZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MTAwNTA5MDAwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICA8c3BlY2ltZW4gdHlwZUNvZGU9IlNQQyIgbnVsbEZsYXZvcj0iTkkiPg0KICAgICAgICAgICAgICAgIDxzcGVjaW1lblJvbGUgY2xhc3NDb2RlPSJTUEVDIiBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgPC9zcGVjaW1lbj4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJBVVQiPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJSRVNQIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IlZSRiI+DQogICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcxMDA4IiAvPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSIzNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjE2Mi0xIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTI5Mi04IiBkaXNwbGF5TmFtZT0iUlBSIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNzUiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB4c2k6dHlwZT0iU1QiPk5vbi1SZWFjdGl2ZTwvdmFsdWU+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJhNGFlZDNjZC03YTE2LTQxMjctYTYzZi00NzkwNWJlODc1ZTIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjciIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjY0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIENvbW1lbnQgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNDg3NjctOCIgZGlzcGxheU5hbWU9IkFubm90YXRpb24gY29tbWVudCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjY29tcG9uZW50NXRlc3Q3NSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KE5vbi1SZWFjdGl2ZSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U3NSIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjQwYTk1YzE2LTFjZWItNGE3Yi1iMmJkLWM3ZjhiZjY3NzFkOCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJSUFIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjIiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24xNjIiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzEwMDUwOTAwMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNGFlZTZmMGQtNzlkMi00YzRlLWFmZjMtNDBlMmE0ZGI3NjY3IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS40IiBleHRlbnNpb249IjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgIDwvb3JnYW5pemVyPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5Pg0KICAgICAgICAgICAgPG9yZ2FuaXplciBjbGFzc0NvZGU9IkJBVFRFUlkiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjEiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9yZ2FuaXplciIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjEiIGV4dGVuc2lvbj0iNDkzIiAvPg0KICAgICAgICAgICAgICA8Y29kZSBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCI+DQogICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjcxMzg4MDAyIiBkaXNwbGF5TmFtZT0iUHJvY2VkdXJlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgIDxzcGVjaW1lbiB0eXBlQ29kZT0iU1BDIj4NCiAgICAgICAgICAgICAgICA8c3BlY2ltZW5Sb2xlIGNsYXNzQ29kZT0iU1BFQyI+DQogICAgICAgICAgICAgICAgICA8c3BlY2ltZW5QbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJCTEQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjEyLjcwIiBjb2RlU3lzdGVtTmFtZT0iU3BlY2ltZW4gU291cmNlIiBkaXNwbGF5TmFtZT0iV2hvbGUgYmxvb2QiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPldob2xlIGJsb29kPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9zcGVjaW1lblBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9zcGVjaW1lblJvbGU+DQogICAgICAgICAgICAgIDwvc3BlY2ltZW4+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQVVUIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iUkVTUCI+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJWUkYiPg0KICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDA4MDEwOCIgLz4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iMzYiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjY2OTAtMiIgZGlzcGxheU5hbWU9IldoaXRlIEJsb29kIENlbGwgKFdCQykgQ291bnQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24wIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjUuOCIgdW5pdD0iVEhPVVMvTUNMIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjMTU3ZGFmNi1hODg2LTQzZTgtODU1YS02MmYzMGM5MzdiYjUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMy44LTEwLjgpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMCIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImEyMDNlYWMzLTQzNmMtNDk2MS1hMTA2LTNhYmM0MTA3YTYxNCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDkzLTIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3ODktOCIgZGlzcGxheU5hbWU9IlJlZCBCbG9vZCBDZWxsIChSQkMpIENvdW50IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uMSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI0LjIwIiB1bml0PSJNSUxML01DTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMGU3ZDM4ZmQtNDI4NC00ZGQzLTk3YWQtNTQzODIzYjkzZTJkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDMuODAtNS4xMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UxIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDRhYzlhYWUtYTc1My00Y2E4LWE2NWEtM2I2NWU5NTM4NzY2IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtNCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjcxOC03IiBkaXNwbGF5TmFtZT0iSGVtb2dsb2JpbiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjIiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMTEuNyIgdW5pdD0iRy9ETCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYWJhMzMxMGMtODNjMC00Y2U0LWE0NTMtM2UyN2VkODkxZDU4IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDExLjctMTUuNSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UyIiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDdjN2JhZjktNDUzOC00ZTk3LThkNzktYzdlMGIzZTllZWUwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ1NDQtMyIgZGlzcGxheU5hbWU9IkhlbWF0b2NyaXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24zIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjM2LjIiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijg4MzNiYmMyLTg0NDItNGI4NS04N2U4LWEwZWNhMjY5MjRiMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigzNS4wLTQ1LjApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijk1YTRkNWQxLThhYTctNGJiNy05MmM3LTE2OThiNTc2ZjkxNCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDkzLTMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3ODctMiIgZGlzcGxheU5hbWU9Ik1DViIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjQiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iODYuMSIgdW5pdD0iRkwiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjYwODcxMjc1LWQ3MTMtNDQwNy05NGY3LThjZGMwM2E2NTc1MSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPiguMC0xMDAuMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U0IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYWYzZGE0MGEtZWEyYi00YWUyLTk4MjYtNjEzZjI5ZTM0Njg4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc4NS02IiBkaXNwbGF5TmFtZT0iTUNIIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIyOC4wIiB1bml0PSJQRyIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYzUyZjY0YjUtYzE5Zi00ZGM2LTliMTAtODIwMzllZmRiNGI5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDI3LjAtMzMuMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U1IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iY2Q4YzFmZjMtZGE0OS00NjZjLWFjYzYtZDcxYWU5ZDc3MGU5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtNyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc4Ni00IiBkaXNwbGF5TmFtZT0iTUNIQyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjYiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iMzIuNSIgdW5pdD0iRy9ETCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZmMyMmM3ZDEtODI1Yi00ZWY3LWE2NDYtYmI2N2FlMjUzOWI1IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDMyLjAtMzYuMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U2IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYjEyZTkzYWMtMTU3MC00YWY4LWJiYjgtZjI0Y2IwZDcxMjlmIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtOSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc3MC04IiBkaXNwbGF5TmFtZT0iUG9seXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjUxLjEiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjgxYmVhZGMxLTAwMjctNDQzNi04ZTI0LTlhYWFhNmI1YWFiNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJkZDk5ZTRlMS02ZTFkLTQ1ZmUtOTIyOS1jOGI3NTU4YTc3NGEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5My04IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzM2LTkiIGRpc3BsYXlOYW1lPSJMeW1waHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjMxLjgiIHVuaXQ9IiUiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjdhY2ZkODY4LTA4NGMtNDZjZS05OWJhLWE5OTg5OGM5MzIzNyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIwZGYyYTVhOC01OWU4LTQ4MDMtOWJkNi00ZTIyZjAzZmY1YjAiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5My0xMCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjU5MDUtNSIgZGlzcGxheU5hbWU9Ik1vbm9jeXRlcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iOS4xIiB1bml0PSIlIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI4MTBjNDJlZC0xOGU4LTRiNDEtOTE3OS01OTJmMTkwOTdlMmUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDEwNTViMWQtMjM1Ny00Yjg5LTk3MTYtYjIzYzVkMzE5MmRlIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtMTEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3MTMtOCIgZGlzcGxheU5hbWU9IkVvcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjEwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjcuMiIgdW5pdD0iJSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZWVlNGNjODEtMmVjZi00YThlLWI0NGEtYmVmN2NhMWJhNzIzIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjJkNzYwMTY3LTEyZTgtNGZiNi05MTc5LTFmMDk3Njg3NjZmYyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDkzLTEyIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzA2LTIiIGRpc3BsYXlOYW1lPSJCYXNvcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjExIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjAuOCIgdW5pdD0iJSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDE0NDY3N2MtNWMzNi00ZmE4LWEwZmMtNjA1YmIyY2ZlYmU0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjMzZDlhZTc0LTk3NDItNDBlMy04YjRhLWE4MDU0ZjQzY2I0NCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDkzLTEzIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzc3LTMiIGRpc3BsYXlOYW1lPSJQbGF0ZWxldHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xMiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIzNTQiIHVuaXQ9IlRIT1VTL01DTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iOWZhZDMxN2EtYTIxYy00YzI2LWJkN2UtZTFmMTZjNGIxYmUyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDE0MC00MDApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMTIiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI5ODRjYWY3MS1hNjA3LTRiYmMtODBlZS02MWNhOWM4YzhkZDciIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5My0xNCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijc1MS04IiBkaXNwbGF5TmFtZT0iUG9seXMgKEFic29sdXRlKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjEzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjI5NjQiIHVuaXQ9IkNFTExTL01DTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDFiOTQwMzItZmE4ZC00MTNhLTkzOWEtYjc1OTBmNWUyYTJmIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDE1MDAtNzgwMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UxMyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijc5NmI3NGI1LTg2OTEtNGY2Zi05MDlmLTM3YWM1ZjFiZmU2MSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDkzLTE1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzMxLTAiIGRpc3BsYXlOYW1lPSJMeW1waHMgKEFic29sdXRlKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjE0IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjE4NDQiIHVuaXQ9IkNFTExTL01DTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNTdmOWVlM2QtZTE3MC00N2FkLTk3YTItNTg3ZmViNDMxYjU5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDg1MC0zOTAwKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTE0IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYmJmNTRiNTgtNjE5Yi00MzkxLWFiNmQtZWE5MGE2YmFjMjJjIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSI0OTMtMTYiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI3NDItNyIgZGlzcGxheU5hbWU9Ik1vbm9jeXRlcyhBYnNvbHV0ZSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xNSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI1MjgiIHVuaXQ9IkNFTExTL01DTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iY2JjOGRlOTItYTE1Mi00ZGYwLWE4YTgtMDk3ODkwMTMzYzJmIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDIwMC05NTApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlMTUiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJhYWEwYWQxZS1hY2YxLTQ4Y2YtYjFhZi05ODMwYTUzZTI4MmIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ0JDIHcvIERpZmZlcmVudGlhbCAmYW1wOyBQbGF0ZWxldCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjQ5MyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjQ5My0xNyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjcxMS0yIiBkaXNwbGF5TmFtZT0iRW9zIChBYnNvbHV0ZSBWYWx1ZSkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xNiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSI0MTgiIHVuaXQ9IkNFTExTL01DTCIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNzUwYTIzZGMtZjU5My00NjQ2LTg0NDEtZmZkODkzZmZkYjM3IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkxhYkNvcnAgTWFkaXNvbjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS0wMzA2IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjE0NDcgWW9yayBDb3VydDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDE1LTUwMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UxNiIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjY0NzVjOGFmLTkxMzQtNGI3OC1hZmY4LTdlZmVlMmMwYTkwZiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDkzLTE4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzA0LTciIGRpc3BsYXlOYW1lPSJCYXNvKEFic29sdXRlKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Rlc3RSZXN1bHRDb21wb25lbnREZXNjcmlwdGlvbjE3IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjQ2IiB1bml0PSJDRUxMUy9NQ0wiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjI3YTFiZDkzLTY1M2EtNDY1Yy04NzlkLTc5OWJiYWY4NWZjMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5MYWJDb3JwIE1hZGlzb248L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMDMwNiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xNDQ3IFlvcmsgQ291cnQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigwLTIwMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2UxNyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjE5ZjgyNjMzLTk4MzctNGQzNC1iNzQ3LWY4ZGRlYmY4N2I5MCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJDQkMgdy8gRGlmZmVyZW50aWFsICZhbXA7IFBsYXRlbGV0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uNDkzIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAxNTAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iNDkzLTE5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNzg4LTAiIGRpc3BsYXlOYW1lPSJSRFciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb24xOCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMTUwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIxMy40IiB1bml0PSIlIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJkYjQ0ZTQ1Yy0zZTY1LTQ2YmEtYjNiMS0wYzE2MzZlMjY3NjYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TGFiQ29ycCBNYWRpc29uPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTAzMDYiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTQ0NyBZb3JrIENvdXJ0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMTEuMC0xNS4wKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTE4IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMDNiYjQxNzYtZmRkNC00OWNkLTlkMTQtNTIyMTU2NTEyYTc5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkNCQyB3LyBEaWZmZXJlbnRpYWwgJmFtcDsgUGxhdGVsZXQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb240OTMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDE1MDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICA8L29yZ2FuaXplcj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeT4NCiAgICAgICAgICAgIDxvcmdhbml6ZXIgY2xhc3NDb2RlPSJCQVRURVJZIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPcmdhbml6ZXIiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4xIiBleHRlbnNpb249IjMwOCIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgZGlzcGxheU5hbWU9IkhlbWF0b2NyaXQiPg0KICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI3MTM4ODAwMiIgZGlzcGxheU5hbWU9IlByb2NlZHVyZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgLz4NCiAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICA8c3BlY2ltZW4gdHlwZUNvZGU9IlNQQyI+DQogICAgICAgICAgICAgICAgPHNwZWNpbWVuUm9sZSBjbGFzc0NvZGU9IlNQRUMiPg0KICAgICAgICAgICAgICAgICAgPHNwZWNpbWVuUGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQkxEIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4xMi43MCIgY29kZVN5c3RlbU5hbWU9IlNwZWNpbWVuIFNvdXJjZSIgZGlzcGxheU5hbWU9Ildob2xlIGJsb29kIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5XaG9sZSBibG9vZDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvc3BlY2ltZW5QbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvc3BlY2ltZW5Sb2xlPg0KICAgICAgICAgICAgICA8L3NwZWNpbWVuPg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkFVVCI+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4zIiBleHRlbnNpb249IjQyIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xMTU1NCBXZWVkc2lkZSBMYW5lPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkphbWVzPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+VDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Nb25yb2U8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJSRVNQIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zNCBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTGFib3JhdG9yeTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJWUkYiPg0KICAgICAgICAgICAgICAgIDx0aW1lIHZhbHVlPSIyMDA3MDkwMyIgLz4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iNDIiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjExNTU0IFdlZWRzaWRlIExhbmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+SmFtZXM8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5UPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5Pk1vbnJvZTwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMzA4LTEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iRmVtYWxlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNzYiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDAyMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNDAiIHVuaXQ9IjEiIHhzaTp0eXBlPSJQUSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjdiZTZjMjZlLTgzMGUtNDQwNy04MGViLTIzNTBmM2VlZTI1YiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIxMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTGFib3JhdG9yeTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oMzctNDcpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlNzYiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyNzFhODY4Zi1kY2FiLTQ4ZTgtYjYxNy1mOTFmMmNlMDcxZmQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iSGVtYXRvY3JpdCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjMwOC0yIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9Ik1hbGUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243NyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIwMCIgdW5pdD0iMSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iN2FjNzFjNGQtMzU2Mi00ZmQyLWJlY2ItYmNhMzA1ZTk5ZmM0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPig0MC01NCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U3NyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijg5NDg5ZGUxLWY0YzMtNDk3My04Yjk0LTQ5NTVkM2E1NWQxOSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJIZW1hdG9jcml0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA4IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA4IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwMjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgPC9vcmdhbml6ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnk+DQogICAgICAgICAgICA8b3JnYW5pemVyIGNsYXNzQ29kZT0iQkFUVEVSWSIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT3JnYW5pemVyIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMSIgZXh0ZW5zaW9uPSIzMDkiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGRpc3BsYXlOYW1lPSJVcmluYWx5c2lzIj4NCiAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iNzEzODgwMDIiIGRpc3BsYXlOYW1lPSJQcm9jZWR1cmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDAyMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgPHNwZWNpbWVuIHR5cGVDb2RlPSJTUEMiIG51bGxGbGF2b3I9Ik5JIj4NCiAgICAgICAgICAgICAgICA8c3BlY2ltZW5Sb2xlIGNsYXNzQ29kZT0iU1BFQyIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgIDwvc3BlY2ltZW4+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQVVUIj4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjMiIGV4dGVuc2lvbj0iNDIiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjExNTU0IFdlZWRzaWRlIExhbmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+SmFtZXM8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5UPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5Pk1vbnJvZTwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IlJFU1AiPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyMTIiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IlZSRiI+DQogICAgICAgICAgICAgICAgPHRpbWUgdmFsdWU9IjIwMDcwOTAzIiAvPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMyIgZXh0ZW5zaW9uPSI0MiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MTE1NTQgV2VlZHNpZGUgTGFuZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5KYW1lczwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPlQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIzMDktMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJBcHBlYXJhbmNlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uNzgiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDAyMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB4c2k6dHlwZT0iU1QiPkNsZWFyPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjJjMGU2OThjLWM1YWItNDM4ZC1hMGZiLTdhYjRhNGIzMmRiYyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIxMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTGFib3JhdG9yeTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oQ2xlYXItTW9kIENsb3VkKTxyZWZlcmVuY2UgdmFsdWU9IiNyZXN1bHRSYW5nZTc4IiAvPjwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgPC9yZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iY2Q2NzE5YmUtOWZkOS00YWJiLTk3MzYtYmRhMzRjMmE3ZmJiIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IlVyaW5hbHlzaXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24zMDkiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNsYWJUZXN0RGVzY3JpcHRpb24zMDkiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDAyMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICA8L3Byb2NlZHVyZT4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBSZXN1bHQgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTUuMiIgZXh0ZW5zaW9uPSIzMDktMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJCaWxpcnViaW4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb243OSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+TmVnYXRpdmU8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNmJhNjgyM2EtMmJjZS00Mjk4LWI5MzItMGQyYjMxMThiYzIyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPihOZWdhdGl2ZS1TbWFsbCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U3OSIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImUxMTY3YjFmLTY2ODAtNDViZi1iM2MzLTIzMzcxYjI0NmZhZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJVcmluYWx5c2lzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwMjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMzA5LTMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQmxvb2QiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244MCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+TmVnYXRpdmU8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMGFlMjdjMzUtZWZiNi00YjJhLWE4ODgtYzczMDBlM2QwMzY5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPihOZWdhdGl2ZSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U4MCIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImNkNDljMzNiLTZmNGYtNDgwZS04YzAxLWQ1MTQ5ZDYyOGNmYiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJVcmluYWx5c2lzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwMjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMzA5LTQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iQ29sb3IiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244MSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+WWVsbG93PC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImMwMGFhNWM4LWFjZmYtNDczNy05MGY4LTdiYWU3ZDliM2RiYiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIxMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTGFib3JhdG9yeTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oTm9uZS1ZZWxsb3cpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlODEiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIzMTdiNzViNS1mNDRiLTQyODEtODc1Zi1jMDA4N2JhZDVjZjMiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iVXJpbmFseXNpcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjMwOS01IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkdsdWNvc2UiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244MiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+TmVnYXRpdmU8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZWUzNDk2ZTQtZjg5Yy00OGM5LTk4MzEtMzFkYWJhMDk2MTM3IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPihOZWdhdGl2ZS0yNTApPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlODIiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyMWY4Yzc1Ni0yOWJhLTRmMjYtOWY0Mi1jYzdmZDUxMWE4NmIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iVXJpbmFseXNpcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjMwOS02IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IlNwZWNpZmljIEdyYXZpdHkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244MyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHZhbHVlPSIxLjAwNSIgdW5pdD0iMSIgeHNpOnR5cGU9IlBRIiAvPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNzk5NzI0NjktNTk3Ni00OGZiLWE3ZGItNjAzYTljMDliODIzIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPigxLjAwMC0xLjAxMCk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U4MyIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImJlMGRmNTY4LTViNmUtNDNiNS1hMzM0LWQ3NTVjOGYxYzVlYiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJVcmluYWx5c2lzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwMjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMzA5LTciIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iS2V0b25lIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uODQiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDAyMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB4c2k6dHlwZT0iU1QiPk5lZ2F0aXZlPC92YWx1ZT4NCiAgICAgICAgICAgICAgICAgIDxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgZGlzcGxheU5hbWU9Ik5vcm1hbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIgY29kZVN5c3RlbU5hbWU9Ik9ic2VydmF0aW9uSW50ZXJwcmV0YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjUxYjQ4ZGRhLWVmMGItNGZlNi04OWFlLTM2ODllNDY3MTgzYiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjIxMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTGFib3JhdG9yeTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2VSYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQgeHNpOnR5cGU9IkVEIj4oTmVnYXRpdmUtVHJhY2UpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlODQiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJlY2Y4NWNlZS0zYmU3LTRhYmItYjJmNC1lOWViNzM4NDBkNTIiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iVXJpbmFseXNpcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjMwOS04IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9IkxldWtvY3l0ZXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244NSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+TmVnYXRpdmU8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMTNmMjk1YzMtZjIyYi00Nzg4LTk3NjgtMmYzZTY4ODRhMmZkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPihOZWdhdGl2ZS1UcmFjZSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U4NSIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjU1YzM5ZTc0LWFjOGYtNDUzMy1iYWZmLWUwYjgxYTM1ZjhkMiIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJVcmluYWx5c2lzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwMjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMzA5LTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iTml0cml0ZXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244NiIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+TmVnYXRpdmU8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYjBiNGE4ODItNTJjZi00NzAxLTgzM2YtNTMzY2YwZjkzYzk0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPihOZWdhdGl2ZSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U4NiIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjEyYzJlYjFmLWY3ZWItNGU0Yi05ODBiLWNkYjU3NzkyZTkxYyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJVcmluYWx5c2lzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwMjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUmVzdWx0IE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE1LjIiIGV4dGVuc2lvbj0iMzA5LTEwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LTk9XTiIgZGlzcGxheU5hbWU9InBIIExldmVsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjdGVzdFJlc3VsdENvbXBvbmVudERlc2NyaXB0aW9uODciIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwNzA5MDMxMDAyMDAtMDQwMCIgLz4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSB2YWx1ZT0iNi4wIiB1bml0PSIxIiB4c2k6dHlwZT0iUFEiIC8+DQogICAgICAgICAgICAgICAgICA8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGRpc3BsYXlOYW1lPSJOb3JtYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiIGNvZGVTeXN0ZW1OYW1lPSJPYnNlcnZhdGlvbkludGVycHJldGF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI2ZTMzYzFhMC02YTY0LTQ0ZjgtYTZmMy03NmFmMjRkOTgwMDIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSIyMTIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIExhYm9yYXRvcnk8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zNCBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvblJhbmdlPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHhzaTp0eXBlPSJFRCI+KDUuMC02LjUpPHJlZmVyZW5jZSB2YWx1ZT0iI3Jlc3VsdFJhbmdlODciIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uUmFuZ2U+DQogICAgICAgICAgICAgICAgICA8L3JlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgICA8Y29tcG9uZW50Pg0KICAgICAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJlYWZjZjVjZC0xNmE1LTQzOTMtYWMyZi00OTBmZWNmNTgwN2QiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJVTktOT1dOIiBkaXNwbGF5TmFtZT0iVXJpbmFseXNpcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYlRlc3REZXNjcmlwdGlvbjMwOSIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgICAgICA8L2NvbXBvbmVudD4NCiAgICAgICAgICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4yIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJlc3VsdCBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNS4yIiBleHRlbnNpb249IjMwOS0xMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJVcm9iaWxpbm9nZW4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiN0ZXN0UmVzdWx0Q29tcG9uZW50RGVzY3JpcHRpb244OCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDA3MDkwMzEwMDIwMC0wNDAwIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIHhzaTp0eXBlPSJTVCI+TmVnYXRpdmU8L3ZhbHVlPg0KICAgICAgICAgICAgICAgICAgPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBkaXNwbGF5TmFtZT0iTm9ybWFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIiBjb2RlU3lzdGVtTmFtZT0iT2JzZXJ2YXRpb25JbnRlcnByZXRhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iYmE4ZjcwNzEtY2ViZi00ZWFmLWE4NzAtMGQzMzQyZGJjZWE0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBMYWJvcmF0b3J5PC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZVJhbmdlPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4c2k6dHlwZT0iRUQiPihOZWdhdGl2ZSk8cmVmZXJlbmNlIHZhbHVlPSIjcmVzdWx0UmFuZ2U4OCIgLz48L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb25SYW5nZT4NCiAgICAgICAgICAgICAgICAgIDwvcmVmZXJlbmNlUmFuZ2U+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9jb21wb25lbnQ+DQogICAgICAgICAgICAgIDxjb21wb25lbnQ+DQogICAgICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjQ5ZDg0MzY5LWY0NjgtNDNhMi1iZjM4LTM0NTEwNGI4OGFlMyIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOS05PV04iIGRpc3BsYXlOYW1lPSJVcmluYWx5c2lzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbGFiVGVzdERlc2NyaXB0aW9uMzA5IiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDcwOTAzMTAwMjAwLTA0MDAiIC8+DQogICAgICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgICAgICAgPC9vcmdhbml6ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgPC9zZWN0aW9uPg0KICAgICAgPC9jb21wb25lbnQ+DQogICAgICA8Y29tcG9uZW50Pg0KICAgICAgICA8c2VjdGlvbj4NCiAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjMuNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iSGlzdG9yeSBvZiBQcmVzZW50IElsbG5lc3MgU2VjdGlvbiIgLz4NCiAgICAgICAgICA8aWQgcm9vdD0iMjg3NDAyZDEtZmMxNS00MjkxLTgxOWUtNjRkODZhOTNmNTE4IiAvPg0KICAgICAgICAgIDxjb2RlIGNvZGU9IjEwMTY0LTIiIGRpc3BsYXlOYW1lPSJISVNUT1JZIE9GIFBSRVNFTlQgSUxMTkVTUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgPHRpdGxlPkhpc3Rvcnkgb2YgUHJlc2VudCBJbGxuZXNzPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDxjb250ZW50Pk5vIEhpc3Rvcnkgb2YgUHJlc2VudCBJbGxuZXNzIFJlY29yZGVkPC9jb250ZW50Pg0KICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgPC9zZWN0aW9uPg0KICAgICAgPC9jb21wb25lbnQ+DQogICAgICA8Y29tcG9uZW50Pg0KICAgICAgICA8c2VjdGlvbj4NCiAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjE3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFNvY2lhbCBIaXN0b3J5IFNlY3Rpb24iIC8+DQogICAgICAgICAgPGlkIHJvb3Q9ImQ1ZmZjZmQ3LTliOTctNGNjNS1hMzc0LWJmNjUxNWE1Y2UwYyIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSIyOTc2Mi0yIiBkaXNwbGF5TmFtZT0iJ1NPQ0lBTCBISVNUT1JZIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+U29jaWFsIEhpc3Rvcnk8L3RpdGxlPg0KICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+TGFzdCBVcGRhdGVkPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJzb2NpYWxIeERlc2NyaXB0aW9uSUQwIj5XaW5lIGNvbnN1bXB0aW9uIChfX18gZ2xhc3Nlcy9kYXkpPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wMS8wOC8yMDA4PC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ic29jaWFsSHhEZXNjcmlwdGlvbklEMSI+Q2FmZmVpbmUgdXNlPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wMS8wOC8yMDA4PC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ic29jaWFsSHhEZXNjcmlwdGlvbklEMiI+VG9iYWNjbyB1c2U8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAxLzA4LzIwMDg8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJzb2NpYWxIeERlc2NyaXB0aW9uSUQzIj5TbW9raW5nIFN0YXR1cyBVbmtub3duPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBTb2NpYWwgSGlzdG9yeSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE5IiBleHRlbnNpb249IjgxOTUzIiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGRpc3BsYXlOYW1lPSJBc3NlcnRpb24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiIC8+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNzb2NpYWxIeERlc2NyaXB0aW9uSUQwIiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjM2NTk2NzAwNSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMzczMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNiIgY29kZVN5c3RlbU5hbWU9Ik1FRENJTiIgLz4NCiAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBTb2NpYWwgSGlzdG9yeSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE5IiBleHRlbnNpb249IjgxOTU1IiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGRpc3BsYXlOYW1lPSJBc3NlcnRpb24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiIC8+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNzb2NpYWxIeERlc2NyaXB0aW9uSUQxIiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPHZhbHVlIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjEyMDA0NSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yNiIgY29kZVN5c3RlbU5hbWU9Ik1FRENJTiIgLz4NCiAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zOCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBTb2NpYWwgSGlzdG9yeSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE5IiBleHRlbnNpb249IjgxOTU0IiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGRpc3BsYXlOYW1lPSJBc3NlcnRpb24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiIC8+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNzb2NpYWxIeERlc2NyaXB0aW9uSUQyIiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjExMDQ4MzAwMCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICA8dHJhbnNsYXRpb24gY29kZT0iMTIwMDQ3IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI2IiBjb2RlU3lzdGVtTmFtZT0iTUVEQ0lOIiAvPg0KICAgICAgICAgICAgICA8L3ZhbHVlPg0KICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC43OCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBTbW9raW5nIFN0YXR1cyBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBkaXNwbGF5TmFtZT0iQXNzZXJ0aW9uIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIiAvPg0KICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjc29jaWFsSHhEZXNjcmlwdGlvbklEMyIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSIyNjY5MjcwMDEiIGRpc3BsYXlOYW1lPSJVbmtub3duIGlmIGV2ZXIgc21va2VkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgIDwvc2VjdGlvbj4NCiAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHNlY3Rpb24+DQogICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi43LjEiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlcyBTZWN0aW9uIChFbnRyaWVzIFJlcXVpcmVkKSIgLz4NCiAgICAgICAgICA8aWQgcm9vdD0iYjQ0ZWRmZWQtOTMzMy00N2Y3LWE2YTAtYmFhMjNmNDM5MjgzIiAvPg0KICAgICAgICAgIDxjb2RlIGNvZGU9IjQ3NTE5LTQiIGRpc3BsYXlOYW1lPSJISVNUT1JZIE9GIFBST0NFRFVSRVMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgIDx0aXRsZT5Qcm9jZWR1cmVzIGFuZCBTdXJnaWNhbC9NZWRpY2FsIEhpc3Rvcnk8L3RpdGxlPg0KICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aD5Qcm9jZWR1cmVzPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5DUFQtNDwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+RGlhZ25vc2lzPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5QZXJmb3JtaW5nIFByb3ZpZGVyPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5TZXJ2aWNlIExvY2F0aW9uPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5TZXJ2aWNlIERhdGU8L3RoPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InByb2NlZHVyZURlc2NyaXB0aW9uSUQwIj5IZW1hdG9jcml0PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD44NTAxNDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9InByb2NlZHVyZURlc2NyaXB0aW9uMCI+Uk9VVElORSBHRU5FUkFMIE1FRElDQUwgRVhBTTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+SmFtZXMgVCBNb25yb2UgTUQ8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPk9mZmljZSAtIE1hZGlzb24gTWVkaWNhbCBDZW50ZXIsIFAuQS48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjA5LzAzLzIwMDc8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJwcm9jZWR1cmVEZXNjcmlwdGlvbklEMSI+VXJpbmFseXNpczwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+ODEwMDA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJwcm9jZWR1cmVEZXNjcmlwdGlvbjEiPlJPVVRJTkUgR0VORVJBTCBNRURJQ0FMIEVYQU08L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkphbWVzIFQgTW9ucm9lIE1EPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wOS8wMy8yMDA3PC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGg+U3VyZ2ljYWwgSGlzdG9yeTwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+TGFzdCBVcGRhdGVkPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJzdXJnaWNhbEh4RGVzY3JpcHRpb25JRDAiPkhpc3Rvcnkgb2YgcHJpb3Igc3VyZ2VyeSAgIFtGb3IgSHggb2YgVHgsIHVzZSBIIHByZWZpeF08L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAxLzA4LzIwMDg8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aD5NZWRpY2FsIEhpc3Rvcnk8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPkxhc3QgVXBkYXRlZDwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90aGVhZD4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0ibWVkaWNhbEh4RGVzY3JpcHRpb25JRDAiPlJlcG9ydGVkIG1lZGljYWwgaGlzdG9yeTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDgvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvY2VkdXJlIEFjdGl2aXR5IFByb2NlZHVyZSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE3LjIiIGV4dGVuc2lvbj0iOTQiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijg1MDE0IiBkaXNwbGF5TmFtZT0iSGVtYXRvY3JpdCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMiIgY29kZVN5c3RlbU5hbWU9IkNQVC00Ij4NCiAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Byb2NlZHVyZURlc2NyaXB0aW9uSUQwIiAvPg0KICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNwcm9jZWR1cmVEZXNjcmlwdGlvbklEMCIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcwOTAzIiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5MDgwMDg5MDAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjExNTU0IFdlZWRzaWRlIExhbmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkphbWVzPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+VDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Nb25yb2U8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMWU3NjYxODMtNzE0OC00NTVjLTg5YjYtMTEzZjJlY2QyY2NjIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJMT0MiPg0KICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIExvY2F0aW9uIiAvPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJTRExPQyI+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSI0NSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlBST0ZGIiBkaXNwbGF5TmFtZT0iUHJvdmlkZXIncyBPZmZpY2UiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldCwgU3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iUExDIj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+T2ZmaWNlIC0gTWFkaXNvbiBNZWRpY2FsIENlbnRlciwgUC5BLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUHJvYmxlbSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0MmIzNGU5Ny1kNjQzLTQ4MDEtYmM0Zi00YzRiY2U5Nzk1ZTkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIyODIyOTEwMDkiIGRpc3BsYXlOYW1lPSJEaWFnbm9zaXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI3Byb2NlZHVyZURlc2NyaXB0aW9uMCIgLz4NCiAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MDkwMyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSJWNzAuMCIgZGlzcGxheU5hbWU9IlJPVVRJTkUgR0VORVJBTCBNRURJQ0FMIEVYQU0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNEOUNNIiB4c2k6dHlwZT0iQ0QiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNwcm9jZWR1cmVEZXNjcmlwdGlvbjAiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC92YWx1ZT4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNy4yIiBleHRlbnNpb249Ijk1IiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI4MTAwMCIgZGlzcGxheU5hbWU9IlVyaW5hbHlzaXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTIiIGNvZGVTeXN0ZW1OYW1lPSJDUFQtNCI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNwcm9jZWR1cmVEZXNjcmlwdGlvbklEMSIgLz4NCiAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjcHJvY2VkdXJlRGVzY3JpcHRpb25JRDEiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MDkwMyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTA4MDA4OTAwMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTlBJIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xMTU1NCBXZWVkc2lkZSBMYW5lPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5KYW1lczwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPlQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjU1NmFmNDQyLTZiMzYtNDEzYS1iMTMzLTk4OWZlNjJjNTNjNiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iTE9DIj4NCiAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMyIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEVuY291bnRlciBMb2NhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iU0RMT0MiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iNDUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQUk9GRiIgZGlzcGxheU5hbWU9IlByb3ZpZGVyJ3MgT2ZmaWNlIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zNCBTeWNhbW9yZSBTdHJlZXQsIFN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9IlBMQyI+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk9mZmljZSAtIE1hZGlzb24gTWVkaWNhbCBDZW50ZXIsIFAuQS48L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2JsZW0gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMWIzYWZlMzQtOTY1YS00M2M4LWIwMzYtMjI2OGUyMGQzN2U0IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMjgyMjkxMDA5IiBkaXNwbGF5TmFtZT0iRGlhZ25vc2lzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNwcm9jZWR1cmVEZXNjcmlwdGlvbjEiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNzA5MDMiIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iVjcwLjAiIGRpc3BsYXlOYW1lPSJST1VUSU5FIEdFTkVSQUwgTUVESUNBTCBFWEFNIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRDlDTSIgeHNpOnR5cGU9IkNEIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjcHJvY2VkdXJlRGVzY3JpcHRpb24xIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgIDwvcHJvY2VkdXJlPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQcm9jZWR1cmUgQWN0aXZpdHkgUHJvY2VkdXJlIiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTkiIGV4dGVuc2lvbj0iODE5NTciIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjE2MTYxNTAwMyIgZGlzcGxheU5hbWU9Imhpc3Rvcnkgb2YgcHJpb3Igc3VyZ2VyeSAgIFtGb3IgSHggb2YgVHgsIHVzZSBIIHByZWZpeF0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiPg0KICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjc3VyZ2ljYWxIeERlc2NyaXB0aW9uSUQwIiAvPg0KICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNzdXJnaWNhbEh4RGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA4MDEwOCIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjE0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFByb2NlZHVyZSBBY3Rpdml0eSBQcm9jZWR1cmUiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xOSIgZXh0ZW5zaW9uPSI4MTk1NiIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgZGlzcGxheU5hbWU9InJlcG9ydGVkIG1lZGljYWwgaGlzdG9yeSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNtZWRpY2FsSHhEZXNjcmlwdGlvbklEMCIgLz4NCiAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjbWVkaWNhbEh4RGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA4MDEwOCIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgPC9wcm9jZWR1cmU+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgPC9zZWN0aW9uPg0KICAgICAgPC9jb21wb25lbnQ+DQogICAgICA8Y29tcG9uZW50Pg0KICAgICAgICA8c2VjdGlvbj4NCiAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjE1IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEZhbWlseSBIaXN0b3J5IFNlY3Rpb24iIC8+DQogICAgICAgICAgPGlkIHJvb3Q9ImY4MjEyMzcwLWEwOGEtNGIwZS1iZTA3LWZiZDljOGQ0MjgwMiIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSIxMDE1Ny02IiBkaXNwbGF5TmFtZT0iSElTVE9SWSBPRiBGQU1JTFkgTUVNQkVSIERJU0VBU0VTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+RmFtaWx5IEhpc3Rvcnk8L3RpdGxlPg0KICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+TGFzdCBVcGRhdGVkPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJmYW1pbHlIeERlc2NyaXB0aW9uSUQwIj5SZXBvcnRlZCBmYW1pbHkgaGlzdG9yeSBvZiBjYW5jZXI8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAxLzA4LzIwMDg8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJmYW1pbHlIeERlc2NyaXB0aW9uSUQxIj5GYW1pbHkgaGlzdG9yeSAgW0ZvciBGSHggb2YgRHggdXNlIER4IHcvIEYgcHJlZml4XTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDgvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTkiIGV4dGVuc2lvbj0iODE5NTgiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkFTU0VSVElPTiIgZGlzcGxheU5hbWU9IkFzc2VydGlvbiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2ZhbWlseUh4RGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iMjc1OTM3MDAxIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiPg0KICAgICAgICAgICAgICAgIDx0cmFuc2xhdGlvbiBjb2RlPSI0MTAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI2IiBjb2RlU3lzdGVtTmFtZT0iTUVEQ0lOIiAvPg0KICAgICAgICAgICAgICA8L3ZhbHVlPg0KICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTkiIGV4dGVuc2lvbj0iODE5NTkiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkFTU0VSVElPTiIgZGlzcGxheU5hbWU9IkFzc2VydGlvbiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSIgLz4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2ZhbWlseUh4RGVzY3JpcHRpb25JRDEiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNTcxNzcwMDciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCI+DQogICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9IjUwOTgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjYiIGNvZGVTeXN0ZW1OYW1lPSJNRURDSU4iIC8+DQogICAgICAgICAgICAgIDwvdmFsdWU+DQogICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgIDwvc2VjdGlvbj4NCiAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHNlY3Rpb24+DQogICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS4zLjE4IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFJldmlldyBvZiBTeXN0ZW1zIFNlY3Rpb24iIC8+DQogICAgICAgICAgPGlkIHJvb3Q9IjQxZDJhODA2LWU0ZjctNDk4YS1hMzQzLTVlNGRmYTFmZjcwMyIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSIxMDE4Ny0zIiBkaXNwbGF5TmFtZT0iUkVWSUVXIE9GIFNZU1RFTVMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgIDx0aXRsZT5SZXZpZXcgb2YgU3lzdGVtczwvdGl0bGU+DQogICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICA8Y29udGVudD5ObyBSZXZpZXcgb2YgU3lzdGVtcyBSZWNvcmRlZDwvY29udGVudD4NCiAgICAgICAgICA8L3RleHQ+DQogICAgICAgIDwvc2VjdGlvbj4NCiAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHNlY3Rpb24+DQogICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuMi4xNCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBGdW5jdGlvbmFsIFN0YXR1cyBTZWN0aW9uIiAvPg0KICAgICAgICAgIDxpZCByb290PSIxNDNjMzNlMi05YjcwLTQ5OTktODExZC04NTA3MGM2ZmVhOWEiIC8+DQogICAgICAgICAgPGNvZGUgY29kZT0iNDc0MjAtNSIgZGlzcGxheU5hbWU9IkZVTkNUSU9OQUwgU1RBVFVTIEFTU0VTU01FTlQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgIDx0aXRsZT5GdW5jdGlvbmFsIGFuZCBDb2duaXRpdmUgU3RhdHVzPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDxjb250ZW50Pk5vIEZ1bmN0aW9uYWwgb3IgQ29nbml0aXZlIFN0YXR1cyBSZWNvcmRlZDwvY29udGVudD4NCiAgICAgICAgICA8L3RleHQ+DQogICAgICAgIDwvc2VjdGlvbj4NCiAgICAgIDwvY29tcG9uZW50Pg0KICAgICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHNlY3Rpb24+DQogICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMi4xMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQaHlzaWNhbCBFeGFtIFNlY3Rpb24iIC8+DQogICAgICAgICAgPGlkIHJvb3Q9ImJiYWQ2OTAwLWYyNjQtNDM1My04ZDgzLTRlZGY4N2E0Y2RlNyIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSIyOTU0NS0xIiBkaXNwbGF5TmFtZT0iUEhZU0lDQUwgRklORElOR1MiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgIDx0aXRsZT5QaHlzaWNhbCBFeGFtPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDxjb250ZW50Pk5vIFBoeXNpY2FsIEV4YW0gUmVjb3JkZWQ8L2NvbnRlbnQ+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICA8L3NlY3Rpb24+DQogICAgICA8L2NvbXBvbmVudD4NCiAgICAgIDxjb21wb25lbnQ+DQogICAgICAgIDxzZWN0aW9uPg0KICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMi4xIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEltbXVuaXphdGlvbnMgU2VjdGlvbiAoRW50cmllcyBSZXF1aXJlZCkiIC8+DQogICAgICAgICAgPGlkIHJvb3Q9ImY0MTRkMTdmLTg1YmEtNDc5YS1iOWUyLTQ5MDk3ZDBkMzc2YSIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSIxMTM2OS02IiBkaXNwbGF5TmFtZT0iSElTVE9SWSBPRiBJTU1VTklaQVRJT05TIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+SW1tdW5pemF0aW9uczwvdGl0bGU+DQogICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICA8dGFibGUgd2lkdGg9IjEwMCUiPg0KICAgICAgICAgICAgICA8dGhlYWQ+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRoPlZhY2NpbmU8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPkRvc2UgIzwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+RGF0ZTwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+U2l0ZTwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+UmVhY3Rpb24ocyk8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlN0YXR1czwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+U291cmNlPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aCAvPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICAgIDx0Ym9keT4NCiAgICAgICAgICAgICAgICA8dHIgSUQ9IkltbXVuaXphdGlvbnMtVmFjY2luZS1JRDAiPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJJbW11bml6YXRpb25zLURlc2NyaXB0aW9uLUlEMCI+SW5mbHVlbnphPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iSW1tdW5pemF0aW9uRG9zZS0wIj4xPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wNi8yOC8yMDA2PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iSW1tdW5pemF0aW9ucy1BZG1pblNpdGUtSUQwIj5MZWZ0IEFybTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJJbW11bml6YXRpb25zLVN0YXR1cy1JRDAiPkFjdGl2ZSAoQWRtaW5pc3RlcmVkKTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9IkltbXVuaXphdGlvbnMtRXh0cmEtSW5mby1Db21tZW50LUlEMCI+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNTIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW1tdW5pemF0aW9uIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTMiIGV4dGVuc2lvbj0iMjIiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IklNTVVOSVoiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiIC8+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNJbW11bml6YXRpb25zLVZhY2NpbmUtSUQwIiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDYwNjI4MTQyNCIgLz4NCiAgICAgICAgICAgICAgPGFwcHJvYWNoU2l0ZUNvZGUgY29kZT0iNzIwOTgwMDIiIGRpc3BsYXlOYW1lPSJFbnRpcmUgbGVmdCB1cHBlciBhcm0gKGJvZHkgc3RydWN0dXJlKSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNJbW11bml6YXRpb25zLUFkbWluU2l0ZS1JRDAiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvYXBwcm9hY2hTaXRlQ29kZT4NCiAgICAgICAgICAgICAgPGNvbnN1bWFibGU+DQogICAgICAgICAgICAgICAgPG1hbnVmYWN0dXJlZFByb2R1Y3QgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNTQiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgSW1tdW5pemF0aW9uIE1lZGljYXRpb24gSW5mb3JtYXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQogICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9Ijg4IiBkaXNwbGF5TmFtZT0iSW5mbHVlbnphIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4xMi4yOTIiIGNvZGVTeXN0ZW1OYW1lPSJDVlgiPg0KICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjSW1tdW5pemF0aW9ucy1EZXNjcmlwdGlvbi1JRDAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+SW5mbHVlbnphPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8bG90TnVtYmVyVGV4dD5iNzE0NTIzPC9sb3ROdW1iZXJUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCiAgICAgICAgICAgICAgICAgIDxtYW51ZmFjdHVyZXJPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPkF2ZW50aXMgUGFzdGV1ciBJbmM8L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgIDxzdGFuZGFyZEluZHVzdHJ5Q2xhc3NDb2RlIGNvZGU9IjAwNzIxNjciIGRpc3BsYXlOYW1lPSJBdmVudGlzIFBhc3RldXIgSW5jIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExNDIyMi40LjExLjgyNiIgY29kZVN5c3RlbU5hbWU9Ik1WWCAoTWFudWZhY3R1cmVycyBvZiB2YWNjaW5lcykiIC8+DQogICAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQogICAgICAgICAgICAgIDwvY29uc3VtYWJsZT4NCiAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42IiBleHRlbnNpb249Ijk5OTAwNTg3MDAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5QSSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyYzEzYWQxNy04MDg2LTQwZjQtYTdhNS01OWUyYTdmMTJjMDEiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIwMCIgZGlzcGxheU5hbWU9Ik5ldyBpbW11bml6YXRpb24gcmVjb3JkIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTWVkaWNhdGlvbiBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMzk5OS00IiBkaXNwbGF5TmFtZT0iU3RhdHVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjSW1tdW5pemF0aW9ucy1TdGF0dXMtSUQwIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU1NTYxMDAzIiBkaXNwbGF5TmFtZT0iQWN0aXZlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0UiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEIERvc2UgTnVtYmVyIE9ic2VydmF0aW9uIFRlbXBsYXRlIiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImZhMjUwZGJkLTEzZWEtNGZmNy04NDVmLTEzNmI0N2Q2YmY3YSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMwOTczLTIiIGRpc3BsYXlOYW1lPSJEb3NlIE51bWJlciIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgdmFsdWU9IjEiIHhzaTp0eXBlPSJJTlQiIC8+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC42NCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBDb21tZW50IEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNDg3NjctOCIgZGlzcGxheU5hbWU9IkltbXVuaXphdGlvbiBSZWdpc3RyeSBjb21tZW50IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0PkVuY291bnRlckRhdGU9MjAwNjA2MjgxNTAyfENvbXBsZXRpb25TdGF0dXM9Q1B8T1BJRE51bWJlcj05OTkwMDU4NzAwfE9QQXNzaWduaW5nQXV0aD1OUEl8T1BGaXJzdE5hbWU9RGF2aWR8T1BMYXN0TmFtZT1Gb3JkfEVQSUROdW1iZXI9OTk5MDA1ODcwMHxFUEFzc2lnbmluZ0F1dGg9TlBJfEVQRmlyc3ROYW1lPURhdmlkfEVQTGFzdE5hbWU9Rm9yZHxQYXRpZW50QXV0aG9yaXphdGlvbj1VfFBhdGllbnRBdXRob3JpemF0aW9uRGF0ZT1VfEltbXVuaXphdGlvblNvdXJjZUNvZGU9MDB8SW1tdW5pemF0aW9uU291cmNlRGVzYz1OZXcgaW1tdW5pemF0aW9uIHJlY29yZDxyZWZlcmVuY2UgdmFsdWU9IiNJbW11bml6YXRpb25zLUV4dHJhLUluZm8tQ29tbWVudC1JRDAiIC8+PC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICA8L3NlY3Rpb24+DQogICAgICA8L2NvbXBvbmVudD4NCiAgICAgIDxjb21wb25lbnQ+DQogICAgICAgIDxzZWN0aW9uPg0KICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuNi4xIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ2llcyBTZWN0aW9uIChFbnRyaWVzIFJlcXVpcmVkKSIgLz4NCiAgICAgICAgICA8aWQgcm9vdD0iNDk5M2UwNzAtODc5My00ZGRhLTk4MjAtMmUxOTM5NGIzMDk4IiAvPg0KICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY1LTIiIGRpc3BsYXlOYW1lPSJBbGxlcmdpZXMsIGFkdmVyc2UgcmVhY3Rpb25zLCBhbGVydHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgIDx0aXRsZT5BbGxlcmdpZXM8L3RpdGxlPg0KICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgPHRhYmxlIHdpZHRoPSIxMDAlIj4NCiAgICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0aD5TdWJzdGFuY2U8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlR5cGU8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlJlYWN0aW9uPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5FZmZlY3RpdmU8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlN0YXR1czwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90aGVhZD4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneURlc2NyaXB0aW9uSUQwIj5SYWd3ZWVkPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5BbGxlcmd5PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneVJlYWN0aW9uSUQwIj5JdGNoeSBleWVzIGFuZCBuYXNhbCBjb25nZXN0aW9uPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wMi8wNC8xOTcwPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneVN0YXR1c0lEMCI+QWN0aXZlPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneURlc2NyaXB0aW9uSUQxIj5MYXRleDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+QWxsZXJneTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9ImFsbGVyZ3lSZWFjdGlvbklEMSI+U2tpbiBSYXNoZXMvSGl2ZXM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAzLzA3LzIwMDI8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJhbGxlcmd5U3RhdHVzSUQxIj5BY3RpdmU8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJhbGxlcmd5RGVzY3JpcHRpb25JRDIiPkZpb3JpbmFsL0NvZGVpbmUgIzM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkludG9sZXJhbmNlPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneVJlYWN0aW9uSUQyIj5OYXVzZWEvVm9taXRpbmcvRGlhcnJoZWE8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjA5LzA1LzIwMDc8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJhbGxlcmd5U3RhdHVzSUQyIj5BY3RpdmU8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneUNvbW1lbnRzSUQyIiBjb2xzcGFuPSI0Ij5Ob3RlOiBQYXRpZW50IHN0b3BwZWQgdGFraW5nIG1lZCBvbiBkYXkgMjwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9ImFsbGVyZ3lEZXNjcmlwdGlvbklEMyI+Q2hlZXNlPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5BbGxlcmd5PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneVJlYWN0aW9uSUQzIj5OYXVzZWEvVm9taXRpbmcvRGlhcnJoZWE8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAzLzA3LzIwMDI8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJhbGxlcmd5U3RhdHVzSUQzIj5BY3RpdmU8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJhbGxlcmd5RGVzY3JpcHRpb25JRDQiPkJpcmRzPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5BbGxlcmd5PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneVJlYWN0aW9uSUQ0Ij5Ta2luIFJhc2hlcy9IaXZlcywgTmF1c2VhL1ZvbWl0aW5nL0RpYXJyaGVhPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4xMS8wNS8yMDA5PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iYWxsZXJneVN0YXR1c0lENCI+QWN0aXZlPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3Rib2R5Pg0KICAgICAgICAgICAgPC90YWJsZT4NCiAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgUHJvYmxlbSBBY3QiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC42IiBleHRlbnNpb249IjEwOS1SQUciIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY1LTIiIGRpc3BsYXlOYW1lPSJBbGxlcmdpZXMsIGFkdmVyc2UgcmVhY3Rpb25zLCBhbGVydHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDkwMTA4IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC43IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMjc1ZTIyOGQtOTc5YS00OWNmLWE4NjYtNmVhMzNjODJkMGM4IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBkaXNwbGF5TmFtZT0iQXNzZXJ0aW9uIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneURlc2NyaXB0aW9uSUQwIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjE5NzAwMjA0IiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjQxOTE5OTAwNyIgZGlzcGxheU5hbWU9IkFsbGVyZ3kgdG8gc3Vic3RhbmNlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjFmMjdmOTI2LTJiNTQtNDBiYy04ZTNkLWQ2NTg4MDBhMzFiZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDU00iPg0KICAgICAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJNTUFUIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVua25vd24iIGRpc3BsYXlOYW1lPSJSYWd3ZWVkIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My40LjkiIGNvZGVTeXN0ZW1OYW1lPSJVTklJIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneURlc2NyaXB0aW9uSUQwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9Ik1GU1QiIGludmVyc2lvbkluZD0idHJ1ZSI+DQogICAgICAgICAgICAgICAgICAgIDxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC45IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgUmVhY3Rpb24gT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjVmOTMxNDNkLWQxZjQtNGM3Ny04NThmLTg2YzE1YjJiYTA2ZSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI1NTYwNzAwNiIgZGlzcGxheU5hbWU9IlByb2JsZW0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneVJlYWN0aW9uSUQwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9Ik5JIiBkaXNwbGF5TmFtZT0iSXRjaHkgZXllcyBhbmQgbmFzYWwgY29uZ2VzdGlvbiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjI4IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgU3RhdHVzIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjMzOTk5LTQiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lTdGF0dXNJRDAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNTU1NjEwMDMiIGRpc3BsYXlOYW1lPSJBY3RpdmUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgICAgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQogICAgICAgICAgICAgICAgPC9vYnNlcnZhdGlvbj4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgUHJvYmxlbSBBY3QiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC42IiBleHRlbnNpb249IjEwOS1MQVQiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY1LTIiIGRpc3BsYXlOYW1lPSJBbGxlcmdpZXMsIGFkdmVyc2UgcmVhY3Rpb25zLCBhbGVydHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDYxMjA3IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC43IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iNDMwM2ZjOTMtNmZlYi00NjQ2LTk2N2ItNmJlM2Y2NTMxNWUwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBkaXNwbGF5TmFtZT0iQXNzZXJ0aW9uIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneURlc2NyaXB0aW9uSUQxIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDIwMzA3IiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjQxOTE5OTAwNyIgZGlzcGxheU5hbWU9IkFsbGVyZ3kgdG8gc3Vic3RhbmNlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9Ijc1MjE0NDIwLWNhOTgtNDY3Mi05YzM2LWFlZDhjYjc5ZDIxZiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDU00iPg0KICAgICAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJNTUFUIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVua25vd24iIGRpc3BsYXlOYW1lPSJMYXRleCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNC45IiBjb2RlU3lzdGVtTmFtZT0iVU5JSSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lEZXNjcmlwdGlvbklEMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJNRlNUIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuOSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBBbGxlcmd5IFJlYWN0aW9uIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI1NjA4MDE4NC00MGRkLTQwNWMtODJmYy0xMmQyOTNkYWZjYjkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lSZWFjdGlvbklEMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI2NDE0NDAwMiIgZGlzcGxheU5hbWU9IlNraW4gUmFzaGVzL0hpdmVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBTdGF0dXMgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzM5OTktNCIgZGlzcGxheU5hbWU9IlN0YXR1cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneVN0YXR1c0lEMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBQcm9ibGVtIEFjdCIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjYiIGV4dGVuc2lvbj0iMTA5LTIiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY1LTIiIGRpc3BsYXlOYW1lPSJBbGxlcmdpZXMsIGFkdmVyc2UgcmVhY3Rpb25zLCBhbGVydHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC43IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMDBlZmE1ZDktYmEzZC00ZWM2LTg2N2YtMjIwMDkzYzlhNDRhIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBkaXNwbGF5TmFtZT0iQXNzZXJ0aW9uIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneURlc2NyaXB0aW9uSUQyIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcwOTA1IiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjU5MDM3MDA3IiBkaXNwbGF5TmFtZT0iRHJ1ZyBpbnRvbGVyYW5jZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNEIiAvPg0KICAgICAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIzYjk4ZTk3Zi1kMGVmLTQ2NzktODhjYS1jODVmMThkNTQ4YmUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQ1NNIj4NCiAgICAgICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KICAgICAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iTU1BVCI+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSIzMDk0NzEiIGRpc3BsYXlOYW1lPSJBc3BpcmluIDMyNSBNRyAvIGJ1dGFsYml0YWwgNTAgTUcgLyBDYWZmZWluZSA0MCBNRyAvIENvZGVpbmUgMzAgTUcgT3JhbCBDYXBzdWxlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiBjb2RlU3lzdGVtTmFtZT0iUnhOb3JtIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneURlc2NyaXB0aW9uSUQyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyYW5zbGF0aW9uIGNvZGU9Ijg0MzAiIGRpc3BsYXlOYW1lPSJGaW9yaW5hbC9Db2RlaW5lICMzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1MyIgY29kZVN5c3RlbU5hbWU9Ik1lZGlTcGFuIERESUQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5Bc3BpcmluIDMyNSBNRyAvIGJ1dGFsYml0YWwgNTAgTUcgLyBDYWZmZWluZSA0MCBNRyAvIENvZGVpbmUgMzAgTUcgT3JhbCBDYXBzdWxlPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJNRlNUIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuOSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBBbGxlcmd5IFJlYWN0aW9uIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSI3OTJiNDg5ZC02Y2FhLTQ4MDUtOWJmZi01NmFlMmQyYTJlNTYiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lSZWFjdGlvbklEMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSIyOTE5MDA4IiBkaXNwbGF5TmFtZT0iTmF1c2VhL1ZvbWl0aW5nL0RpYXJyaGVhIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBTdGF0dXMgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzM5OTktNCIgZGlzcGxheU5hbWU9IlN0YXR1cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneVN0YXR1c0lEMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+DQogICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjY0IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIENvbW1lbnQgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI0ODc2Ny04IiBkaXNwbGF5TmFtZT0iQW5ub3RhdGlvbiBjb21tZW50IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneUNvbW1lbnRzSUQyIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBQcm9ibGVtIEFjdCIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjYiIGV4dGVuc2lvbj0iMTA5LWNoZWVzZSIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNDg3NjUtMiIgZGlzcGxheU5hbWU9IkFsbGVyZ2llcywgYWR2ZXJzZSByZWFjdGlvbnMsIGFsZXJ0cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgIDxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIgLz4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNjEyMDciIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9ImZhbHNlIj4NCiAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjciIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBPYnNlcnZhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyMzEzNDUzZS0wZDg4LTQxODAtODAzOS1hYjkzNzE2YzlhZmQiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGRpc3BsYXlOYW1lPSJBc3NlcnRpb24iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiPg0KICAgICAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNhbGxlcmd5RGVzY3JpcHRpb25JRDMiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiMiIC8+DQogICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwMjAzMDciIC8+DQogICAgICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICA8dmFsdWUgY29kZT0iNDE5MTk5MDA3IiBkaXNwbGF5TmFtZT0iQWxsZXJneSB0byBzdWJzdGFuY2UiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIHhzaTp0eXBlPSJDRCIgLz4NCiAgICAgICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMTBhN2ZhNDgtYmM1My00YzFlLTlmYjgtZjUyNmFlOWYxNmU0IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQogICAgICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJNQU5VIj4NCiAgICAgICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iVW5rbm93biIgZGlzcGxheU5hbWU9IkNoZWVzZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNC45IiBjb2RlU3lzdGVtTmFtZT0iVU5JSSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lEZXNjcmlwdGlvbklEMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJNRlNUIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuOSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBBbGxlcmd5IFJlYWN0aW9uIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJkZjgxMTkwNi1iM2M5LTQ1ZDgtODc2Ny1jOWI0ZjY2NDljNjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lSZWFjdGlvbklEMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSIyOTE5MDA4IiBkaXNwbGF5TmFtZT0iTmF1c2VhL1ZvbWl0aW5nL0RpYXJyaGVhIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBTdGF0dXMgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzM5OTktNCIgZGlzcGxheU5hbWU9IlN0YXR1cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneVN0YXR1c0lEMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBQcm9ibGVtIEFjdCIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjYiIGV4dGVuc2lvbj0iMTA5LWJpcmQiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY1LTIiIGRpc3BsYXlOYW1lPSJBbGxlcmdpZXMsIGFkdmVyc2UgcmVhY3Rpb25zLCBhbGVydHMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiIC8+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDkxMTA1IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiIgaW52ZXJzaW9uSW5kPSJmYWxzZSI+DQogICAgICAgICAgICAgICAgPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC43IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFsbGVyZ3kgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iZDkxYjdlNWUtYmM0Ny00ZTRmLWFjMTAtZGNiOGI2ZGZlODBiIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBkaXNwbGF5TmFtZT0iQXNzZXJ0aW9uIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIj4NCiAgICAgICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneURlc2NyaXB0aW9uSUQ0IiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjIiAvPg0KICAgICAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDkxMTA1IiAvPg0KICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgPHZhbHVlIGNvZGU9IjQxOTE5OTAwNyIgZGlzcGxheU5hbWU9IkFsbGVyZ3kgdG8gc3Vic3RhbmNlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImZiYTRhZTcwLTM4ZGEtNDY3MS04N2YxLTg5OTZjODFhNjkyMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDU00iPg0KICAgICAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQogICAgICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJNTUFUIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVua25vd24iIGRpc3BsYXlOYW1lPSJCaXJkcyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNC45IiBjb2RlU3lzdGVtTmFtZT0iVU5JSSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lEZXNjcmlwdGlvbklENCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZSAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJNRlNUIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuOSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBBbGxlcmd5IFJlYWN0aW9uIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjYWYyNWQ4My1lNGMyLTQzOTctYjI1YS0wOWNhY2MyMDkxODIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lSZWFjdGlvbklENCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI2NDE0NDAwMiIgZGlzcGxheU5hbWU9IlNraW4gUmFzaGVzL0hpdmVzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJNRlNUIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuOSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBBbGxlcmd5IFJlYWN0aW9uIE9ic2VydmF0aW9uIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyYzFhMmM2OS1hMzljLTRlYmEtODU3NS0zNmIwNGQ1NWJkOWQiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iNTU2MDcwMDYiIGRpc3BsYXlOYW1lPSJQcm9ibGVtIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2FsbGVyZ3lSZWFjdGlvbklENCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSIyOTE5MDA4IiBkaXNwbGF5TmFtZT0iTmF1c2VhL1ZvbWl0aW5nL0RpYXJyaGVhIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiB4c2k6dHlwZT0iQ0QiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvb2JzZXJ2YXRpb24+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KICAgICAgICAgICAgICAgICAgICA8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMjgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQWxsZXJneSBTdGF0dXMgT2JzZXJ2YXRpb24iIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMzM5OTktNCIgZGlzcGxheU5hbWU9IlN0YXR1cyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjYWxsZXJneVN0YXR1c0lENCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgeHNpOnR5cGU9IkNFIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L29ic2VydmF0aW9uPg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgPC9zZWN0aW9uPg0KICAgICAgPC9jb21wb25lbnQ+DQogICAgICA8Y29tcG9uZW50Pg0KICAgICAgICA8c2VjdGlvbj4NCiAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjIyIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEVuY291bnRlcnMgU2VjdGlvbiIgLz4NCiAgICAgICAgICA8aWQgcm9vdD0iY2VmODcxYzctNTU1OS00MWU0LWFhZjItYzNhMmQ4OGEwOTJiIiAvPg0KICAgICAgICAgIDxjb2RlIGNvZGU9IjQ2MjQwLTgiIGRpc3BsYXlOYW1lPSJIaXN0b3J5IG9mIGVuY291bnRlcnMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgIDx0aXRsZT5FbmNvdW50ZXJzPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGg+RW5jb3VudGVyPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5Qcm92aWRlcjwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+TG9jYXRpb248L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPkRhdGU8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPkRpYWdub3NpczwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90aGVhZD4NCiAgICAgICAgICAgICAgPHRib2R5Pg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iZW5jb3VudGVyRGVzY3JpcHRpb25JRDAiPltQYXRpZW50IEVuY291bnRlcl08L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRhdmlkIEUgRm9yZCBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAxLzEzLzIwMTI8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iZW5jb3VudGVyRGVzY3JpcHRpb25JRDEiPltQYXRpZW50IEVuY291bnRlcl08L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRhdmlkIEUgRm9yZCBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAzLzAxLzIwMTA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iZW5jb3VudGVyRGVzY3JpcHRpb25JRDIiPltQYXRpZW50IEVuY291bnRlcl08L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRhdmlkIEUgRm9yZCBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAyLzIzLzIwMTA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iZW5jb3VudGVyRGVzY3JpcHRpb25JRDMiPltQYXRpZW50IEVuY291bnRlcl08L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkRhdmlkIEUgRm9yZCBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjExLzAyLzIwMDk8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iZW5jb3VudGVyRGVzY3JpcHRpb25JRDQiPkNvbnN1bHRhdGlvbjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGVwYWsgRSBTaGFoIE1EPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wMS8wOC8yMDA4PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9ImVuY291bnRlckRlc2NyaXB0aW9uSUQ1Ij5bUGF0aWVudCBFbmNvdW50ZXJdPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5EYXZpZCBFIEZvcmQgTUQ8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPk9mZmljZSAtIE1hZGlzb24gTWVkaWNhbCBDZW50ZXIsIFAuQS48L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjAxLzA4LzIwMDg8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iZW5jb3VudGVyRGVzY3JpcHRpb25JRDYiPk5ldyBQYXRpZW50IFZpc2l0PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5HYXJ5IE1hZGRlciBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+T2ZmaWNlIC0gTWFkaXNvbiBNZWRpY2FsIENlbnRlciwgUC5BLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDgvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJlbmNvdW50ZXJEZXNjcmlwdGlvbklENyI+Q29uc3VsdGF0aW9uPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5KYW1lcyBUIE1vbnJvZSBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+T2ZmaWNlIC0gTWFkaXNvbiBNZWRpY2FsIENlbnRlciwgUC5BLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDMvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJlbmNvdW50ZXJEZXNjcmlwdGlvbklEOCI+Q29uc3VsdGF0aW9uPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5KYW1lcyBUIE1vbnJvZSBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+T2ZmaWNlIC0gTWFkaXNvbiBNZWRpY2FsIENlbnRlciwgUC5BLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDEvMDMvMjAwODwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJlbmNvdW50ZXJEZXNjcmlwdGlvbklEOSI+Q29uc3VsdGF0aW9uPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5KYW1lcyBUIE1vbnJvZSBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+T2ZmaWNlIC0gTWFkaXNvbiBNZWRpY2FsIENlbnRlciwgUC5BLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTEvMDIvMjAwNzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJlbmNvdW50ZXJEZXNjcmlwdGlvbklEMTAiPlJlLUNoZWNrPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5KYW1lcyBUIE1vbnJvZSBNRDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+T2ZmaWNlIC0gTWFkaXNvbiBNZWRpY2FsIENlbnRlciwgUC5BLjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTAvMDUvMjAwNzwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+DQogICAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJlbmNvdW50ZXJEZXNjcmlwdGlvbklEMTEiPk5ldyBQYXRpZW50IEV2YWx1YXRpb248L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPkphbWVzIFQgTW9ucm9lIE1EPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wOS8wMy8yMDA3PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGQgSUQ9ImVuY291bnRlckRlc2NyaXB0aW9uSUQxMiI+R2VuZXJhbCBDaGVjay11cDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+RGF2aWQgRSBGb3JkIE1EPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4wNi8yOC8yMDA2PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgICAgIDwvdGFibGU+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8ZW5jb3VudGVyIGNsYXNzQ29kZT0iRU5DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNiIgZXh0ZW5zaW9uPSI3ODAiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkdFTlJMIiBkaXNwbGF5TmFtZT0iR2VuZXJhbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklEMCIgLz4NCiAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDAiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAxMjAxMTMiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42IiBleHRlbnNpb249Ijk5OTAwNTg3MDAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5QSSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjNzU3NzA4MS1hN2E4LTRjYTMtOWZmNy01ZWM2ZjI1MTU4OGQiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iNTk2IiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJHRU5STCIgZGlzcGxheU5hbWU9IkdlbmVyYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiPg0KICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDEiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQxIiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMTAwMzAxIiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMDU4NzAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMmVjYzZiMWYtMDY4Yy00MWY1LWE2OGQtMTY1Zjc5YmU4OGViIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgIDwvZW5jb3VudGVyPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxlbmNvdW50ZXIgY2xhc3NDb2RlPSJFTkMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQ5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEVuY291bnRlciBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE2IiBleHRlbnNpb249IjU5MiIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgY29kZT0iR0VOUkwiIGRpc3BsYXlOYW1lPSJHZW5lcmFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIj4NCiAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQyIiAvPg0KICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklEMiIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDEwMDIyMyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTk5MDA1ODcwMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTlBJIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT44NyBCYXlzaG9yZSBEcml2ZTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RGF2aWQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkZvcmQ8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjkxZmQ2MDgxLTIwMDMtNDE5Ny04YThiLTJkOGRlNmIyMmRmMSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICA8L2VuY291bnRlcj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8ZW5jb3VudGVyIGNsYXNzQ29kZT0iRU5DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNiIgZXh0ZW5zaW9uPSI1MTEiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkdFTlJMIiBkaXNwbGF5TmFtZT0iR2VuZXJhbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklEMyIgLz4NCiAgICAgICAgICAgICAgICA8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgPC9jb2RlPg0KICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDMiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwOTExMDIiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42IiBleHRlbnNpb249Ijk5OTAwNTg3MDAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5QSSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjODg0MDgwYS1mYzZjLTQ0Y2EtYjRmZC00NTRjYmRjMzE5MDciIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iMTE1IiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJHRU5STCIgZGlzcGxheU5hbWU9IkdlbmVyYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiPg0KICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDQiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQ0IiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMDU0ODAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg2MjAgUGFsbWV0dG8gRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRlcGFrPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5TaGFoPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIwMWEwODlkNy0yMmI5LTQ5NjctYjIwZS0yNGJhYTBhYzE4ZTkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQogICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgTG9jYXRpb24iIC8+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjQ1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUFJPRkYiIGRpc3BsYXlOYW1lPSJQcm92aWRlcidzIE9mZmljZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0LCBTdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iMTMwIiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJHRU5STCIgZGlzcGxheU5hbWU9IkdlbmVyYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiPg0KICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDUiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQ1IiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMDU4NzAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjg3IEJheXNob3JlIERyaXZlPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5EYXZpZDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkU8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+Rm9yZDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMjg0NmQwZDItMjVmMS00OTliLTllNzEtNTA2MzU0OTUyYzZkIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJMT0MiPg0KICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIExvY2F0aW9uIiAvPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJTRExPQyI+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlBST0ZGIiBkaXNwbGF5TmFtZT0iUHJvdmlkZXIncyBPZmZpY2UiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMTExIiBjb2RlU3lzdGVtTmFtZT0iUm9sZUNvZGUiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iMjg5IiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJHRU5STCIgZGlzcGxheU5hbWU9IkdlbmVyYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiPg0KICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDYiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQ2IiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTA4IiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5OTkwMTU1MjAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5HYXJ5PC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5Pk1hZGRlcjwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdWZmaXg+TUQ8L3N1ZmZpeD4NCiAgICAgICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCiAgICAgICAgICAgICAgPGluZm9ybWFudD4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iN2JlODg1ZWQtYjAyZS00ZTJiLWFhZTEtNTUxYjBmMDcyOGU2IiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42IiBleHRlbnNpb249Ik1NQyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWFkaXNvbiBNZWRpY2FsIENlbnRlciBQLiBBLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU3IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+U3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICA8L2luZm9ybWFudD4NCiAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJMT0MiPg0KICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuMzIiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIExvY2F0aW9uIiAvPg0KICAgICAgICAgICAgICAgIDxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJTRExPQyI+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuNSIgZXh0ZW5zaW9uPSI0NSIgLz4NCiAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlBST0ZGIiBkaXNwbGF5TmFtZT0iUHJvdmlkZXIncyBPZmZpY2UiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMTExIiBjb2RlU3lzdGVtTmFtZT0iUm9sZUNvZGUiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjM0IFN5Y2Ftb3JlIFN0cmVldCwgU3VpdGUgMzwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iUExDIj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+T2ZmaWNlIC0gTWFkaXNvbiBNZWRpY2FsIENlbnRlciwgUC5BLjwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudD4NCiAgICAgICAgICAgIDwvZW5jb3VudGVyPg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxlbmNvdW50ZXIgY2xhc3NDb2RlPSJFTkMiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjQ5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEVuY291bnRlciBBY3Rpdml0eSIgLz4NCiAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjE2IiBleHRlbnNpb249IjQxNSIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgY29kZT0iR0VOUkwiIGRpc3BsYXlOYW1lPSJHZW5lcmFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIj4NCiAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQ3IiAvPg0KICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklENyIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA4MDEwMyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTA4MDA4OTAwMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTlBJIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xMTU1NCBXZWVkc2lkZSBMYW5lPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5KYW1lczwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPlQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJiYzMzNDRhYy0wZDVhLTRkMzItODVmNi1jNDBiNTcyM2VjNmMiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQogICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgTG9jYXRpb24iIC8+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjQ1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUFJPRkYiIGRpc3BsYXlOYW1lPSJQcm92aWRlcidzIE9mZmljZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0LCBTdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iMTEyIiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJHRU5STCIgZGlzcGxheU5hbWU9IkdlbmVyYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiPg0KICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDgiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQ4IiAvPg0KICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgIDxlZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDgwMTAzIiAvPg0KICAgICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuNiIgZXh0ZW5zaW9uPSI5MDgwMDg5MDAwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJOUEkiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjExNTU0IFdlZWRzaWRlIExhbmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkphbWVzPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+VDwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Nb25yb2U8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3VmZml4Pk1EPC9zdWZmaXg+DQogICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9ImRjMGFlZmE0LTY1MDctNDM4Ny1hNjRjLTQxMjA1ZjMxMDFhZiIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iTE9DIj4NCiAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjMyIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEVuY291bnRlciBMb2NhdGlvbiIgLz4NCiAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iU0RMT0MiPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjUiIGV4dGVuc2lvbj0iNDUiIC8+DQogICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQUk9GRiIgZGlzcGxheU5hbWU9IlByb3ZpZGVyJ3MgT2ZmaWNlIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMSIgY29kZVN5c3RlbU5hbWU9IlJvbGVDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zNCBTeWNhbW9yZSBTdHJlZXQsIFN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9IlBMQyI+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk9mZmljZSAtIE1hZGlzb24gTWVkaWNhbCBDZW50ZXIsIFAuQS48L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICA8L2VuY291bnRlcj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICAgIDxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQogICAgICAgICAgICA8ZW5jb3VudGVyIGNsYXNzQ29kZT0iRU5DIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC40OSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi4xMC4xNiIgZXh0ZW5zaW9uPSIzMCIgLz4NCiAgICAgICAgICAgICAgPGNvZGUgY29kZT0iR0VOUkwiIGRpc3BsYXlOYW1lPSJHZW5lcmFsIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIj4NCiAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQ5IiAvPg0KICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklEOSIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTEwMiIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTA4MDA4OTAwMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTlBJIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xMTU1NCBXZWVkc2lkZSBMYW5lPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5KYW1lczwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPlQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJjMzQyOTE0Yy01ZmNkLTQ1MDQtODZhMS1iZGUxOGJmYjU4YjEiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQogICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgTG9jYXRpb24iIC8+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjQ1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUFJPRkYiIGRpc3BsYXlOYW1lPSJQcm92aWRlcidzIE9mZmljZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0LCBTdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iMjEiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkdFTlJMIiBkaXNwbGF5TmFtZT0iR2VuZXJhbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklEMTAiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQxMCIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTAwNSIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTA4MDA4OTAwMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTlBJIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xMTU1NCBXZWVkc2lkZSBMYW5lPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5KYW1lczwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPlQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIxMTI1ZTUxZi1kZjk5LTQ5NWMtOWM5Yi03MDBlZGM4Njk1OWEiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQogICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgTG9jYXRpb24iIC8+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjQ1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUFJPRkYiIGRpc3BsYXlOYW1lPSJQcm92aWRlcidzIE9mZmljZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0LCBTdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iMjAiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IkdFTlJMIiBkaXNwbGF5TmFtZT0iR2VuZXJhbCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklEMTEiIC8+DQogICAgICAgICAgICAgICAgPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgIDwvY29kZT4NCiAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY291bnRlckRlc2NyaXB0aW9uSUQxMSIgLz4NCiAgICAgICAgICAgICAgPC90ZXh0Pg0KICAgICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MDkwMyIgLz4NCiAgICAgICAgICAgICAgPC9lZmZlY3RpdmVUaW1lPg0KICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjYiIGV4dGVuc2lvbj0iOTA4MDA4OTAwMCIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iTlBJIiAvPg0KICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4xMTU1NCBXZWVkc2lkZSBMYW5lPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkNBPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5KYW1lczwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPlQ8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TW9ucm9lPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJlNWFjZGY4Yy03NWU2LTQxZjgtOWZhZS0xNTAxNDk0MGE4OTIiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQogICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgTG9jYXRpb24iIC8+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiBleHRlbnNpb249IjQ1IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUFJPRkYiIGRpc3BsYXlOYW1lPSJQcm92aWRlcidzIE9mZmljZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQgU3ljYW1vcmUgU3RyZWV0LCBTdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5PZmZpY2UgLSBNYWRpc29uIE1lZGljYWwgQ2VudGVyLCBQLkEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnRSb2xlPg0KICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgPC9lbmNvdW50ZXI+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNDkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgRW5jb3VudGVyIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuMTYiIGV4dGVuc2lvbj0iMTI2IiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJHRU5STCIgZGlzcGxheU5hbWU9IkdlbmVyYWwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiPg0KICAgICAgICAgICAgICAgIDxvcmlnaW5hbFRleHQ+DQogICAgICAgICAgICAgICAgICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5jb3VudGVyRGVzY3JpcHRpb25JRDEyIiAvPg0KICAgICAgICAgICAgICAgIDwvb3JpZ2luYWxUZXh0Pg0KICAgICAgICAgICAgICA8L2NvZGU+DQogICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmNvdW50ZXJEZXNjcmlwdGlvbklEMTIiIC8+DQogICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgPGVmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICAgICAgPGxvdyB2YWx1ZT0iMjAwNjA2MjgiIC8+DQogICAgICAgICAgICAgIDwvZWZmZWN0aXZlVGltZT4NCiAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHkgY2xhc3NDb2RlPSJBU1NJR05FRCI+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC42IiBleHRlbnNpb249Ijk5OTAwNTg3MDAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9Ik5QSSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+ODcgQmF5c2hvcmUgRHJpdmU8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5NYWRpc29uPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+OTU2NTM8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgPG5hbWU+DQogICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkRhdmlkPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+RTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5Gb3JkPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgPHN1ZmZpeD5NRDwvc3VmZml4Pg0KICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSJmZjEzMzEwMy1mM2UyLTQzM2EtODdhZC1lNmExZjVkNWY5NzAiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQogICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC4zMiIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBFbmNvdW50ZXIgTG9jYXRpb24iIC8+DQogICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNi41IiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iUFJPRkYiIGRpc3BsYXlOYW1lPSJQcm92aWRlcidzIE9mZmljZSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9IlBMQyI+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk9mZmljZSAtIE1hZGlzb24gTWVkaWNhbCBDZW50ZXIsIFAuQS48L25hbWU+DQogICAgICAgICAgICAgICAgICA8L3BsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICA8L2VuY291bnRlcj4NCiAgICAgICAgICA8L2VudHJ5Pg0KICAgICAgICA8L3NlY3Rpb24+DQogICAgICA8L2NvbXBvbmVudD4NCiAgICAgIDxjb21wb25lbnQ+DQogICAgICAgIDxzZWN0aW9uPg0KICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjIuMTgiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUGF5ZXJzIFNlY3Rpb24iIC8+DQogICAgICAgICAgPGlkIHJvb3Q9IjE1NzQ3NWMxLTk1ZTMtNDQwYS1iNzM3LWY3NWVkY2I2NzlmOCIgLz4NCiAgICAgICAgICA8Y29kZSBjb2RlPSI0ODc2OC02IiBkaXNwbGF5TmFtZT0iUEFZTUVOVCBTT1VSQ0VTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICA8dGl0bGU+SW5zdXJhbmNlPC90aXRsZT4NCiAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgIDx0YWJsZSB3aWR0aD0iMTAwJSI+DQogICAgICAgICAgICAgIDx0aGVhZD4NCiAgICAgICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgICA8dGg+UGxhbiBOYW1lPC90aD4NCiAgICAgICAgICAgICAgICAgIDx0aD5NZW1iZXIgSUQ8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPkdyb3VwICM8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlN1YnNjcmliZXI8L3RoPg0KICAgICAgICAgICAgICAgICAgPHRoPlJlbGF0aW9uc2hpcDwvdGg+DQogICAgICAgICAgICAgICAgICA8dGg+RWZmZWN0aXZlIERhdGVzPC90aD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICA8L3RoZWFkPg0KICAgICAgICAgICAgICA8dGJvZHk+DQogICAgICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgICAgPHRkIElEPSJJbnN1cmFuY2VOYW1lMCI+MSAtIEFuYWhlaW0gTWFuYWdlZCBIZWFsdGg8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjY0MzAwNTYzOTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MDQ4LTI3LTk4NzM8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPlNoYXJvbiBBIENhcmxzb248L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPlNlbGY8L3RkPg0KICAgICAgICAgICAgICAgICAgPHRkPjEwLzAzLzIwMDcgLSAxMC8wMS8yMDA4PC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgIDx0ZCBJRD0iSW5zdXJhbmNlTmFtZTEiPjIgLSBNZWRpY2FyZSBCIC0gQ2FsaWZvcm5pYTwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+NjQzMDA1NjM5PC90ZD4NCiAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+U2hhcm9uIEEgQ2FybHNvbjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+U2VsZjwvdGQ+DQogICAgICAgICAgICAgICAgICA8dGQ+MTAvMDMvMjAwNyAtIDEwLzAxLzIwMDg8L3RkPg0KICAgICAgICAgICAgICAgIDwvdHI+DQogICAgICAgICAgICAgIDwvdGJvZHk+DQogICAgICAgICAgICA8L3RhYmxlPg0KICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICA8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQogICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNjAiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgQ292ZXJhZ2UgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgIDxpZCByb290PSI1MDgzZjJhYS01ODJkLTQ3NmItYTgxNC0xZDkzMjAxMmNjM2QiIC8+DQogICAgICAgICAgICAgIDxjb2RlIGNvZGU9IjQ4NzY4LTYiIGRpc3BsYXlOYW1lPSJQQVlNRU5UIFNPVVJDRVMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiAvPg0KICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgIDxpbmZvcm1hbnQ+DQogICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjhmZTFjMGMyLTk0ZDMtNDU2YS1iZTMyLTEwYjUwM2Q5YmI4YyIgLz4NCiAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+OTkgU3ljYW1vcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgPHN0YXRlPkZMPC9zdGF0ZT4NCiAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICA8YXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjE0MC4xLjAuNiIgZXh0ZW5zaW9uPSJNTUMiIC8+DQogICAgICAgICAgICAgICAgICAgIDxuYW1lPk1hZGlzb24gTWVkaWNhbCBDZW50ZXIgUC4gQS48L25hbWU+DQogICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NyIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPlN1aXRlIDM8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxjaXR5PkdhaW5lc3ZpbGxlPC9jaXR5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MzI2MDg8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgPC9pbmZvcm1hbnQ+DQogICAgICAgICAgICAgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iQ09NUCI+DQogICAgICAgICAgICAgICAgPHNlcXVlbmNlTnVtYmVyIHZhbHVlPSIxIiAvPg0KICAgICAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC42MSIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQb2xpY3kgQWN0aXZpdHkiIC8+DQogICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuNi4xIiBleHRlbnNpb249IjA0OC0yNy05ODczIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iR1AiIGRpc3BsYXlOYW1lPSJHcm91cCBQb2xpY3kiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjU1LjEzMzYiIGNvZGVTeXN0ZW1OYW1lPSJJbnN1cmFuY2VUeXBlIENvZGUiIC8+DQogICAgICAgICAgICAgICAgICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQogICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljg3IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIFBheWVyIFBlcmZvcm1lciIgLz4NCiAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5IGNsYXNzQ29kZT0iQVNTSUdORUQiPg0KICAgICAgICAgICAgICAgICAgICAgIDxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJQQVlPUiIgZGlzcGxheU5hbWU9Ikludm9pY2UgUGF5b3IiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMTEwIiBjb2RlU3lzdGVtTmFtZT0iUm9sZUNsYXNzUmVsYXRpb25zaGlwRm9ybWFsIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjgxNDcgTlcgMTI4dGggUGxhY2U8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMTA0MCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMTAxMCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMTAyMCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24gY2xhc3NDb2RlPSJPUkciPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWUgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIG51bGxGbGF2b3I9Ik5JIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KICAgICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDT1YiPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40Ljg5IiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDb3ZlcmVkIFBhcnR5IFBhcnRpY2lwYW50IiAvPg0KICAgICAgICAgICAgICAgICAgICA8dGltZT4NCiAgICAgICAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIyMDA3MTAwMyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8aGlnaCB2YWx1ZT0iMjAwODEwMDEiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGltZT4NCiAgICAgICAgICAgICAgICAgICAgPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlBBVCI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjYuMyIgZXh0ZW5zaW9uPSI2NDMwMDU2MzkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iU0VMRiIgZGlzcGxheU5hbWU9IlNlbGYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMTExIiBjb2RlU3lzdGVtTmFtZT0iUm9sZUNvZGUiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MzQ1NiBXZXN0IFBhbG08L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPkFwdC4gIzM0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXR5Pk1hZGlzb248L2NpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Q0E8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNvdW50cnk+VVM8L2NvdW50cnk+DQogICAgICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT45NTY1MzwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTMyOTMiIHVzZT0iSFAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTU1NDQiIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPHBsYXlpbmdFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPlNoYXJvbjwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgICAgICAgIDxnaXZlbj5BPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5DYXJsc29uPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c2R0YzpiaXJ0aFRpbWUgdmFsdWU9IjE5MzgxMjEyIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvcGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgPC9wYXJ0aWNpcGFudFJvbGU+DQogICAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Pg0KICAgICAgICAgICAgICAgICAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCiAgICAgICAgICAgICAgICAgICAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkRFRiI+DQogICAgICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjYuNSIgZXh0ZW5zaW9uPSI3OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWZlcmVuY2UgdmFsdWU9IiNJbnN1cmFuY2VOYW1lMCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+DQogICAgICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgICAgICA8L2FjdD4NCiAgICAgICAgICAgICAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCiAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgIDwvZW50cnk+DQogICAgICAgICAgPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCiAgICAgICAgICAgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi40LjYwIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIENvdmVyYWdlIEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICA8aWQgcm9vdD0iNWUxYTcyMDUtODVmYS00MTBiLThhNTctNzk4MjY5MjY3NmNkIiAvPg0KICAgICAgICAgICAgICA8Y29kZSBjb2RlPSI0ODc2OC02IiBkaXNwbGF5TmFtZT0iUEFZTUVOVCBTT1VSQ0VTIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgLz4NCiAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICA8aW5mb3JtYW50Pg0KICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgIDxpZCByb290PSI0OWM0NWFlZi04NzQ3LTQ0MWMtYWYyZS1lNzU2ZWRjNjVmY2MiIC8+DQogICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjk5IFN5Y2Ftb3JlIFN0cmVldDwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgPGNpdHk+R2FpbmVzdmlsbGU8L2NpdHk+DQogICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5GTDwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICA8cG9zdGFsQ29kZT4zMjYwODwvcG9zdGFsQ29kZT4NCiAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIHZhbHVlPSJ0ZWw6KzEtOTE2LTU1NS03NjU0IiB1c2U9IldQIiAvPg0KICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYiIGV4dGVuc2lvbj0iTU1DIiAvPg0KICAgICAgICAgICAgICAgICAgICA8bmFtZT5NYWRpc29uIE1lZGljYWwgQ2VudGVyIFAuIEEuPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNzY1NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gdmFsdWU9InRlbDorMS05MTYtNTU1LTc2NTciIHVzZT0iV1AiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhZGRyPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT45OSBTeWNhbW9yZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT5TdWl0ZSAzPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICAgICAgICA8Y2l0eT5HYWluZXN2aWxsZTwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICA8c3RhdGU+Rkw8L3N0YXRlPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb3VudHJ5PlVTPC9jb3VudHJ5Pg0KICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjMyNjA4PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgIDwvaW5mb3JtYW50Pg0KICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IkNPTVAiPg0KICAgICAgICAgICAgICAgIDxzZXF1ZW5jZU51bWJlciB2YWx1ZT0iMiIgLz4NCiAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCiAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuNjEiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDREEgUG9saWN5IEFjdGl2aXR5IiAvPg0KICAgICAgICAgICAgICAgICAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuMTQwLjEuMC42LjEwLjYuMSIgZXh0ZW5zaW9uPSIwIiAvPg0KICAgICAgICAgICAgICAgICAgPGNvZGUgY29kZT0iMTIiIGRpc3BsYXlOYW1lPSJNZWRpY2FyZSBTZWNvbmRhcnkgV29ya2luZyBBZ2VkIEJlbmVmaWNpYXJ5IG9yIFNwb3VzZSB3aXRoIEVtcGxveWVyIEdyb3VwIEhlYWx0aCBQbGFuIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjI1NS4xMzM2IiBjb2RlU3lzdGVtTmFtZT0iSW5zdXJhbmNlVHlwZSBDb2RlIiAvPg0KICAgICAgICAgICAgICAgICAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMjIuNC44NyIgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEQSBQYXllciBQZXJmb3JtZXIiIC8+DQogICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eSBjbGFzc0NvZGU9IkFTU0lHTkVEIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuNi4yIiBleHRlbnNpb249IlNNQ0ExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIGNvZGU9IlBBWU9SIiBkaXNwbGF5TmFtZT0iSW52b2ljZSBQYXlvciIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTAiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ2xhc3NSZWxhdGlvbnNoaXBGb3JtYWwiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPGFkZHI+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+MjYzIFN1bm55ZGFsZSBXYXk8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjU1PC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNTU2NSIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNTU2MiIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNTU2NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24gY2xhc3NDb2RlPSJPUkciPg0KICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TWVkaWNhcmUgUGFydCBCIG9mIENhbGlmb3JuaWEgLSBOb3J0aGVybiBDYWxpZm9ybmlhPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gbnVsbEZsYXZvcj0iTkkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICA8YWRkciBudWxsRmxhdm9yPSJOSSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQogICAgICAgICAgICAgICAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNPViI+DQogICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjIyLjQuODkiIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNvdmVyZWQgUGFydHkgUGFydGljaXBhbnQiIC8+DQogICAgICAgICAgICAgICAgICAgIDx0aW1lPg0KICAgICAgICAgICAgICAgICAgICAgIDxsb3cgdmFsdWU9IjIwMDcxMDAzIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxoaWdoIHZhbHVlPSIyMDA4MTAwMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC90aW1lPg0KICAgICAgICAgICAgICAgICAgICA8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iUEFUIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuNi4zIiBleHRlbnNpb249IjY0MzAwNTYzOSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8Y29kZSBjb2RlPSJTRUxGIiBkaXNwbGF5TmFtZT0iU2VsZiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8YWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT4zNDU2IFdlc3QgUGFsbTwvc3RyZWV0QWRkcmVzc0xpbmU+DQogICAgICAgICAgICAgICAgICAgICAgICA8c3RyZWV0QWRkcmVzc0xpbmU+QXB0LiAjMzQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGNpdHk+TWFkaXNvbjwvY2l0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzdGF0ZT5DQTwvc3RhdGU+DQogICAgICAgICAgICAgICAgICAgICAgICA8Y291bnRyeT5VUzwvY291bnRyeT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjk1NjUzPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgICAgICAgICAgIDwvYWRkcj4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtMzI5MyIgdXNlPSJIUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSB2YWx1ZT0idGVsOisxLTkxNi01NTUtNTU0NCIgdXNlPSJXUCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICA8cGxheWluZ0VudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4+U2hhcm9uPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkE8L2dpdmVuPg0KICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5PkNhcmxzb248L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzZHRjOmJpcnRoVGltZSB2YWx1ZT0iMTkzODEyMTIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgPC9wbGF5aW5nRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICA8L3BhcnRpY2lwYW50Um9sZT4NCiAgICAgICAgICAgICAgICAgIDwvcGFydGljaXBhbnQ+DQogICAgICAgICAgICAgICAgICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KICAgICAgICAgICAgICAgICAgICA8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iREVGIj4NCiAgICAgICAgICAgICAgICAgICAgICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy4xNDAuMS4wLjYuMTAuNi41IiBleHRlbnNpb249Ijg5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDxjb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0Pg0KICAgICAgICAgICAgICAgICAgICAgICAgPHJlZmVyZW5jZSB2YWx1ZT0iI0luc3VyYW5jZU5hbWUxIiAvPg0KICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD4NCiAgICAgICAgICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgICAgIDwvYWN0Pg0KICAgICAgICAgICAgICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KICAgICAgICAgICAgPC9hY3Q+DQogICAgICAgICAgPC9lbnRyeT4NCiAgICAgICAgPC9zZWN0aW9uPg0KICAgICAgPC9jb21wb25lbnQ+DQogICAgICA8Y29tcG9uZW50Pg0KICAgICAgICA8c2VjdGlvbj4NCiAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4yMi4yLjIxIiBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0RBIEFkdmFuY2UgRGlyZWN0aXZlcyBTZWN0aW9uIiAvPg0KICAgICAgICAgIDxpZCByb290PSJmNzZhZDBlYS03YzEwLTRhZmYtYThhMC00MWJiNGQ3MGNmYjYiIC8+DQogICAgICAgICAgPGNvZGUgY29kZT0iNDIzNDgtMyIgZGlzcGxheU5hbWU9IkFEVkFOQ0UgRElSRUNUSVZFUyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIC8+DQogICAgICAgICAgPHRpdGxlPkFkdmFuY2UgRGlyZWN0aXZlczwvdGl0bGU+DQogICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICA8Y29udGVudD5ObyBBZHZhbmNlIERpcmVjdGl2ZXMgUmVjb3JkZWQ8L2NvbnRlbnQ+DQogICAgICAgICAgPC90ZXh0Pg0KICAgICAgICA8L3NlY3Rpb24+DQogICAgICA8L2NvbXBvbmVudD4NCiAgICA8L3N0cnVjdHVyZWRCb2R5Pg0KICA8L2NvbXBvbmVudD4NCjwvQ2xpbmljYWxEb2N1bWVudD4=","base64").toString();
        var result = bb.parseString(data);

        // check validation
        var val = bb.validator.validateDocumentModel(result);

        // generate ccda
        var xml = bbg.generateCCD(result);

        // parse generated ccda
        var result2 = bb.parseString(xml);

        // re-generate
        var xml2 = bbg.generateCCD(result2);

        delete result.errors;
        delete result2.errors;

        assert.deepEqual(result2, result);
    });

    it('VA_CCD_Sample_File_Version_12_5_1.xml should still be same', function () {
        var data = Buffer("PD94bWwgdmVyc2lvbj0iMS4wIj8+DQo8P3htbC1zdHlsZXNoZWV0IHR5cGU9InRleHQveHNsIiBocmVmPSJDQ0QueHNsIj8+DQo8Q2xpbmljYWxEb2N1bWVudCB4bWxucz0idXJuOmhsNy1vcmc6djMiIHhtbG5zOnZvYz0idXJuOmhsNy1vcmc6djMvdm9jIiB4bWxuczp4c2k9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlIiB4c2k6c2NoZW1hTG9jYXRpb249InVybjpobDctb3JnOnYzIGh0dHA6Ly94cmVnMi5uaXN0LmdvdjoxMTA4MC9oaXRzcFZhbGlkYXRpb24vc2NoZW1hL2NkYXIyYzMyL2luZnJhc3RydWN0dXJlL2NkYS9DMzJfQ0RBLnhzZCI+DQoJPCEtLSANCiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KICAgIENEQSBIZWFkZXINCiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KICAgIC0tPg0KICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICBBZGQgcmVhbG1Db2RlIC0tPg0KICAgIDxyZWFsbUNvZGUgY29kZT0iVVMiIC8+DQoJPCEtLSBGb2xsb3dpbmcgdGVtcGxhdGUgaXMgSEw3IENEQSBSZWxlYXNlIDIgLS0+DQoJPCEtLSBQT0NEX0hEMDAwMDQwIGlzIGZvciBMYWIuUmVwb3J0LkNsaW5pY2FsLkRvY3VtZW50IC0tPg0KCTx0eXBlSWQgZXh0ZW5zaW9uPSJQT0NEX0hEMDAwMDQwIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xLjMiIC8+DQoJPCEtLSBISVRTUCBDMzIgVjIuNTogIFRlbXBsYXRlIGZvciBJSEUgUENDIE1lZGljYWwgRG9jdW1lbnRzIHNwZWNpZmljYXRpb24gLS0+DQoJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS4xLjEiIC8+DQoJPCEtLSBGb2xsb3dpbmcgdGVtcGxhdGUgaXMgdGhlIENDRCB2MS4wIFRlbXBsYXRlcyBSb290IC0tPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEiIC8+DQoJPCEtLSBISVRTUCBDMzIgVjIuNTogIFRlbXBsYXRlIGZvciBITDcgR2VuZXJhbCBIZWFkZXIgY29uc3RyYWludHMtLT4NCgk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4zIiAvPg0KCTwhLS0gRm9sbG93aW5nIHRlbXBsYXRlIGlzIHRoZSBISVRTUC9DMzIgUmVnaXN0cmF0aW9uIGFuZCBNZWRpY2F0aW9uIFRlbXBsYXRlIC0tPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuMSIgLz4NCgk8IS0tIEhJVFNQIEMzMiBWMi41OiAgVGVtcGxhdGUgZm9yIEhJVFNQIEMzMiBWMi41IC0tPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMSIgLz4NCgk8IS0tIENEQSBEb2N1bWVudCBJZGVudGlmZXIsIGlkPVZBIE9JRCwgZXh0ZW5zaW9uPXN5c3RlbS1nZW5lcmF0ZWQgLS0+DQoJPGlkIGV4dGVuc2lvbj0iMi4yNS4xNTM5NjczMjAzOTExNzEyNjAxOTU4NjkxOTI3NDMwNTE4NzY5NDAiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCTwhLS0gQ0RBIERvY3VtZW50IENvZGUgLS0+DQoJPGNvZGUgY29kZT0iMzQxMzMtOSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iU3VtbWFyaXphdGlvbiBvZiBFcGlzb2RlIE5vdGUiIC8+DQoJPCEtLSBDREEgRG9jdW1lbnQgVGl0bGUgLS0+DQoJPHRpdGxlPkRlcGFydG1lbnQgb2YgVmV0ZXJhbnMgQWZmYWlycyBTdW1tYXJpemF0aW9uIG9mIEVwaXNvZGUgTm90ZTwvdGl0bGU+DQoJPCEtLSAxLjAxIERPQ1VNRU5UIFRJTUVTVEFNUCwgUkVRVUlSRUQgLS0+DQoJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTMwMzE1MDg0NzEwLTA1MDAiIC8+DQoJPCEtLSBDREEgQ29uZmllZG50aWFsaXR5IENvZGUgLS0+DQoJPGNvbmZpZGVudGlhbGl0eUNvZGUgY29kZT0iTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4yNSIgLz4NCgk8IS0tIENEQSBET0NVTUVOVCBMQU5HVUFHRSAtLT4NCgk8bGFuZ3VhZ2VDb2RlIGNvZGU9ImVuLVVTIiAvPg0KCTwhLS0gDQoJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCglQRVJTT04gSU5GT1JNQVRJT04gQ09OVEVOVCBNT0RVTEUsIFJFUVVJUkVEDQoJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgktLT4NCiAgICA8cmVjb3JkVGFyZ2V0Pg0KICAgICAgICA8cGF0aWVudFJvbGU+DQoJCQk8IS0tIDEuMDIgUEVSU09OIElELCBSRVFVSVJFRCwgaWQ9VkEgT0lELCBleHRlbnNpb249R1VJRCAtLT4NCiAgICAgICAgICAgIDxpZCBleHRlbnNpb249IjEwMTI2Mzg5MjRWNTQ2NzA5IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCTwhLS0gIDEuMDMgUEVSU09OIEFERFJFU1MtSE9NRSBQRVJNQU5FTlQsIFJFUVVJUkVEIC0tPg0KICAgICAgICAgICAgPGFkZHIgdXNlPSJIUCI+DQogICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjEyMyBBbnl3aGVyZSBSb2FkPC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICA8Y2l0eT5Bbnl3aGVyZTwvY2l0eT4NCiAgICAgICAgICAgICAgICA8c3RhdGU+REM8L3N0YXRlPg0KICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjAwMDAxPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgPC9hZGRyPg0KCQkJPCEtLSAxLjA0IFBFUlNPTiBQSE9ORS9FTUFJTC9VUkwsIFJFUVVJUkVEIC0tPg0KICAgICAgICAgICAgPHRlbGVjb20gdXNlPSJIUCIgdmFsdWU9InRlbDorMS0wMDAtMDAwLTAwMDEiIC8+DQogICAgICAgICAgICA8cGF0aWVudD4NCgkJCQk8IS0tICAxLjA1IFBFUlNPTiBOQU1FIExFR0FMLCBSRVFVSVJFRCAtLT4NCiAgICAgICAgICAgICAgICA8bmFtZSB1c2U9IkwiPg0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgPGdpdmVuPk5XSElOT05FPC9naXZlbj4NCiAgICAgICAgICAgICAgICAgICAgPGZhbWlseT5OV0hJTlpaWlRFU1RQQVRJRU5UPC9mYW1pbHk+DQogICAgICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIDwvbmFtZT4NCgkJCQk8IS0tICAxLjA1IFBFUlNPTiBOQU1FIEFsaWFzIE5hbWUsIE9wdGlvbmFsIC0tPg0KICAgICAgICAgICAgICAgIDxuYW1lIHVzZT0iUCI+DQogICAgICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgICAgICA8Z2l2ZW4gbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICA8ZmFtaWx5IG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgPC9uYW1lPg0KCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDEuMDYgR0VOREVSLCBSRVFVSVJFRCBBTkQgUkVRVUlSRUQgVGVybWlub2xvZ3kgLS0+DQoJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogV2hlbiBWaXN0YSB2YWx1ZSBpcyBNLCBGLCBzZW5kIGFzIEhMN0FkbWluR2VuZGVyQ29kZSAgLS0+DQoJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogV2hlbiBWaXN0YSB2YWx1ZSBpcyAiVW5rbm93biIsIHNlbmQgYXMgZ2VuZGVyQ29kZSBudWxsRmxhdm9yPVVOSyIgIC0tPg0KICAgICAgICAgICAgICAgIDxhZG1pbmlzdHJhdGl2ZUdlbmRlckNvZGUgY29kZT0iTSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xIiBjb2RlU3lzdGVtTmFtZT0iQWRtaW5pc3RyYXRpdmVHZW5kZXJDb2RlIiBkaXNwbGF5TmFtZT0iTWFsZSI+DQoJCQkJCTxvcmlnaW5hbFRleHQ+TUFMRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCTwvYWRtaW5pc3RyYXRpdmVHZW5kZXJDb2RlPg0KCQkJCTwhLS0gMS4wNyBQRVJTT04gREFURSBPRiBCSVJUSCwgUkVRVUlSRUQgLS0+DQogICAgICAgICAgICAgICAgPGJpcnRoVGltZSB2YWx1ZT0iMTk4MTAxMDEiIC8+DQoJCQkJPCEtLSAgMS4wOCBNQVJJVEFMIFNUQVRVUywgT3B0aW9uYWwtUjIgLS0+DQoJCQkJPCEtLSBWTEVSIFNFRyAxQjogIFNlbmQgYXMgSEw3IE1hcml0YWxTdGF0dXMgIC0tPg0KCQkJCTxtYXJpdGFsU3RhdHVzQ29kZSBjb2RlPSJNIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjIiIGNvZGVTeXN0ZW1OYW1lPSJNYXJpdGFsU3RhdHVzQ29kZSIgZGlzcGxheU5hbWU9Ik1hcnJpZWQiPg0KCQkJCQk8b3JpZ2luYWxUZXh0Pk1BUlJJRUQ8L29yaWdpbmFsVGV4dD4NCgkJCQk8L21hcml0YWxTdGF0dXNDb2RlPg0KCQkJCTwhLS0gIDEuMDkgUkVMSUdJT1VTIEFGRklMSUFUSU9OLCBPcHRpb25hbCwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVklzdEEgUlBDcy0tPg0KCQkJCTwhLS0gIDEuMTAgUkFDRSwgT3B0aW9uYWwgLS0+DQoJCQkJPCEtLSAgMS4xMCBSQUNFIGFzIG9yaWdpbmFsVGV4dCBwZXIgTkhJTiBDb3JlIENvbnRlbnQgU3BlY2lmaWNhdGlvbiBiL2MgVkEgY29kZSB0cmFuc2xhdGlvbiBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCiAgICAgICAgICAgICAgICA8cmFjZUNvZGUgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yMzgiIGNvZGVTeXN0ZW1OYW1lPSJDREMgUmFjZSBhbmQgRXRobmljaXR5IiBudWxsRmxhdm9yPSJVTksiPg0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICA8L3JhY2VDb2RlPg0KCQkJCTwhLS0gMS4xMSBFVEhOSUNJVFksIE9wdGlvbmFsIC0tPg0KCQkJCTwhLS0gMS4xMSBFVEhOSUNJVFkgYXMgb3JpZ2luYWxUZXh0IHBlciBOSElOIENvcmUgQ29udGVudCBTcGVjaWZpY2F0aW9uIGIvYyBWQSBjb2RlIHRyYW5zbGF0aW9uIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgIDxldGhuaWNHcm91cENvZGUgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4yMzgiIGNvZGVTeXN0ZW1OYW1lPSJDREMgUmFjZSBhbmQgRXRobmljaXR5IiBudWxsRmxhdm9yPSJVTksiPg0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICA8L2V0aG5pY0dyb3VwQ29kZT4NCgkJCQk8IS0tIA0KCQkJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJCQkJTEFOR1VBR0UgU1BPS0VOIENPTlRFTlQgTU9EVUxFDQoJCQkJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgkJCQktLT4NCiAgICAgICAgICAgICAgICA8bGFuZ3VhZ2VDb21tdW5pY2F0aW9uPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjIiIC8+DQoJCQkJCTwhLS0gIDIuMDEgTEFOR1VBR0UsIFJFUVVJUkVELCBsYW5ndWFnZUNvZGUgYXMgbnVsbEZsYXZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPGxhbmd1YWdlQ29kZSBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgPC9sYW5ndWFnZUNvbW11bmljYXRpb24+DQogICAgICAgICAgICA8L3BhdGllbnQ+DQogICAgICAgIDwvcGF0aWVudFJvbGU+DQogICAgPC9yZWNvcmRUYXJnZXQ+DQoJPCEtLSANCgkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCUlORk9STUFUSU9OIFNPVVJDRSBDT05URU5UIE1PRFVMRSwgUkVRVUlSRUQNCgkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCS0tPg0KCTwhLS0gQVVUSE9SIFNFQ1RJT04gKFJFUVVJUkVEKSBPRiBJTkZPUk1BVElPTiBTT1VSQ0UgQ09OVEVOVCBNT0RVTEUgLS0+DQoJPGF1dGhvcj4NCgkJPCEtLSAxMC4wMSBBVVRIT1IgVElNRSAoPURvY3VtZW50IENyZWF0aW9uIERhdGUpLCBSRVFVSVJFRCAtLT4NCgkJPHRpbWUgdmFsdWU9IjIwMTMwMzE1MDg0NzEwLTA1MDAiIC8+DQoJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCTwhLS0gMTAuMDIgQVVUSE9SIElEIChWQSBPSUQpIChhdXRob3JPSUQpLCBSRVFVSUlSRUQgLS0+DQoJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQXNzaWduZWQgQXV0aG9yIEFkZHJlc3MgUmVxdWlyZWQsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJPGFkZHIgLz4NCgkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBBc3NpZ25lZCBBdXRob3IgIFRlbGVjb20gUmVxdWlyZWQsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJPHRlbGVjb20gLz4NCgkJCTwhLS0gMTAuMDIgQVVUSE9SIE5BTUUgUkVRVUlSRUQgLS0+DQoJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQzgzICBhc3NpZ25lZFBlcnNvbi9BdXRob3IgTmFtZSBSRVFVSVJFRCBidXQgcHJvdmlkZWQgYXMgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24tLT4NCgkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQk8bmFtZSAvPg0KCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCTwhLS0gMTAuMDIgQVVUSE9SIE5BTUUgUkVRVUlSRUQgYXMgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24tLT4NCgkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQk8IS0tIDEwLjAyIEFVVEhPUklORyBERVZJQ0UgT1JHQU5JWkFUSU9OIE9JRCAoVkEgT0lEKSAoZGV2aWNlT3JnT0lEKSwgUkVRVUlJUkVEIC0tPg0KCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQk8IS0tIDEwLjAyIEFVVEhPUklORyBERVZJQ0UgT1JHQU5JWkFUSU9OIE5BTUUgKGRldmljZU9yZ05hbWUpLCBSRVFVSUlSRUQgLS0+DQoJCQkJPG5hbWU+RGVwYXJ0bWVudCBvZiBWZXRlcmFucyBBZmZhaXJzPC9uYW1lPg0KCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBBc3NpZ25lZCBBdXRob3IgIFRlbGVjb20gUmVxdWlyZWQsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCTx0ZWxlY29tIC8+DQoJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEFzc2lnbmVkIEF1dGhvciBBZGRyZXNzIFJlcXVpcmVkLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQk8YWRkciAvPg0KCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJPC9hc3NpZ25lZEF1dGhvcj4NCgk8L2F1dGhvcj4NCgk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBTRUNUSU9OIChPUFRJT05BTClPRiBJTkZPUk1BVElPTiBTT1VSQ0UgQ09OVEVOVCBNT0RVTEUgLS0+DQoJPCEtLSAxMC4wNiBJTkZPUk1BVElPTiBTT1VSQ0UgQVMgQU4gT1JHQU5JWkFUSU9OLCBSRVFVSVJFRCAtLT4NCgk8aW5mb3JtYW50Pg0KCQk8YXNzaWduZWRFbnRpdHk+DQoJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGluZm9ybWFudC9hc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQk8YWRkciAvPg0KCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaW5mb3JtYW50L2Fzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCTx0ZWxlY29tIC8+DQoJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgYXNzaWduZWRQZXJzb24gUmVxdWlyZWQgZm9yIGluZm9ybWFudC9hc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIE5hbWUgUmVxdWlyZWQgZm9yIGluZm9ybWFudC9hc3NpZ25lZEVudGl0eS9hc3NpZ25lZFBlcnNvbiAtLT4NCgkJCQk8bmFtZT5EZXBhcnRtZW50IG9mIFZldGVyYW5zIEFmZmFpcnM8L25hbWU+DQoJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCTwhLS0gMTAuMDYgSU5GT1JNQVRJT04gU09VUkNFIE9SR0FOSVpBVElPTiBPSUQgKFZBIE9JRCkgKHNvdXJjZU9yZ09JRCksIFJFUVVJUkVEIC0tPg0KCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQk8IS0tIDEwLjA2IElORk9STUFUSU9OIFNPVVJDRSBPUkdBTklaQVRJT04gTkFNRSAoc291cmNlT3JnTmFtZSksIFJFUVVJUkVEIC0tPg0KCQkJCTxuYW1lPkRlcGFydG1lbnQgb2YgVmV0ZXJhbnMgQWZmYWlyczwvbmFtZT4NCgkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJPHRlbGVjb20gLz4NCgkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQk8YWRkciAvPg0KCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJPC9hc3NpZ25lZEVudGl0eT4NCgk8L2luZm9ybWFudD4NCgk8IS0tIA0KCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJQ0NEIENEQSBSMiBDVVNUT0RJQU4gQVMgQU4gT1JHQU5JWkFUSU9OLCBSRVFVSVJFRA0KCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJLS0+DQoJPGN1c3RvZGlhbj4NCgkJPGFzc2lnbmVkQ3VzdG9kaWFuPg0KCQkJPHJlcHJlc2VudGVkQ3VzdG9kaWFuT3JnYW5pemF0aW9uPg0KCQkJCTwhLS0gQ0NEIENEQSBSMiBDVVNUT0RJQU4gT0lEIChWQSkgKGN1c3RvZGlhbk9JRCkgLS0+DQoJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCTwhLS0gQ0NEIENEQSBSMiBDVVNUT0RJQU4gTkFNRSAoY3VzdG9kaWFuTmFtZSkgLS0+DQoJCQkJPG5hbWU+RGVwYXJ0bWVudCBvZiBWZXRlcmFucyBBZmZhaXJzPC9uYW1lPg0KCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQk8dGVsZWNvbSAvPg0KCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCTxhZGRyIC8+DQoJCQk8L3JlcHJlc2VudGVkQ3VzdG9kaWFuT3JnYW5pemF0aW9uPg0KCQk8L2Fzc2lnbmVkQ3VzdG9kaWFuPg0KCTwvY3VzdG9kaWFuPg0KICAgIDwhLS0gDQoJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCglDQ0QgQ0RBIFIyIExFR0FMIEFVVEhFTlRJQ0FUT1IgQVMgQU4gT1JHQU5JWkFUSU9OLCBSRVFVSVJFRA0KCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJLS0+DQoJPGxlZ2FsQXV0aGVudGljYXRvcj4NCgkJPCEtLSBDQ0QgQ0RBIFIyIFRJTUUgT0YgQVVUSEVOVElDQVRJT04gLS0+DQoJCTx0aW1lIHZhbHVlPSIyMDEzMDMxNTA4NDcxMC0wNTAwIiAvPg0KCQk8c2lnbmF0dXJlQ29kZSBjb2RlPSJTIiAvPg0KCQk8YXNzaWduZWRFbnRpdHk+DQoJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCTxhZGRyIC8+DQoJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQk8dGVsZWNvbSAvPg0KCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBhc3NpZ25lZCBQZXJzb24gUmVxdWlyZWQgZm9yIGxlZ2FsQXV0aGVudGljYXRvci9hc3NpZ25lZEVudGl0eSAgLS0+DQoJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJPG5hbWU+RGVwYXJ0bWVudCBvZiBWZXRlcmFucyBBZmZhaXJzPC9uYW1lPg0KCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQk8IS0tIENDRCBDREEgUjIgTEVHQUwgQVVUSEVOVElDQVRPUiBPSUQgKFZBKSAgLS0+DQoJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCTwhLS0gQ0NEIENEQSBSMiBMRUdBTCBBVVRIRU5USUNBVE9SIE5BTUUgKGF1dGhlbnRpY2F0b3JOYW1lKSAtLT4NCgkJCQk8bmFtZT5EZXBhcnRtZW50IG9mIFZldGVyYW5zIEFmZmFpcnM8L25hbWU+DQoJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCTx0ZWxlY29tIC8+DQoJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJPGFkZHIgLz4NCgkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCTwvYXNzaWduZWRFbnRpdHk+DQoJPC9sZWdhbEF1dGhlbnRpY2F0b3I+DQoJPCEtLSANCiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KICAgIFNVUFBPUlQgQ09OVEVOVCBNT0RVTEUsIFJFUVVJUkVEDQogICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCiAgICAtLT4NCiAgICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IklORCI+IDwhLS0gcGFydGljaXBhbnQgYmxvY2sgcmVwZWF0ZWQgZm9yIE5PSyBhbmQgRUNPTiAtLT4NCiAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS4zMi4zIiAvPg0KICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBJSEUgU3VwcG9ydCBUZW1wbGF0ZSAtLT4NCgkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS4yLjQiIC8+DQoJCTwhLS0gIDMuMDEgREFURSwgUkVRVUlSRUQgLS0+DQoJCTwhLS0gIDMuMDEgREFURSBkYXRlIGFzIG51bGxGbGF2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQogICAgICAgIDx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJPCEtLSAgMy4wMiBDT05UQUNUIFRZUEUsIFJFUVVJUkVELCBjbGFzc0NvZGUgdmFsdWUgZGV0ZXJtaW5lZCBieSBWaXN0QSB2YWx1ZSBpbiBjb250YWN0VHlwZSAtLT4NCiAgICAgICAgPGFzc29jaWF0ZWRFbnRpdHkgY2xhc3NDb2RlPSJFQ09OIj4NCgkJCTwhLS0gIDMuMDMgQ09OVEFDVCBSRUxBVElPTlNISVAgYXMgb3JpZ2luYWxUZXh0IHBlciBOSElOIENvcmUgQ29udGVudCBTcGVjaWZpY2F0aW9uIGIvYyBWQSBjb2RlIHRyYW5zbGF0aW9uIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgPGNvZGUgY29kZT0iVU5LIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMSIgY29kZVN5c3RlbU5hbWU9IlJvbGVDb2RlIj4NCiAgICAgICAgICAgICAgICA8b3JpZ2luYWxUZXh0PlNpYmxpbmc8L29yaWdpbmFsVGV4dD4NCiAgICAgICAgICAgIDwvY29kZT4NCgkJCTwhLS0gIDMuMDQgQ09OVEFDVCBBZGRyZXNzcywgSG9tZSBQZXJtYW5lbnQsIE9wdGlvbmFsLVIyIC0tPg0KICAgICAgICAgICAgPGFkZHIgdXNlPSJIUCI+DQogICAgICAgICAgICAgICAgPHN0cmVldEFkZHJlc3NMaW5lPjQ1NiBBbnl3aGVyZSBTdHJlZXQ8L3N0cmVldEFkZHJlc3NMaW5lPg0KICAgICAgICAgICAgICAgIDxjaXR5PkFueXdoZXJlPC9jaXR5Pg0KICAgICAgICAgICAgICAgIDxzdGF0ZT5EQzwvc3RhdGU+DQogICAgICAgICAgICAgICAgPHBvc3RhbENvZGU+MDAwMDE8L3Bvc3RhbENvZGU+DQogICAgICAgICAgICA8L2FkZHI+DQogICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSAgLS0+DQoJCQk8IS0tICAzLjA1IENPTlRBQ1QgUEhPTkUvRU1BSUwvVVJMLCBPcHRpb25hbC1SMiwgIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQk8dGVsZWNvbSB1c2U9IkhQIiB2YWx1ZT0idGVsOisxLTAwMC0wMDAtMDAwMSIgLz4NCiAgICAgICAgICAgIDxhc3NvY2lhdGVkUGVyc29uPg0KCQkJCTwhLS0gMy4wNiBDT05UQUNUIE5BTUUsIFJFUVVJUkVEIC0tPg0KICAgICAgICAgICAgICAgIDxuYW1lPg0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgPGdpdmVuPkVNRVJHRU5DWTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TldISU5aWlpURVNUUEFUSUVOVDwvZmFtaWx5Pg0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICA8L25hbWU+DQogICAgICAgICAgICA8L2Fzc29jaWF0ZWRQZXJzb24+DQogICAgICAgIDwvYXNzb2NpYXRlZEVudGl0eT4NCiAgICA8L3BhcnRpY2lwYW50PjxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iSU5EIj4gPCEtLSBwYXJ0aWNpcGFudCBibG9jayByZXBlYXRlZCBmb3IgTk9LIGFuZCBFQ09OIC0tPg0KICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjMiIC8+DQogICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIElIRSBTdXBwb3J0IFRlbXBsYXRlIC0tPg0KCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjIuNCIgLz4NCgkJPCEtLSAgMy4wMSBEQVRFLCBSRVFVSVJFRCAtLT4NCgkJPCEtLSAgMy4wMSBEQVRFIGRhdGUgYXMgbnVsbEZsYXZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQk8IS0tICAzLjAyIENPTlRBQ1QgVFlQRSwgUkVRVUlSRUQsIGNsYXNzQ29kZSB2YWx1ZSBkZXRlcm1pbmVkIGJ5IFZpc3RBIHZhbHVlIGluIGNvbnRhY3RUeXBlIC0tPg0KICAgICAgICA8YXNzb2NpYXRlZEVudGl0eSBjbGFzc0NvZGU9Ik5PSyI+DQoJCQk8IS0tICAzLjAzIENPTlRBQ1QgUkVMQVRJT05TSElQIGFzIG9yaWdpbmFsVGV4dCBwZXIgTkhJTiBDb3JlIENvbnRlbnQgU3BlY2lmaWNhdGlvbiBiL2MgVkEgY29kZSB0cmFuc2xhdGlvbiBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCiAgICAgICAgICAgIDxjb2RlIGNvZGU9IlVOSyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGNvZGVTeXN0ZW1OYW1lPSJSb2xlQ29kZSI+DQogICAgICAgICAgICAgICAgPG9yaWdpbmFsVGV4dD5icm90aGVyPC9vcmlnaW5hbFRleHQ+DQogICAgICAgICAgICA8L2NvZGU+DQoJCQk8IS0tICAzLjA0IENPTlRBQ1QgQWRkcmVzc3MsIEhvbWUgUGVybWFuZW50LCBPcHRpb25hbC1SMiAtLT4NCiAgICAgICAgICAgIDxhZGRyIHVzZT0iSFAiPg0KICAgICAgICAgICAgICAgIDxzdHJlZXRBZGRyZXNzTGluZT43ODkgQW55d2hlcmUgU3RyZWV0PC9zdHJlZXRBZGRyZXNzTGluZT4NCiAgICAgICAgICAgICAgICA8Y2l0eT5Bbnl3aGVyZTwvY2l0eT4NCiAgICAgICAgICAgICAgICA8c3RhdGU+REM8L3N0YXRlPg0KICAgICAgICAgICAgICAgIDxwb3N0YWxDb2RlPjAwMDAxPC9wb3N0YWxDb2RlPg0KICAgICAgICAgICAgPC9hZGRyPg0KICAgICAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHkgIC0tPg0KCQkJPCEtLSAgMy4wNSBDT05UQUNUIFBIT05FL0VNQUlML1VSTCwgT3B0aW9uYWwtUjIsICBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJPHRlbGVjb20gdXNlPSJIUCIgdmFsdWU9InRlbDorMS0wMDAtMDAwLTAwMDEiIC8+DQogICAgICAgICAgICA8YXNzb2NpYXRlZFBlcnNvbj4NCgkJCQk8IS0tIDMuMDYgQ09OVEFDVCBOQU1FLCBSRVFVSVJFRCAtLT4NCiAgICAgICAgICAgICAgICA8bmFtZT4NCiAgICAgICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgIDxnaXZlbj5OV0hJTk9ORTwvZ2l2ZW4+DQogICAgICAgICAgICAgICAgICAgIDxmYW1pbHk+TldISU5aWlpOT0s8L2ZhbWlseT4NCiAgICAgICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgPC9uYW1lPg0KICAgICAgICAgICAgPC9hc3NvY2lhdGVkUGVyc29uPg0KICAgICAgICA8L2Fzc29jaWF0ZWRFbnRpdHk+DQogICAgPC9wYXJ0aWNpcGFudD4NCgk8IS0tIA0KCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJQ0NEIENEQSBSMiBET0NVTUVOVEFUSU9OIE9GIE1PRFVMRSAtIFFVRVJZIE1FVEEgREFUQSwgT3B0aW9uYWwgDQoJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgktLT4NCiAgICA8ZG9jdW1lbnRhdGlvbk9mPg0KICAgICAgICA8c2VydmljZUV2ZW50IGNsYXNzQ29kZT0iUENQUiI+DQogICAgICAgICAgICA8ZWZmZWN0aXZlVGltZT4NCgkJCQk8IS0tIFFVRVJZIE1FVEEgREFUQSwgU0VSVklDRSBTVEFSVCBUSU1FLCBPcHRpb25hbCAtLT4NCiAgICAgICAgICAgICAgICA8bG93IHZhbHVlPSIxOTAwMDEwMTAwMDAwMC0wNjAwIiAvPg0KCQkJCTwhLS0gUVVFUlkgTUVUQSBEQVRBLCBTRVJWSUNFIFNUT1AgVElNRSwgT3B0aW9uYWwgLS0+DQogICAgICAgICAgICAgICAgPGhpZ2ggdmFsdWU9IjIwMTMwMzE1MDg0NzEwLTA1MDAiIC8+DQogICAgICAgICAgICA8L2VmZmVjdGl2ZVRpbWU+DQogICAgICAgICAgICA8IS0tIA0KCQkJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgkJCUhFQUxUSENBUkUgUFJPVklERVIgTU9EVUxFLCBPUFRJT05BTA0KCQkJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgkJCS0tPg0KICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSBQcm92aWRlciBUZW1wbGF0ZSBJZCAgLS0+DQogICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAyLVBST1ZJREVSIFJPTEUgQ09ERUQsIE9wdGlvbmFsLVIyLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIDQuMDMtUFJPVklERVIgUk9MRSBGUkVFIFRFWFQsIE9wdGlvbmFsLVIyLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIDQuMDEtREFURSBSQU5HRSwgUmVxdWlyZWQsIG51bGxGbGF2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQogICAgICAgICAgICAgICAgICAgIDx0aW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC90aW1lPg0KCQkJCSAgICA8YXNzaWduZWRFbnRpdHk+DQoJCQkJICAgICAgICA8IS0tIFByb3ZpZGVyIElEIGZyb20gUHJvYmxlbXMgTW9kdWxlICg3LjA1VHJlYXRpbmcgUHJvdmlkZXIgSUQpIC0tPg0KCQkJCSAgICAgICAgPGlkIGV4dGVuc2lvbj0icHJvdmlkZXIxIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJPGFkZHIgLz4NCgkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGlhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCTxuYW1lPkJSVVVOLEpFU1NFPC9uYW1lPg0KCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJICAgIDwvYXNzaWduZWRFbnRpdHk+DQoJCQk8L3BlcmZvcm1lcj48cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIFByb3ZpZGVyIFRlbXBsYXRlIElkICAtLT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS4zMi40IiAvPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIDQuMDItUFJPVklERVIgUk9MRSBDT0RFRCwgT3B0aW9uYWwtUjIsIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMy1QUk9WSURFUiBST0xFIEZSRUUgVEVYVCwgT3B0aW9uYWwtUjIsIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMS1EQVRFIFJBTkdFLCBSZXF1aXJlZCwgbnVsbEZsYXZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L3RpbWU+DQoJCQkJICAgIDxhc3NpZ25lZEVudGl0eT4NCgkJCQkgICAgICAgIDwhLS0gUHJvdmlkZXIgSUQgZnJvbSBQcm9ibGVtcyBNb2R1bGUgKDcuMDVUcmVhdGluZyBQcm92aWRlciBJRCkgLS0+DQoJCQkJICAgICAgICA8aWQgZXh0ZW5zaW9uPSJwcm92aWRlcjIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCSAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQk8YWRkciAvPg0KCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJPG5hbWU+Q0hEUkFNRFBST1YsQUxJQ0lBIE08L25hbWU+DQoJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkciAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkgICAgPC9hc3NpZ25lZEVudGl0eT4NCgkJCTwvcGVyZm9ybWVyPjxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMi1QUk9WSURFUiBST0xFIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAzLVBST1ZJREVSIFJPTEUgRlJFRSBURVhULCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAxLURBVEUgUkFOR0UsIFJlcXVpcmVkLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGltZT4NCgkJCQkgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCSAgICAgICAgPCEtLSBQcm92aWRlciBJRCBmcm9tIFByb2JsZW1zIE1vZHVsZSAoNy4wNVRyZWF0aW5nIFByb3ZpZGVyIElEKSAtLT4NCgkJCQkgICAgICAgIDxpZCBleHRlbnNpb249InByb3ZpZGVyMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTxhZGRyIC8+DQoJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQk8bmFtZT5Qcm92aWRlciwgT25lPC9uYW1lPg0KCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJICAgIDwvYXNzaWduZWRFbnRpdHk+DQoJCQk8L3BlcmZvcm1lcj48cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIFByb3ZpZGVyIFRlbXBsYXRlIElkICAtLT4NCiAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS4zMi40IiAvPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIDQuMDItUFJPVklERVIgUk9MRSBDT0RFRCwgT3B0aW9uYWwtUjIsIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMy1QUk9WSURFUiBST0xFIEZSRUUgVEVYVCwgT3B0aW9uYWwtUjIsIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMS1EQVRFIFJBTkdFLCBSZXF1aXJlZCwgbnVsbEZsYXZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPHRpbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L3RpbWU+DQoJCQkJICAgIDxhc3NpZ25lZEVudGl0eT4NCgkJCQkgICAgICAgIDwhLS0gUHJvdmlkZXIgSUQgZnJvbSBQcm9ibGVtcyBNb2R1bGUgKDcuMDVUcmVhdGluZyBQcm92aWRlciBJRCkgLS0+DQoJCQkJICAgICAgICA8aWQgZXh0ZW5zaW9uPSJwcm92aWRlcjQiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCSAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQk8YWRkciAvPg0KCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJPG5hbWU+UHJvdmlkZXIsIE9uZTwvbmFtZT4NCgkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZCBleHRlbnNpb249Ijk5MiIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbGVjb20gLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhZGRyIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCSAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJPC9wZXJmb3JtZXI+PHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSBQcm92aWRlciBUZW1wbGF0ZSBJZCAgLS0+DQogICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAyLVBST1ZJREVSIFJPTEUgQ09ERUQsIE9wdGlvbmFsLVIyLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIDQuMDMtUFJPVklERVIgUk9MRSBGUkVFIFRFWFQsIE9wdGlvbmFsLVIyLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8IS0tIDQuMDEtREFURSBSQU5HRSwgUmVxdWlyZWQsIG51bGxGbGF2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQogICAgICAgICAgICAgICAgICAgIDx0aW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC90aW1lPg0KCQkJCSAgICA8YXNzaWduZWRFbnRpdHk+DQoJCQkJICAgICAgICA8IS0tIFByb3ZpZGVyIElEIGZyb20gUHJvYmxlbXMgTW9kdWxlICg3LjA1VHJlYXRpbmcgUHJvdmlkZXIgSUQpIC0tPg0KCQkJCSAgICAgICAgPGlkIGV4dGVuc2lvbj0icHJvdmlkZXI1IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJPGFkZHIgLz4NCgkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGlhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCTxuYW1lPlByb3ZpZGVyLCBPbmU8L25hbWU+DQoJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgZXh0ZW5zaW9uPSI5OTIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkciAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkgICAgPC9hc3NpZ25lZEVudGl0eT4NCgkJCTwvcGVyZm9ybWVyPjxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMi1QUk9WSURFUiBST0xFIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAzLVBST1ZJREVSIFJPTEUgRlJFRSBURVhULCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAxLURBVEUgUkFOR0UsIFJlcXVpcmVkLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGltZT4NCgkJCQkgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCSAgICAgICAgPCEtLSBQcm92aWRlciBJRCBmcm9tIFByb2JsZW1zIE1vZHVsZSAoNy4wNVRyZWF0aW5nIFByb3ZpZGVyIElEKSAtLT4NCgkJCQkgICAgICAgIDxpZCBleHRlbnNpb249InByb3ZpZGVyNiIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTxhZGRyIC8+DQoJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQk8bmFtZT5QT05ELE5FQUw8L25hbWU+DQoJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgZXh0ZW5zaW9uPSI5OTIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkciAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkgICAgPC9hc3NpZ25lZEVudGl0eT4NCgkJCTwvcGVyZm9ybWVyPjxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMi1QUk9WSURFUiBST0xFIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAzLVBST1ZJREVSIFJPTEUgRlJFRSBURVhULCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAxLURBVEUgUkFOR0UsIFJlcXVpcmVkLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGltZT4NCgkJCQkgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCSAgICAgICAgPCEtLSBQcm92aWRlciBJRCBmcm9tIFByb2JsZW1zIE1vZHVsZSAoNy4wNVRyZWF0aW5nIFByb3ZpZGVyIElEKSAtLT4NCgkJCQkgICAgICAgIDxpZCBleHRlbnNpb249InByb3ZpZGVyNyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTxhZGRyIC8+DQoJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQk8bmFtZT5QT05ELE5FQUw8L25hbWU+DQoJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgZXh0ZW5zaW9uPSI5OTIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkciAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkgICAgPC9hc3NpZ25lZEVudGl0eT4NCgkJCTwvcGVyZm9ybWVyPjxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMi1QUk9WSURFUiBST0xFIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAzLVBST1ZJREVSIFJPTEUgRlJFRSBURVhULCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAxLURBVEUgUkFOR0UsIFJlcXVpcmVkLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGltZT4NCgkJCQkgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCSAgICAgICAgPCEtLSBQcm92aWRlciBJRCBmcm9tIFByb2JsZW1zIE1vZHVsZSAoNy4wNVRyZWF0aW5nIFByb3ZpZGVyIElEKSAtLT4NCgkJCQkgICAgICAgIDxpZCBleHRlbnNpb249InByb3ZpZGVyOCIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTxhZGRyIC8+DQoJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQk8bmFtZT5QT05ELE5FQUw8L25hbWU+DQoJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgZXh0ZW5zaW9uPSI5OTIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkciAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkgICAgPC9hc3NpZ25lZEVudGl0eT4NCgkJCTwvcGVyZm9ybWVyPjxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMi1QUk9WSURFUiBST0xFIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAzLVBST1ZJREVSIFJPTEUgRlJFRSBURVhULCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAxLURBVEUgUkFOR0UsIFJlcXVpcmVkLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGltZT4NCgkJCQkgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCSAgICAgICAgPCEtLSBQcm92aWRlciBJRCBmcm9tIFByb2JsZW1zIE1vZHVsZSAoNy4wNVRyZWF0aW5nIFByb3ZpZGVyIElEKSAtLT4NCgkJCQkgICAgICAgIDxpZCBleHRlbnNpb249InByb3ZpZGVyOSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTxhZGRyIC8+DQoJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQk8bmFtZT5QT05ELE5FQUw8L25hbWU+DQoJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWQgZXh0ZW5zaW9uPSI5OTIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWRkciAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkgICAgPC9hc3NpZ25lZEVudGl0eT4NCgkJCTwvcGVyZm9ybWVyPjxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQogICAgICAgICAgICAgICAgICAgIDwhLS0gNC4wMi1QUk9WSURFUiBST0xFIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAzLVBST1ZJREVSIFJPTEUgRlJFRSBURVhULCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPCEtLSA0LjAxLURBVEUgUkFOR0UsIFJlcXVpcmVkLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGltZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGltZT4NCgkJCQkgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCSAgICAgICAgPCEtLSBQcm92aWRlciBJRCBmcm9tIFByb2JsZW1zIE1vZHVsZSAoNy4wNVRyZWF0aW5nIFByb3ZpZGVyIElEKSAtLT4NCgkJCQkgICAgICAgIDxpZCBleHRlbnNpb249InByb3ZpZGVyMTAiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCSAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQk8YWRkciAvPg0KCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJPG5hbWU+UE9ORCxORUFMPC9uYW1lPg0KCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5hbWU+Q0hFWUVOTkUgSERSIFNRQTwvbmFtZT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVsZWNvbSAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFkZHIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJICAgIDwvYXNzaWduZWRFbnRpdHk+DQoJCQk8L3BlcmZvcm1lcj4NCiAgICAgICAgPC9zZXJ2aWNlRXZlbnQ+DQogICAgPC9kb2N1bWVudGF0aW9uT2Y+DQogICAgPCEtLSANCgkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCUNEQSBCT0RZDQoJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgktLT4JDQogICAgPGNvbXBvbmVudD4NCiAgICAgICAgPHN0cnVjdHVyZWRCb2R5Pg0KICAgICAgICAJPCEtLSANCgkJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJCQlBTExFUkdZL0RSVUcgU0VDVElPTiBTRUNUSU9ODQoJCQkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCQkJLS0+DQoJCQk8Y29tcG9uZW50Pg0KCQkJCQkJCTxzZWN0aW9uPg0KCQkJCQkJCQk8IS0tIENDRCBBbGVydCBTZWN0aW9uIFRlbXBsYXRlLS0+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMiIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEFsbGVyZ3kgYW5kIEFkdmVyc2UgUmVhY3Rpb24gU2VjdGlvbiBUZW1wbGF0ZSAtLT4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xMDIiIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJnaWVzIGFuZCBPdGhlciBBZHZlcnNlIFJlYWN0aW9ucyAgU2VjdGlvbiBUZW1wbGF0ZSAtLT4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS4zLjEzIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIENDRCBTZWN0aW9uIENvbmZvcm1hbmNlIGNvZGUgdmFsdWUgLCBzdGF0aWMgLS0+DQoJCQkJCQkJCTxjb2RlIGNvZGU9IjQ4NzY1LTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IkFsbGVyZ2llcywgYWR2ZXJzZSByZWFjdGlvbnMsIGFsZXJ0cyIgLz4NCgkJCQkJCQkJPHRpdGxlPkFsbGVyZ2llczwvdGl0bGU+DQoJCQkJCQkJCTwhLS0gIEFMTEVSR0lFUyBOQVJSQVRJVkUgQkxPQ0sgLS0+DQoJCQkJCQkJCSA8dGV4dD4NCgkJCQkJCQkJCTwhLS0gVkxFUiBTRUcgMUI6IEFsbGVyZ2llcy9EcnVnIEJ1c2luZXNzIFJ1bGVzIGZvciBNZWRpY2FsIENvbnRlbnQgIC0tPg0KCQkJCQkJCQkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJCQkJCQkJCTx0aGVhZD4NCgkJCQkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJCQkJPHRoPkRlcGFydG1lbnQgb2YgVmV0ZXJhbnMgQWZmYWlyczwvdGg+DQoJCQkJCQkJCQkJCQk8dGg+QnVzaW5lc3MgUnVsZXMgZm9yIENvbnN0cnVjdGlvbiBvZiBNZWRpY2FsIEluZm9ybWF0aW9uPC90aD4NCgkJCQkJCQkJCQkJPC90cj4NCgkJCQkJCQkJCQk8L3RoZWFkPg0KCQkJCQkJCQkJCTx0Ym9keT4NCgkJCQkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJCQkJPHRkPkFsbGVyZ2llczwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+VGhpcyBzZWN0aW9uIGNvbnRhaW5zIGFsbCBwYXRpZW50IGFsbGVyZ3kgaW5mb3JtYXRpb24gZnJvbSBhbGwgVkEgdHJlYXRtZW50IGZhY2lsaXRpZXMuIEl0IGRvZXMgbm90IGNvbnRhaW4gcGF0aWVudCBhbGxlcmdpZXMgdGhhdCB3ZXJlIGRlbGV0ZWQgb3IgZW50ZXJlZCBpbiBlcnJvci48L3RkPg0KCQkJCQkJCQkJCQk8L3RyPg0KCQkJCQkJCQkJCTwvdGJvZHk+DQoJCQkJCQkJCQk8L3RhYmxlPg0KCQkJCQkJCQkJPHRhYmxlIElEPSJhbGxlcmd5TmFycml0aXZlIiBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCQkJCQkJCQk8dGhlYWQ+DQoJCQkJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCQkJCTx0aD5BbGxlcmd5PC90aD4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5Db2RlZCBBbGxlcmd5PC90aD4NCgkJCQkJCQkJCQkJCTx0aD5WZXJpZmljYXRpb24gRGF0ZTwvdGg+DQoJCQkJCQkJCQkJCQk8dGg+RXZlbnQgVHlwZTwvdGg+DQoJCQkJCQkJCQkJCQk8dGg+UmVhY3Rpb248L3RoPg0KCQkJCQkJCQkJCQkJPHRoPlNldmVyaXR5PC90aD4NCgkJCQkJCQkJCQkJCTx0aD5Tb3VyY2U8L3RoPg0KCQkJCQkJCQkJCQk8L3RyPg0KCQkJCQkJCQkJCTwvdGhlYWQ+DQoJCQkJCQkJCQkJPHRib2R5Pg0KCQkJCQkJCQkJCQk8dHI+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEFsbGVyZ3kxIj5MQVRFWCBTVFJBUDwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZENvZGVkQWxsZXJneU5hbWUxIj5Db2RlZCBBbGxlcmd5IE5hbWUgTm90IEF2YWlsYWJsZTwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFZlcmlmaWNhdGlvbkRhdGUxIj4yMDEyMDYyNjE0MTAyNjwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEV2ZW50VHlwZTEiPlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gZHJ1ZzwvY29udGVudD4NCgkJCQkJCQkJCQkJICAgIDwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFJlYWN0aW9uMS0xIj5VUlRJQ0FSSUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQkJICAgIDwvaXRlbT4NCgkJCQkJCQkJCQkJCQk8L2xpc3Q+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTZXZlcml0eTEiIC8+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTb3VyY2UxIj5NQVJUSU5TQlVSRyBWQU1DPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEFsbGVyZ3kyIj5CRUUgVkVOT008L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRDb2RlZEFsbGVyZ3lOYW1lMiI+Q29kZWQgQWxsZXJneSBOYW1lIE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRWZXJpZmljYXRpb25EYXRlMiI+MjAxMjEwMTUxMDU3MDI8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRFdmVudFR5cGUyIj5Qcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkgICAgPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8bGlzdD4NCgkJCQkJCQkJCQkJCQkJPGl0ZW0+DQoJCQkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kUmVhY3Rpb24yLTEiPkFOWElFVFk8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQkJICAgIDwvaXRlbT4NCgkJCQkJCQkJCQkJCQk8L2xpc3Q+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTZXZlcml0eTIiIC8+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTb3VyY2UyIj5NQVJUSU5TQlVSRyBWQU1DPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEFsbGVyZ3kzIj5CRUVGIFBST0RVQ1RTPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kQ29kZWRBbGxlcmd5TmFtZTMiPkNvZGVkIEFsbGVyZ3kgTmFtZSBOb3QgQXZhaWxhYmxlPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kVmVyaWZpY2F0aW9uRGF0ZTMiPjIwMTIxMDE2MTYzNDI1PC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kRXZlbnRUeXBlMyI+UHJvcGVuc2l0eSB0byBhZHZlcnNlIHJlYWN0aW9ucyB0byBmb29kPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkgICAgPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8bGlzdD4NCgkJCQkJCQkJCQkJCQkJPGl0ZW0+DQoJCQkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kUmVhY3Rpb24zLTEiPkFOWElFVFk8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQkJICAgIDwvaXRlbT4NCgkJCQkJCQkJCQkJCQk8L2xpc3Q+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTZXZlcml0eTMiIC8+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTb3VyY2UzIj5NQVJUSU5TQlVSRyBWQU1DPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEFsbGVyZ3k0Ij5TT1kgTUlMSzwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZENvZGVkQWxsZXJneU5hbWU0Ij5Db2RlZCBBbGxlcmd5IE5hbWUgTm90IEF2YWlsYWJsZTwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFZlcmlmaWNhdGlvbkRhdGU0Ij4yMDEyMTExMzEzMjYyOTwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEV2ZW50VHlwZTQiPlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gc3Vic3RhbmNlPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkgICAgPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8bGlzdD4NCgkJCQkJCQkJCQkJCQkJPGl0ZW0+DQoJCQkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kUmVhY3Rpb240LTEiPk5BVVNFQSBBTkQgVk9NSVRJTkc8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQkJICAgIDwvaXRlbT4NCgkJCQkJCQkJCQkJCQk8L2xpc3Q+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTZXZlcml0eTQiPk1PREVSQVRFPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kU291cmNlNCI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRBbGxlcmd5NSI+QkFLRUQgQkVBTlM8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRDb2RlZEFsbGVyZ3lOYW1lNSI+Q29kZWQgQWxsZXJneSBOYW1lIE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRWZXJpZmljYXRpb25EYXRlNSI+MjAxMjExMTMxNjIyNTE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRFdmVudFR5cGU1Ij5Qcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIHRvIGZvb2Q8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCSAgICA8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxsaXN0Pg0KCQkJCQkJCQkJCQkJCQk8aXRlbT4NCgkJCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRSZWFjdGlvbjUtMSI+RElBUlJIRUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQkJICAgIDwvaXRlbT4NCgkJCQkJCQkJCQkJCQk8L2xpc3Q+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTZXZlcml0eTUiPk1PREVSQVRFPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kU291cmNlNSI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRBbGxlcmd5NiI+V0FURVJNRUxPTlM8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRDb2RlZEFsbGVyZ3lOYW1lNiI+Q29kZWQgQWxsZXJneSBOYW1lIE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRWZXJpZmljYXRpb25EYXRlNiI+MjAxMTEwMjQxNTMxMzc8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRFdmVudFR5cGU2Ij5Qcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIHRvIGZvb2Q8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCSAgICA8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxsaXN0Pg0KCQkJCQkJCQkJCQkJCQk8aXRlbT4NCgkJCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRSZWFjdGlvbjYtMSI+RElBUlJIRUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQkJICAgIDwvaXRlbT4NCgkJCQkJCQkJCQkJCQk8L2xpc3Q+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTZXZlcml0eTYiIC8+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTb3VyY2U2Ij5DSEVZRU5ORSBIRFIgU1FBPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEFsbGVyZ3k3Ij5IT05FWTwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZENvZGVkQWxsZXJneU5hbWU3Ij5Db2RlZCBBbGxlcmd5IE5hbWUgTm90IEF2YWlsYWJsZTwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFZlcmlmaWNhdGlvbkRhdGU3Ij4yMDEyMDEyMzA5NTUyNDwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEV2ZW50VHlwZTciPlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gZm9vZDwvY29udGVudD4NCgkJCQkJCQkJCQkJICAgIDwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFJlYWN0aW9uNy0xIj5XSEVFWklORzwvY29udGVudD4NCgkJCQkJCQkJCQkJCQkgICAgPC9pdGVtPg0KCQkJCQkJCQkJCQkJCTwvbGlzdD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFNldmVyaXR5NyIgLz4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFNvdXJjZTciPkNIRVlFTk5FIEhEUiBTUUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kQWxsZXJneTgiPk5VVFM8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRDb2RlZEFsbGVyZ3lOYW1lOCI+Q29kZWQgQWxsZXJneSBOYW1lIE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRWZXJpZmljYXRpb25EYXRlOCI+MjAxMjAxMjMxNDQ5Mzk8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRFdmVudFR5cGU4Ij5Qcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIHRvIHN1YnN0YW5jZTwvY29udGVudD4NCgkJCQkJCQkJCQkJICAgIDwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFJlYWN0aW9uOC0xIj5OQVVTRUEgQU5EIFZPTUlUSU5HPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJCSAgICA8L2l0ZW0+PGl0ZW0+DQoJCQkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kUmVhY3Rpb244LTIiPkRJQVJSSEVBPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJCSAgICA8L2l0ZW0+DQoJCQkJCQkJCQkJCQkJPC9saXN0Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kU2V2ZXJpdHk4Ij5NT0RFUkFURTwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFNvdXJjZTgiPkNIRVlFTk5FIEhEUiBTUUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kQWxsZXJneTkiPk9BVFM8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRDb2RlZEFsbGVyZ3lOYW1lOSI+Q29kZWQgQWxsZXJneSBOYW1lIE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRWZXJpZmljYXRpb25EYXRlOSI+MjAxMjAxMjQxMzIyNDA8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRFdmVudFR5cGU5Ij5Qcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIHRvIHN1YnN0YW5jZTwvY29udGVudD4NCgkJCQkJCQkJCQkJICAgIDwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFJlYWN0aW9uOS0xIj5ESUFSUkhFQTwvY29udGVudD4NCgkJCQkJCQkJCQkJCQkgICAgPC9pdGVtPg0KCQkJCQkJCQkJCQkJCTwvbGlzdD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFNldmVyaXR5OSI+TU9ERVJBVEU8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTb3VyY2U5Ij5DSEVZRU5ORSBIRFIgU1FBPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZEFsbGVyZ3kxMCI+Q0hPQ09MQVRFPC9jb250ZW50Pg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kQ29kZWRBbGxlcmd5TmFtZTEwIj5Db2RlZCBBbGxlcmd5IE5hbWUgTm90IEF2YWlsYWJsZTwvY29udGVudD4NCgkJCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImFuZFZlcmlmaWNhdGlvbkRhdGUxMCI+MjAxMjA1MDExNjU0NDg8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRFdmVudFR5cGUxMCI+UHJvcGVuc2l0eSB0byBhZHZlcnNlIHJlYWN0aW9ucyB0byBzdWJzdGFuY2U8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCSAgICA8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxsaXN0Pg0KCQkJCQkJCQkJCQkJCQk8aXRlbT4NCgkJCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRSZWFjdGlvbjEwLTEiPkFOWElFVFk8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQkJICAgIDwvaXRlbT4NCgkJCQkJCQkJCQkJCQk8L2xpc3Q+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJhbmRTZXZlcml0eTEwIiAvPg0KCQkJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iYW5kU291cmNlMTAiPkNIRVlFTk5FIEhEUiBTUUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCQk8L3RyPg0KCQkJCQkJCQkJCTwvdGJvZHk+DQoJCQkJCQkJCQk8L3RhYmxlPg0KCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCQkJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0QiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjciIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFRlbXBsYXRlcyBmb3IgQWxsZXJneS9EcnVnIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjYiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMSIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4zIiAvPg0KCQkJCQkJCQkJCTwhLS0gQ0NEIEFsbGVyZ3kgQWN0IElEIGFzIG51bGxmbGF2b3IgLS0+DQoJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSUhFIENvbmNlcm4gVGVtcGxhdGUgUmVxdWlyZXMgc3RhdHVzQ29kZSBhbmQgZWZmZWN0aXZlVGltZSAgLS0+DQoJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iYWN0aXZlIiAvPg0KCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEFMTEVSR0lFUy9EUlVHLCBPcHRpb25hbCAtLT4NCgkJCQkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQkJCQk8IS0tICBBREQgVElNRSBUTyBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEFMTEVSR0lFUy9EUlVHIC0tPg0KCQkJCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJCQkJPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJmYWxzZSIgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgQWxsZXJneSBUZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBBbGVydCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTgiIC8+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogSUhFIE9ic2VydmF0aW9uIFRlbXBsYXRlcyBSZXF1aXJlIElkIC0tPg0KCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gNi4wMiBBRFZFUlNFIEVWRU5UIFRZUEUsIFJFUVVJUkVEOyBTTk9NRUQgQ1QgIC0tPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDYuMDIgQURWRVJTRSBFVkVOVCBUWVBFIFNOT01FRCBDVCBUZXJtaW5vbG9neSBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjQxOTUxMTAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgZGlzcGxheU5hbWU9IlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gZHJ1ZyI+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5EUlVHPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIElIRSAgU3RhdHVzIENvZGUgZnJvIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAxIEFEVkVSU0UgRVZFTlQgREFURSwgT3B0aW9uYWwtUjIgLS0+DQoJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMDYyNjE0MTAyNiIgLz4NCgkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJneSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHZhbHVlLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFBhcnRpY2lwYW50IGJsb2NrIGZvciA2LjA0LVByb2R1Y3QgQ29kZWQgLS0+DQoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSAgNi4wNCBQUk9EVUNUIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJCQkJIDxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkJCSA8cmVmZXJlbmNlIHZhbHVlPSIjYW5kQ29kZWRBbGxlcmd5TmFtZTEiIC8+DQoJCQkJCQkJCQkJCQkJCQkJIDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQkJIDwvY29kZT4NCgkJCQkJCQkJCQkJCQkJCTwhLS0gNi4wMyBQUk9EVUNUIEZSRUUgVEVYVCwgUkVRVUlSRUQtLT4NCgkJCQkJCQkJCQkJCQkJCTxuYW1lPkxBVEVYIFNUUkFQPC9uYW1lPg0KCQkJCQkJCQkJCQkJCQk8L3BsYXlpbmdFbnRpdHk+DQoJCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Pg0KCQkJCQkJCQkJCQkJPCEtLSAgU0VWRVJJVFkgRU5UUlkgUkVMQVRJT05TSElQIEJMT0NLIG9wdGlvbmFsLCAwIG9yIDEgcGVyIEFsbGVyZ3kgLS0+DQoJCQkJCQkJCQkJCQkNCgkJCQkJCQkJCQkJCTwhLS0gIFJFQUNUSU9OIEVOVFJZUkVMQVRJT05TSElQIEJMT0NLIG9wdGlvbmFsLCByZXBlYXRhYmxlICAtLT4NCgkJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJNRlNUIj4NCgkJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJCQk8IS0tIFJlYWN0aW9uIFRlbXBsYXRlIElEIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjU0IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENvZGUiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNSBSRUFDVElPTi1GUkVFIFRFWFQsIG9wdGlvbmFsLC0tPg0KCQkJCQkJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNhbmRSZWFjdGlvbjEtMSIgLz4NCgkJCQkJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA2IFJFQUNUSU9OIENPREVEIG9wdGlvbmFsLCB3aGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQk8L2FjdD4NCgkJCQkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQkJCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBUZW1wbGF0ZXMgZm9yIEFsbGVyZ3kvRHJ1ZyBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My42IiAvPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMyIgLz4NCgkJCQkJCQkJCQk8IS0tIENDRCBBbGxlcmd5IEFjdCBJRCBhcyBudWxsZmxhdm9yIC0tPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHN0YXR1c0NvZGUgYW5kIGVmZmVjdGl2ZVRpbWUgIC0tPg0KCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIgLz4NCgkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRywgT3B0aW9uYWwgLS0+DQoJCQkJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJCQkJPCEtLSAgQUREIFRJTUUgVE8gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRyAtLT4NCgkJCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gQWxlcnQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjE4IiAvPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IElIRSBPYnNlcnZhdGlvbiBUZW1wbGF0ZXMgUmVxdWlyZSBJZCAtLT4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIDYuMDIgQURWRVJTRSBFVkVOVCBUWVBFLCBSRVFVSVJFRDsgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA2LjAyIEFEVkVSU0UgRVZFTlQgVFlQRSBTTk9NRUQgQ1QgVGVybWlub2xvZ3kgUmVxdWlyZWQgLS0+DQoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSI0MjAxMzQwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIGRpc3BsYXlOYW1lPSJQcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIj4NCgkJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0Pk9USEVSPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIElIRSAgU3RhdHVzIENvZGUgZnJvIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAxIEFEVkVSU0UgRVZFTlQgREFURSwgT3B0aW9uYWwtUjIgLS0+DQoJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMTAxNTEwNTcwMiIgLz4NCgkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJneSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHZhbHVlLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFBhcnRpY2lwYW50IGJsb2NrIGZvciA2LjA0LVByb2R1Y3QgQ29kZWQgLS0+DQoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSAgNi4wNCBQUk9EVUNUIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJCQkJIDxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkJCSA8cmVmZXJlbmNlIHZhbHVlPSIjYW5kQ29kZWRBbGxlcmd5TmFtZTIiIC8+DQoJCQkJCQkJCQkJCQkJCQkJIDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQkJIDwvY29kZT4NCgkJCQkJCQkJCQkJCQkJCTwhLS0gNi4wMyBQUk9EVUNUIEZSRUUgVEVYVCwgUkVRVUlSRUQtLT4NCgkJCQkJCQkJCQkJCQkJCTxuYW1lPkJFRSBWRU5PTTwvbmFtZT4NCgkJCQkJCQkJCQkJCQkJPC9wbGF5aW5nRW50aXR5Pg0KCQkJCQkJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudD4NCgkJCQkJCQkJCQkJCTwhLS0gIFNFVkVSSVRZIEVOVFJZIFJFTEFUSU9OU0hJUCBCTE9DSyBvcHRpb25hbCwgMCBvciAxIHBlciBBbGxlcmd5IC0tPg0KCQkJCQkJCQkJCQkJDQoJCQkJCQkJCQkJCQk8IS0tICBSRUFDVElPTiBFTlRSWVJFTEFUSU9OU0hJUCBCTE9DSyBvcHRpb25hbCwgcmVwZWF0YWJsZSAgLS0+DQoJCQkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJ0cnVlIiB0eXBlQ29kZT0iTUZTVCI+DQoJCQkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCQkJPCEtLSBSZWFjdGlvbiBUZW1wbGF0ZSBJRCAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41NCIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgQWxsZXJneSBUZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDb2RlIiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDUgUkVBQ1RJT04tRlJFRSBURVhULCBvcHRpb25hbCwtLT4NCgkJCQkJCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjYW5kUmVhY3Rpb24yLTEiIC8+DQoJCQkJCQkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNiBSRUFDVElPTiBDT0RFRCBvcHRpb25hbCwgd2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9Q0QgYWxsb3dlZCAtLT4NCgkJCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJPC9hY3Q+DQoJCQkJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJCQkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDRCIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNyIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgVGVtcGxhdGVzIGZvciBBbGxlcmd5L0RydWcgTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuNiIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4xIiAvPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjMiIC8+DQoJCQkJCQkJCQkJPCEtLSBDQ0QgQWxsZXJneSBBY3QgSUQgYXMgbnVsbGZsYXZvciAtLT4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQ29uY2VybiBUZW1wbGF0ZSBSZXF1aXJlcyBzdGF0dXNDb2RlIGFuZCBlZmZlY3RpdmVUaW1lICAtLT4NCgkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiIC8+DQoJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgQUxMRVJHSUVTL0RSVUcsIE9wdGlvbmFsIC0tPg0KCQkJCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCQkJCTwhLS0gIEFERCBUSU1FIFRPIElORk9STUFUSU9OIFNPVVJDRSBGT1IgQUxMRVJHSUVTL0RSVUcgLS0+DQoJCQkJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9ImZhbHNlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEFsZXJ0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xOCIgLz4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBJSEUgT2JzZXJ2YXRpb24gVGVtcGxhdGVzIFJlcXVpcmUgSWQgLS0+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAyIEFEVkVSU0UgRVZFTlQgVFlQRSwgUkVRVUlSRUQ7IFNOT01FRCBDVCAgLS0+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgNi4wMiBBRFZFUlNFIEVWRU5UIFRZUEUgU05PTUVEIENUIFRlcm1pbm9sb2d5IFJlcXVpcmVkIC0tPg0KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNDE4NDcxMDAwIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBkaXNwbGF5TmFtZT0iUHJvcGVuc2l0eSB0byBhZHZlcnNlIHJlYWN0aW9ucyB0byBmb29kIj4NCgkJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PkZPT0Q8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCQkJCTwhLS0gSUhFICBTdGF0dXMgQ29kZSBmcm8gT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIDYuMDEgQURWRVJTRSBFVkVOVCBEQVRFLCBPcHRpb25hbC1SMiAtLT4NCgkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCTxsb3cgdmFsdWU9IjIwMTIxMDE2MTYzNDI1IiAvPg0KCQkJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBBbGxlcmd5IENvbmNlcm4gVGVtcGxhdGUgUmVxdWlyZXMgdmFsdWUsIFdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPUNEIGFsbG93ZWQgLS0+DQoJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogUGFydGljaXBhbnQgYmxvY2sgZm9yIDYuMDQtUHJvZHVjdCBDb2RlZCAtLT4NCgkJCQkJCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQ1NNIj4NCgkJCQkJCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQoJCQkJCQkJCQkJCQkJCTxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iTU1BVCI+DQoJCQkJCQkJCQkJCQkJCQk8IS0tICA2LjA0IFBST0RVQ1QgQ09ERUQsIE9wdGlvbmFsLVIyLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IlVOSyIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQkJCQkJCQkgPG9yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkJCQkJIDxyZWZlcmVuY2UgdmFsdWU9IiNhbmRDb2RlZEFsbGVyZ3lOYW1lMyIgLz4NCgkJCQkJCQkJCQkJCQkJCQkgPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkgPC9jb2RlPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSA2LjAzIFBST0RVQ1QgRlJFRSBURVhULCBSRVFVSVJFRC0tPg0KCQkJCQkJCQkJCQkJCQkJPG5hbWU+QkVFRiBQUk9EVUNUUzwvbmFtZT4NCgkJCQkJCQkJCQkJCQkJPC9wbGF5aW5nRW50aXR5Pg0KCQkJCQkJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudD4NCgkJCQkJCQkJCQkJCTwhLS0gIFNFVkVSSVRZIEVOVFJZIFJFTEFUSU9OU0hJUCBCTE9DSyBvcHRpb25hbCwgMCBvciAxIHBlciBBbGxlcmd5IC0tPg0KCQkJCQkJCQkJCQkJDQoJCQkJCQkJCQkJCQk8IS0tICBSRUFDVElPTiBFTlRSWVJFTEFUSU9OU0hJUCBCTE9DSyBvcHRpb25hbCwgcmVwZWF0YWJsZSAgLS0+DQoJCQkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJ0cnVlIiB0eXBlQ29kZT0iTUZTVCI+DQoJCQkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCQkJPCEtLSBSZWFjdGlvbiBUZW1wbGF0ZSBJRCAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41NCIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgQWxsZXJneSBUZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDb2RlIiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDUgUkVBQ1RJT04tRlJFRSBURVhULCBvcHRpb25hbCwtLT4NCgkJCQkJCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjYW5kUmVhY3Rpb24zLTEiIC8+DQoJCQkJCQkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNiBSRUFDVElPTiBDT0RFRCBvcHRpb25hbCwgd2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9Q0QgYWxsb3dlZCAtLT4NCgkJCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJPC9hY3Q+DQoJCQkJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJCQkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDRCIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNyIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgVGVtcGxhdGVzIGZvciBBbGxlcmd5L0RydWcgTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuNiIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4xIiAvPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjMiIC8+DQoJCQkJCQkJCQkJPCEtLSBDQ0QgQWxsZXJneSBBY3QgSUQgYXMgbnVsbGZsYXZvciAtLT4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQ29uY2VybiBUZW1wbGF0ZSBSZXF1aXJlcyBzdGF0dXNDb2RlIGFuZCBlZmZlY3RpdmVUaW1lICAtLT4NCgkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiIC8+DQoJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgQUxMRVJHSUVTL0RSVUcsIE9wdGlvbmFsIC0tPg0KCQkJCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCQkJCTwhLS0gIEFERCBUSU1FIFRPIElORk9STUFUSU9OIFNPVVJDRSBGT1IgQUxMRVJHSUVTL0RSVUcgLS0+DQoJCQkJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9ImZhbHNlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEFsZXJ0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xOCIgLz4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBJSEUgT2JzZXJ2YXRpb24gVGVtcGxhdGVzIFJlcXVpcmUgSWQgLS0+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAyIEFEVkVSU0UgRVZFTlQgVFlQRSwgUkVRVUlSRUQ7IFNOT01FRCBDVCAgLS0+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgNi4wMiBBRFZFUlNFIEVWRU5UIFRZUEUgU05PTUVEIENUIFRlcm1pbm9sb2d5IFJlcXVpcmVkIC0tPg0KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNDE4MDM4MDA3IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBkaXNwbGF5TmFtZT0iUHJvcGVuc2l0eSB0byBhZHZlcnNlIHJlYWN0aW9ucyB0byBzdWJzdGFuY2UiPg0KCQkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+RFJVRywgRk9PRDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCQkJCQkJPCEtLSBJSEUgIFN0YXR1cyBDb2RlIGZybyBPYnNlcnZhdGlvbiAtLT4NCgkJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gNi4wMSBBRFZFUlNFIEVWRU5UIERBVEUsIE9wdGlvbmFsLVIyIC0tPg0KCQkJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAxMjExMTMxMzI2MjkiIC8+DQoJCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSUhFIEFsbGVyZ3kgQ29uY2VybiBUZW1wbGF0ZSBSZXF1aXJlcyB2YWx1ZSwgV2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9Q0QgYWxsb3dlZCAtLT4NCgkJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBQYXJ0aWNpcGFudCBibG9jayBmb3IgNi4wNC1Qcm9kdWN0IENvZGVkIC0tPg0KCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDU00iPg0KCQkJCQkJCQkJCQkJCTxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJNQU5VIj4NCgkJCQkJCQkJCQkJCQkJPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJNTUFUIj4NCgkJCQkJCQkJCQkJCQkJCTwhLS0gIDYuMDQgUFJPRFVDVCBDT0RFRCwgT3B0aW9uYWwtUjIsIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iVU5LIiBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCQkJCQkJCSA8b3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQkJCQkgPHJlZmVyZW5jZSB2YWx1ZT0iI2FuZENvZGVkQWxsZXJneU5hbWU0IiAvPg0KCQkJCQkJCQkJCQkJCQkJCSA8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkJCSA8L2NvZGU+DQoJCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDMgUFJPRFVDVCBGUkVFIFRFWFQsIFJFUVVJUkVELS0+DQoJCQkJCQkJCQkJCQkJCQk8bmFtZT5TT1kgTUlMSzwvbmFtZT4NCgkJCQkJCQkJCQkJCQkJPC9wbGF5aW5nRW50aXR5Pg0KCQkJCQkJCQkJCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudD4NCgkJCQkJCQkJCQkJCTwhLS0gIFNFVkVSSVRZIEVOVFJZIFJFTEFUSU9OU0hJUCBCTE9DSyBvcHRpb25hbCwgMCBvciAxIHBlciBBbGxlcmd5IC0tPg0KCQkJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0idHJ1ZSIgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCQkJCQkJCQkJCTwhLS1UZW1wbGF0ZSBJRCBmb3IgUHJvYmxlbSBFbnRyeSAtIEFsbGVyZ3kgUmVhY3Rpb24gVXNlcyBTYW1lIFN0cnVjdHVyZSAtLT4NCgkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNi4xIiAvPg0KCQkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCQkJCTwhLS0gU2V2ZXJpdHlUZW1wbGF0ZSBJRCAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41NSIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgQWxsZXJneSBUZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSBDQ0QgT2JzIElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJTRVYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENvZGUiIGRpc3BsYXlOYW1lPSJTZXZlcml0eSIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA3IFNFVkVSSVRZLUZSRUUgVEVYVCwgb3B0aW9uYWwsIFBvaW50ZXIgdG8gTmFycmF0aXZlIEJsb2NrLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2FuZFNldmVyaXR5NCIgLz4NCgkJCQkJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA4IFNFVkVSSVRZIENPREVELCBvcHRpb25hbCwgV2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9IkNEIiBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJCQkJPCEtLSAgUkVBQ1RJT04gRU5UUllSRUxBVElPTlNISVAgQkxPQ0sgb3B0aW9uYWwsIHJlcGVhdGFibGUgIC0tPg0KCQkJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0idHJ1ZSIgdHlwZUNvZGU9Ik1GU1QiPg0KCQkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCQkJCTwhLS0gUmVhY3Rpb24gVGVtcGxhdGUgSUQgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTQiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iSEw3QWN0Q29kZSIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA1IFJFQUNUSU9OLUZSRUUgVEVYVCwgb3B0aW9uYWwsLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2FuZFJlYWN0aW9uNC0xIiAvPg0KCQkJCQkJCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDYgUkVBQ1RJT04gQ09ERUQgb3B0aW9uYWwsIHdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPUNEIGFsbG93ZWQgLS0+DQoJCQkJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIC8+DQoJCQkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCTwvYWN0Pg0KCQkJCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCQkJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0QiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjciIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFRlbXBsYXRlcyBmb3IgQWxsZXJneS9EcnVnIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjYiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMSIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4zIiAvPg0KCQkJCQkJCQkJCTwhLS0gQ0NEIEFsbGVyZ3kgQWN0IElEIGFzIG51bGxmbGF2b3IgLS0+DQoJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSUhFIENvbmNlcm4gVGVtcGxhdGUgUmVxdWlyZXMgc3RhdHVzQ29kZSBhbmQgZWZmZWN0aXZlVGltZSAgLS0+DQoJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iYWN0aXZlIiAvPg0KCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEFMTEVSR0lFUy9EUlVHLCBPcHRpb25hbCAtLT4NCgkJCQkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQkJCQk8IS0tICBBREQgVElNRSBUTyBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEFMTEVSR0lFUy9EUlVHIC0tPg0KCQkJCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJCQkJPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJmYWxzZSIgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgQWxsZXJneSBUZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBBbGVydCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTgiIC8+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogSUhFIE9ic2VydmF0aW9uIFRlbXBsYXRlcyBSZXF1aXJlIElkIC0tPg0KCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gNi4wMiBBRFZFUlNFIEVWRU5UIFRZUEUsIFJFUVVJUkVEOyBTTk9NRUQgQ1QgIC0tPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDYuMDIgQURWRVJTRSBFVkVOVCBUWVBFIFNOT01FRCBDVCBUZXJtaW5vbG9neSBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjQxODQ3MTAwMCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgZGlzcGxheU5hbWU9IlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gZm9vZCI+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5GT09EPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIElIRSAgU3RhdHVzIENvZGUgZnJvIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAxIEFEVkVSU0UgRVZFTlQgREFURSwgT3B0aW9uYWwtUjIgLS0+DQoJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMTExMzE2MjI1MSIgLz4NCgkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJneSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHZhbHVlLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFBhcnRpY2lwYW50IGJsb2NrIGZvciA2LjA0LVByb2R1Y3QgQ29kZWQgLS0+DQoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSAgNi4wNCBQUk9EVUNUIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJCQkJIDxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkJCSA8cmVmZXJlbmNlIHZhbHVlPSIjYW5kQ29kZWRBbGxlcmd5TmFtZTUiIC8+DQoJCQkJCQkJCQkJCQkJCQkJIDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQkJIDwvY29kZT4NCgkJCQkJCQkJCQkJCQkJCTwhLS0gNi4wMyBQUk9EVUNUIEZSRUUgVEVYVCwgUkVRVUlSRUQtLT4NCgkJCQkJCQkJCQkJCQkJCTxuYW1lPkJBS0VEIEJFQU5TPC9uYW1lPg0KCQkJCQkJCQkJCQkJCQk8L3BsYXlpbmdFbnRpdHk+DQoJCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Pg0KCQkJCQkJCQkJCQkJPCEtLSAgU0VWRVJJVFkgRU5UUlkgUkVMQVRJT05TSElQIEJMT0NLIG9wdGlvbmFsLCAwIG9yIDEgcGVyIEFsbGVyZ3kgLS0+DQoJCQkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJ0cnVlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCQkJCQkJPCEtLVRlbXBsYXRlIElEIGZvciBQcm9ibGVtIEVudHJ5IC0gQWxsZXJneSBSZWFjdGlvbiBVc2VzIFNhbWUgU3RydWN0dXJlIC0tPg0KCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42LjEiIC8+DQoJCQkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCQkJPCEtLSBTZXZlcml0eVRlbXBsYXRlIElEIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjU1IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIENDRCBPYnMgSUQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IlNFViIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iSEw3QWN0Q29kZSIgZGlzcGxheU5hbWU9IlNldmVyaXR5IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDcgU0VWRVJJVFktRlJFRSBURVhULCBvcHRpb25hbCwgUG9pbnRlciB0byBOYXJyYXRpdmUgQmxvY2stLT4NCgkJCQkJCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjYW5kU2V2ZXJpdHk1IiAvPg0KCQkJCQkJCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDggU0VWRVJJVFkgQ09ERUQsIG9wdGlvbmFsLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT0iQ0QiIGFsbG93ZWQgLS0+DQoJCQkJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIC8+DQoJCQkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQkJCQk8IS0tICBSRUFDVElPTiBFTlRSWVJFTEFUSU9OU0hJUCBCTE9DSyBvcHRpb25hbCwgcmVwZWF0YWJsZSAgLS0+DQoJCQkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJ0cnVlIiB0eXBlQ29kZT0iTUZTVCI+DQoJCQkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCQkJPCEtLSBSZWFjdGlvbiBUZW1wbGF0ZSBJRCAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41NCIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgQWxsZXJneSBUZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDb2RlIiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDUgUkVBQ1RJT04tRlJFRSBURVhULCBvcHRpb25hbCwtLT4NCgkJCQkJCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjYW5kUmVhY3Rpb241LTEiIC8+DQoJCQkJCQkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNiBSRUFDVElPTiBDT0RFRCBvcHRpb25hbCwgd2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9Q0QgYWxsb3dlZCAtLT4NCgkJCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJPC9hY3Q+DQoJCQkJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJCQkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkNDRCIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNyIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgVGVtcGxhdGVzIGZvciBBbGxlcmd5L0RydWcgTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuNiIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4xIiAvPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjMiIC8+DQoJCQkJCQkJCQkJPCEtLSBDQ0QgQWxsZXJneSBBY3QgSUQgYXMgbnVsbGZsYXZvciAtLT4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQ29uY2VybiBUZW1wbGF0ZSBSZXF1aXJlcyBzdGF0dXNDb2RlIGFuZCBlZmZlY3RpdmVUaW1lICAtLT4NCgkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJhY3RpdmUiIC8+DQoJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgQUxMRVJHSUVTL0RSVUcsIE9wdGlvbmFsIC0tPg0KCQkJCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCQkJCTwhLS0gIEFERCBUSU1FIFRPIElORk9STUFUSU9OIFNPVVJDRSBGT1IgQUxMRVJHSUVTL0RSVUcgLS0+DQoJCQkJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249Ijk5MiIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQkJCQk8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9ImZhbHNlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEFsZXJ0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xOCIgLz4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBJSEUgT2JzZXJ2YXRpb24gVGVtcGxhdGVzIFJlcXVpcmUgSWQgLS0+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAyIEFEVkVSU0UgRVZFTlQgVFlQRSwgUkVRVUlSRUQ7IFNOT01FRCBDVCAgLS0+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgNi4wMiBBRFZFUlNFIEVWRU5UIFRZUEUgU05PTUVEIENUIFRlcm1pbm9sb2d5IFJlcXVpcmVkIC0tPg0KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNDE4NDcxMDAwIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBkaXNwbGF5TmFtZT0iUHJvcGVuc2l0eSB0byBhZHZlcnNlIHJlYWN0aW9ucyB0byBmb29kIj4NCgkJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PkZPT0Q8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCQkJCTwhLS0gSUhFICBTdGF0dXMgQ29kZSBmcm8gT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIDYuMDEgQURWRVJTRSBFVkVOVCBEQVRFLCBPcHRpb25hbC1SMiAtLT4NCgkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCTxsb3cgdmFsdWU9IjIwMTExMDI0MTUzMTM3IiAvPg0KCQkJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBBbGxlcmd5IENvbmNlcm4gVGVtcGxhdGUgUmVxdWlyZXMgdmFsdWUsIFdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPUNEIGFsbG93ZWQgLS0+DQoJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogUGFydGljaXBhbnQgYmxvY2sgZm9yIDYuMDQtUHJvZHVjdCBDb2RlZCAtLT4NCgkJCQkJCQkJCQkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iQ1NNIj4NCgkJCQkJCQkJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQoJCQkJCQkJCQkJCQkJCTxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iTU1BVCI+DQoJCQkJCQkJCQkJCQkJCQk8IS0tICA2LjA0IFBST0RVQ1QgQ09ERUQsIE9wdGlvbmFsLVIyLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IlVOSyIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQkJCQkJCQkgPG9yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkJCQkJIDxyZWZlcmVuY2UgdmFsdWU9IiNhbmRDb2RlZEFsbGVyZ3lOYW1lNiIgLz4NCgkJCQkJCQkJCQkJCQkJCQkgPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkgPC9jb2RlPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSA2LjAzIFBST0RVQ1QgRlJFRSBURVhULCBSRVFVSVJFRC0tPg0KCQkJCQkJCQkJCQkJCQkJPG5hbWU+V0FURVJNRUxPTlM8L25hbWU+DQoJCQkJCQkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4NCgkJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCQkJCQkJCQkJCTwvcGFydGljaXBhbnQ+DQoJCQkJCQkJCQkJCQk8IS0tICBTRVZFUklUWSBFTlRSWSBSRUxBVElPTlNISVAgQkxPQ0sgb3B0aW9uYWwsIDAgb3IgMSBwZXIgQWxsZXJneSAtLT4NCgkJCQkJCQkJCQkJCQ0KCQkJCQkJCQkJCQkJPCEtLSAgUkVBQ1RJT04gRU5UUllSRUxBVElPTlNISVAgQkxPQ0sgb3B0aW9uYWwsIHJlcGVhdGFibGUgIC0tPg0KCQkJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0idHJ1ZSIgdHlwZUNvZGU9Ik1GU1QiPg0KCQkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCQkJCTwhLS0gUmVhY3Rpb24gVGVtcGxhdGUgSUQgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTQiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iSEw3QWN0Q29kZSIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA1IFJFQUNUSU9OLUZSRUUgVEVYVCwgb3B0aW9uYWwsLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2FuZFJlYWN0aW9uNi0xIiAvPg0KCQkJCQkJCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDYgUkVBQ1RJT04gQ09ERUQgb3B0aW9uYWwsIHdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPUNEIGFsbG93ZWQgLS0+DQoJCQkJCQkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIC8+DQoJCQkJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCTwvYWN0Pg0KCQkJCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCQkJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0QiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjciIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFRlbXBsYXRlcyBmb3IgQWxsZXJneS9EcnVnIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjYiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMSIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4zIiAvPg0KCQkJCQkJCQkJCTwhLS0gQ0NEIEFsbGVyZ3kgQWN0IElEIGFzIG51bGxmbGF2b3IgLS0+DQoJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSUhFIENvbmNlcm4gVGVtcGxhdGUgUmVxdWlyZXMgc3RhdHVzQ29kZSBhbmQgZWZmZWN0aXZlVGltZSAgLS0+DQoJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iYWN0aXZlIiAvPg0KCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEFMTEVSR0lFUy9EUlVHLCBPcHRpb25hbCAtLT4NCgkJCQkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQkJCQk8IS0tICBBREQgVElNRSBUTyBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEFMTEVSR0lFUy9EUlVHIC0tPg0KCQkJCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI5OTIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJCQkJPG5hbWU+Q0hFWUVOTkUgSERSIFNRQTwvbmFtZT4NCgkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJmYWxzZSIgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgQWxsZXJneSBUZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBBbGVydCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTgiIC8+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogSUhFIE9ic2VydmF0aW9uIFRlbXBsYXRlcyBSZXF1aXJlIElkIC0tPg0KCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gNi4wMiBBRFZFUlNFIEVWRU5UIFRZUEUsIFJFUVVJUkVEOyBTTk9NRUQgQ1QgIC0tPg0KCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDYuMDIgQURWRVJTRSBFVkVOVCBUWVBFIFNOT01FRCBDVCBUZXJtaW5vbG9neSBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjQxODQ3MTAwMCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgZGlzcGxheU5hbWU9IlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gZm9vZCI+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5GT09EPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIElIRSAgU3RhdHVzIENvZGUgZnJvIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAxIEFEVkVSU0UgRVZFTlQgREFURSwgT3B0aW9uYWwtUjIgLS0+DQoJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMDEyMzA5NTUyNCIgLz4NCgkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJneSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHZhbHVlLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFBhcnRpY2lwYW50IGJsb2NrIGZvciA2LjA0LVByb2R1Y3QgQ29kZWQgLS0+DQoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSAgNi4wNCBQUk9EVUNUIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJCQkJIDxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkJCSA8cmVmZXJlbmNlIHZhbHVlPSIjYW5kQ29kZWRBbGxlcmd5TmFtZTciIC8+DQoJCQkJCQkJCQkJCQkJCQkJIDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQkJIDwvY29kZT4NCgkJCQkJCQkJCQkJCQkJCTwhLS0gNi4wMyBQUk9EVUNUIEZSRUUgVEVYVCwgUkVRVUlSRUQtLT4NCgkJCQkJCQkJCQkJCQkJCTxuYW1lPkhPTkVZPC9uYW1lPg0KCQkJCQkJCQkJCQkJCQk8L3BsYXlpbmdFbnRpdHk+DQoJCQkJCQkJCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Pg0KCQkJCQkJCQkJCQkJPCEtLSAgU0VWRVJJVFkgRU5UUlkgUkVMQVRJT05TSElQIEJMT0NLIG9wdGlvbmFsLCAwIG9yIDEgcGVyIEFsbGVyZ3kgLS0+DQoJCQkJCQkJCQkJCQkNCgkJCQkJCQkJCQkJCTwhLS0gIFJFQUNUSU9OIEVOVFJZUkVMQVRJT05TSElQIEJMT0NLIG9wdGlvbmFsLCByZXBlYXRhYmxlICAtLT4NCgkJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJNRlNUIj4NCgkJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJCQk8IS0tIFJlYWN0aW9uIFRlbXBsYXRlIElEIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjU0IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENvZGUiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNSBSRUFDVElPTi1GUkVFIFRFWFQsIG9wdGlvbmFsLC0tPg0KCQkJCQkJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNhbmRSZWFjdGlvbjctMSIgLz4NCgkJCQkJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA2IFJFQUNUSU9OIENPREVEIG9wdGlvbmFsLCB3aGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQk8L2FjdD4NCgkJCQkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQkJCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBUZW1wbGF0ZXMgZm9yIEFsbGVyZ3kvRHJ1ZyBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My42IiAvPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMyIgLz4NCgkJCQkJCQkJCQk8IS0tIENDRCBBbGxlcmd5IEFjdCBJRCBhcyBudWxsZmxhdm9yIC0tPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHN0YXR1c0NvZGUgYW5kIGVmZmVjdGl2ZVRpbWUgIC0tPg0KCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIgLz4NCgkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRywgT3B0aW9uYWwgLS0+DQoJCQkJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJCQkJPCEtLSAgQUREIFRJTUUgVE8gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRyAtLT4NCgkJCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gQWxlcnQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjE4IiAvPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IElIRSBPYnNlcnZhdGlvbiBUZW1wbGF0ZXMgUmVxdWlyZSBJZCAtLT4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIDYuMDIgQURWRVJTRSBFVkVOVCBUWVBFLCBSRVFVSVJFRDsgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA2LjAyIEFEVkVSU0UgRVZFTlQgVFlQRSBTTk9NRUQgQ1QgVGVybWlub2xvZ3kgUmVxdWlyZWQgLS0+DQoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSI0MTgwMzgwMDciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIGRpc3BsYXlOYW1lPSJQcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIHRvIHN1YnN0YW5jZSI+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5EUlVHLCBGT09EPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIElIRSAgU3RhdHVzIENvZGUgZnJvIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAxIEFEVkVSU0UgRVZFTlQgREFURSwgT3B0aW9uYWwtUjIgLS0+DQoJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMDEyMzE0NDkzOSIgLz4NCgkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJneSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHZhbHVlLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFBhcnRpY2lwYW50IGJsb2NrIGZvciA2LjA0LVByb2R1Y3QgQ29kZWQgLS0+DQoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSAgNi4wNCBQUk9EVUNUIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJCQkJIDxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkJCSA8cmVmZXJlbmNlIHZhbHVlPSIjYW5kQ29kZWRBbGxlcmd5TmFtZTgiIC8+DQoJCQkJCQkJCQkJCQkJCQkJIDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQkJIDwvY29kZT4NCgkJCQkJCQkJCQkJCQkJCTwhLS0gNi4wMyBQUk9EVUNUIEZSRUUgVEVYVCwgUkVRVUlSRUQtLT4NCgkJCQkJCQkJCQkJCQkJCTxuYW1lPk5VVFM8L25hbWU+DQoJCQkJCQkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4NCgkJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCQkJCQkJCQkJCTwvcGFydGljaXBhbnQ+DQoJCQkJCQkJCQkJCQk8IS0tICBTRVZFUklUWSBFTlRSWSBSRUxBVElPTlNISVAgQkxPQ0sgb3B0aW9uYWwsIDAgb3IgMSBwZXIgQWxsZXJneSAtLT4NCgkJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJCQkJCQk8IS0tVGVtcGxhdGUgSUQgZm9yIFByb2JsZW0gRW50cnkgLSBBbGxlcmd5IFJlYWN0aW9uIFVzZXMgU2FtZSBTdHJ1Y3R1cmUgLS0+DQoJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYuMSIgLz4NCgkJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJCQk8IS0tIFNldmVyaXR5VGVtcGxhdGUgSUQgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTUiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gQ0NEIE9icyBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iU0VWIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDb2RlIiBkaXNwbGF5TmFtZT0iU2V2ZXJpdHkiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNyBTRVZFUklUWS1GUkVFIFRFWFQsIG9wdGlvbmFsLCBQb2ludGVyIHRvIE5hcnJhdGl2ZSBCbG9jay0tPg0KCQkJCQkJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNhbmRTZXZlcml0eTgiIC8+DQoJCQkJCQkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wOCBTRVZFUklUWSBDT0RFRCwgb3B0aW9uYWwsIFdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPSJDRCIgYWxsb3dlZCAtLT4NCgkJCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCQkJCTwhLS0gIFJFQUNUSU9OIEVOVFJZUkVMQVRJT05TSElQIEJMT0NLIG9wdGlvbmFsLCByZXBlYXRhYmxlICAtLT4NCgkJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJNRlNUIj4NCgkJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJCQk8IS0tIFJlYWN0aW9uIFRlbXBsYXRlIElEIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjU0IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENvZGUiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNSBSRUFDVElPTi1GUkVFIFRFWFQsIG9wdGlvbmFsLC0tPg0KCQkJCQkJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNhbmRSZWFjdGlvbjgtMSIgLz4NCgkJCQkJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA2IFJFQUNUSU9OIENPREVEIG9wdGlvbmFsLCB3aGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPjxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJNRlNUIj4NCgkJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJCQk8IS0tIFJlYWN0aW9uIFRlbXBsYXRlIElEIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjU0IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENvZGUiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNSBSRUFDVElPTi1GUkVFIFRFWFQsIG9wdGlvbmFsLC0tPg0KCQkJCQkJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNhbmRSZWFjdGlvbjgtMiIgLz4NCgkJCQkJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA2IFJFQUNUSU9OIENPREVEIG9wdGlvbmFsLCB3aGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQk8L2FjdD4NCgkJCQkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQkJCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBUZW1wbGF0ZXMgZm9yIEFsbGVyZ3kvRHJ1ZyBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My42IiAvPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMyIgLz4NCgkJCQkJCQkJCQk8IS0tIENDRCBBbGxlcmd5IEFjdCBJRCBhcyBudWxsZmxhdm9yIC0tPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHN0YXR1c0NvZGUgYW5kIGVmZmVjdGl2ZVRpbWUgIC0tPg0KCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIgLz4NCgkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRywgT3B0aW9uYWwgLS0+DQoJCQkJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJCQkJPCEtLSAgQUREIFRJTUUgVE8gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRyAtLT4NCgkJCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gQWxlcnQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjE4IiAvPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IElIRSBPYnNlcnZhdGlvbiBUZW1wbGF0ZXMgUmVxdWlyZSBJZCAtLT4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIDYuMDIgQURWRVJTRSBFVkVOVCBUWVBFLCBSRVFVSVJFRDsgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA2LjAyIEFEVkVSU0UgRVZFTlQgVFlQRSBTTk9NRUQgQ1QgVGVybWlub2xvZ3kgUmVxdWlyZWQgLS0+DQoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSI0MTgwMzgwMDciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIGRpc3BsYXlOYW1lPSJQcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIHRvIHN1YnN0YW5jZSI+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5EUlVHLCBGT09EPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIElIRSAgU3RhdHVzIENvZGUgZnJvIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAxIEFEVkVSU0UgRVZFTlQgREFURSwgT3B0aW9uYWwtUjIgLS0+DQoJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMDEyNDEzMjI0MCIgLz4NCgkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJneSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHZhbHVlLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFBhcnRpY2lwYW50IGJsb2NrIGZvciA2LjA0LVByb2R1Y3QgQ29kZWQgLS0+DQoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSAgNi4wNCBQUk9EVUNUIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJCQkJIDxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkJCSA8cmVmZXJlbmNlIHZhbHVlPSIjYW5kQ29kZWRBbGxlcmd5TmFtZTkiIC8+DQoJCQkJCQkJCQkJCQkJCQkJIDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQkJIDwvY29kZT4NCgkJCQkJCQkJCQkJCQkJCTwhLS0gNi4wMyBQUk9EVUNUIEZSRUUgVEVYVCwgUkVRVUlSRUQtLT4NCgkJCQkJCQkJCQkJCQkJCTxuYW1lPk9BVFM8L25hbWU+DQoJCQkJCQkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4NCgkJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCQkJCQkJCQkJCTwvcGFydGljaXBhbnQ+DQoJCQkJCQkJCQkJCQk8IS0tICBTRVZFUklUWSBFTlRSWSBSRUxBVElPTlNISVAgQkxPQ0sgb3B0aW9uYWwsIDAgb3IgMSBwZXIgQWxsZXJneSAtLT4NCgkJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJCQkJCQk8IS0tVGVtcGxhdGUgSUQgZm9yIFByb2JsZW0gRW50cnkgLSBBbGxlcmd5IFJlYWN0aW9uIFVzZXMgU2FtZSBTdHJ1Y3R1cmUgLS0+DQoJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYuMSIgLz4NCgkJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJCQk8IS0tIFNldmVyaXR5VGVtcGxhdGUgSUQgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTUiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gQ0NEIE9icyBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iU0VWIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJITDdBY3RDb2RlIiBkaXNwbGF5TmFtZT0iU2V2ZXJpdHkiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNyBTRVZFUklUWS1GUkVFIFRFWFQsIG9wdGlvbmFsLCBQb2ludGVyIHRvIE5hcnJhdGl2ZSBCbG9jay0tPg0KCQkJCQkJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNhbmRTZXZlcml0eTkiIC8+DQoJCQkJCQkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wOCBTRVZFUklUWSBDT0RFRCwgb3B0aW9uYWwsIFdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPSJDRCIgYWxsb3dlZCAtLT4NCgkJCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCQkJCTwhLS0gIFJFQUNUSU9OIEVOVFJZUkVMQVRJT05TSElQIEJMT0NLIG9wdGlvbmFsLCByZXBlYXRhYmxlICAtLT4NCgkJCQkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJNRlNUIj4NCgkJCQkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQkJCQk8IS0tIFJlYWN0aW9uIFRlbXBsYXRlIElEIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjU0IiAvPg0KCQkJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBBbGxlcmd5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC42IiAvPg0KCQkJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkhMN0FjdENvZGUiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gNi4wNSBSRUFDVElPTi1GUkVFIFRFWFQsIG9wdGlvbmFsLC0tPg0KCQkJCQkJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNhbmRSZWFjdGlvbjktMSIgLz4NCgkJCQkJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA2IFJFQUNUSU9OIENPREVEIG9wdGlvbmFsLCB3aGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQk8L2FjdD4NCgkJCQkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQkJCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iQ0NEIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBUZW1wbGF0ZXMgZm9yIEFsbGVyZ3kvRHJ1ZyBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My42IiAvPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMyIgLz4NCgkJCQkJCQkJCQk8IS0tIENDRCBBbGxlcmd5IEFjdCBJRCBhcyBudWxsZmxhdm9yIC0tPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHN0YXR1c0NvZGUgYW5kIGVmZmVjdGl2ZVRpbWUgIC0tPg0KCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIgLz4NCgkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRywgT3B0aW9uYWwgLS0+DQoJCQkJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJCQkJPCEtLSAgQUREIFRJTUUgVE8gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBBTExFUkdJRVMvRFJVRyAtLT4NCgkJCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gQWxlcnQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjE4IiAvPg0KCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNiIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IElIRSBPYnNlcnZhdGlvbiBUZW1wbGF0ZXMgUmVxdWlyZSBJZCAtLT4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQk8IS0tIDYuMDIgQURWRVJTRSBFVkVOVCBUWVBFLCBSRVFVSVJFRDsgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA2LjAyIEFEVkVSU0UgRVZFTlQgVFlQRSBTTk9NRUQgQ1QgVGVybWlub2xvZ3kgUmVxdWlyZWQgLS0+DQoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSI0MTgwMzgwMDciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIGRpc3BsYXlOYW1lPSJQcm9wZW5zaXR5IHRvIGFkdmVyc2UgcmVhY3Rpb25zIHRvIHN1YnN0YW5jZSI+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5EUlVHLCBGT09EPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIElIRSAgU3RhdHVzIENvZGUgZnJvIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQkJPCEtLSA2LjAxIEFEVkVSU0UgRVZFTlQgREFURSwgT3B0aW9uYWwtUjIgLS0+DQoJCQkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMDUwMTE2NTQ0OCIgLz4NCgkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgQWxsZXJneSBDb25jZXJuIFRlbXBsYXRlIFJlcXVpcmVzIHZhbHVlLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFBhcnRpY2lwYW50IGJsb2NrIGZvciA2LjA0LVByb2R1Y3QgQ29kZWQgLS0+DQoJCQkJCQkJCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQkJCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCQkJCQkJCQk8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9Ik1NQVQiPg0KCQkJCQkJCQkJCQkJCQkJPCEtLSAgNi4wNCBQUk9EVUNUIENPREVELCBPcHRpb25hbC1SMiwgUmVtb3ZlZCBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJCQkJIDxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCQkJCSA8cmVmZXJlbmNlIHZhbHVlPSIjYW5kQ29kZWRBbGxlcmd5TmFtZTEwIiAvPg0KCQkJCQkJCQkJCQkJCQkJCSA8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkJCSA8L2NvZGU+DQoJCQkJCQkJCQkJCQkJCQk8IS0tIDYuMDMgUFJPRFVDVCBGUkVFIFRFWFQsIFJFUVVJUkVELS0+DQoJCQkJCQkJCQkJCQkJCQk8bmFtZT5DSE9DT0xBVEU8L25hbWU+DQoJCQkJCQkJCQkJCQkJCTwvcGxheWluZ0VudGl0eT4NCgkJCQkJCQkJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCQkJCQkJCQkJCTwvcGFydGljaXBhbnQ+DQoJCQkJCQkJCQkJCQk8IS0tICBTRVZFUklUWSBFTlRSWSBSRUxBVElPTlNISVAgQkxPQ0sgb3B0aW9uYWwsIDAgb3IgMSBwZXIgQWxsZXJneSAtLT4NCgkJCQkJCQkJCQkJCQ0KCQkJCQkJCQkJCQkJPCEtLSAgUkVBQ1RJT04gRU5UUllSRUxBVElPTlNISVAgQkxPQ0sgb3B0aW9uYWwsIHJlcGVhdGFibGUgIC0tPg0KCQkJCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0idHJ1ZSIgdHlwZUNvZGU9Ik1GU1QiPg0KCQkJCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCQkJCTwhLS0gUmVhY3Rpb24gVGVtcGxhdGUgSUQgLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTQiIC8+DQoJCQkJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIEFsbGVyZ3kgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjYiIC8+DQoJCQkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iSEw3QWN0Q29kZSIgLz4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA1IFJFQUNUSU9OLUZSRUUgVEVYVCwgb3B0aW9uYWwsLS0+DQoJCQkJCQkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2FuZFJlYWN0aW9uMTAtMSIgLz4NCgkJCQkJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJCQkJPCEtLSA2LjA2IFJFQUNUSU9OIENPREVEIG9wdGlvbmFsLCB3aGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT1DRCBhbGxvd2VkIC0tPg0KCQkJCQkJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQk8L2FjdD4NCgkJCQkJCQkJPC9lbnRyeT4NCgkJCQkJCQk8L3NlY3Rpb24+DQoJCQkJCQk8L2NvbXBvbmVudD4NCgkJCTwhLS0gDQoJCQkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCQkJUFJPQkxFTS9DT05ESVRJT04gU0VDVElPTg0KCQkJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgkJCS0tPg0KCQkJPGNvbXBvbmVudD4gPCEtLSBDb21wb25lbnQgMiAtLT4NCgkJCQk8c2VjdGlvbj4NCgkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBTZWN0aW9uIFRlbXBsYXRlIC0tPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjExIiAvPg0KCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgUHJvYmxlbSBTZWN0aW9uIFRlbXBsYXRlIC0tPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjEwMyIgLz4NCgkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBBY3RpdmUgUHJvYmxlbXMgU2VjdGlvbiBUZW1wbGF0ZSAtLT4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS4zLjYiIC8+DQoJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBDODMgLSBJSEUgUHJvYmxlbSBDb25jZXJuIFRlbXBsYXRlcyAtLT4NCgkJCQkJPCEtLSB0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiLw0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4yIi8gLS0+DQoJCQkJCTxjb2RlIGNvZGU9IjExNDUwLTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBkaXNwbGF5TmFtZT0iUHJvYmxlbXMiIC8+DQoJCQkJCTx0aXRsZT5Qcm9ibGVtcy9Db25kaXRpb25zPC90aXRsZT4NCgkJCQkJPCEtLSAgUFJPQkxFTVMgTkFSUkFUSVZFIEJMT0NLLCBSZXF1aXJlZCAtLT4NCiAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8IS0tIFZMRVIgU0VHIDFCOiBQcm9ibGVtL0NvbmRpdGlvbiBCdXNpbmVzcyBSdWxlcyBmb3IgTWVkaWNhbCBDb250ZW50ICAtLT4NCiAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCQkJCQk8dGhlYWQ+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0aD5EZXBhcnRtZW50IG9mIFZldGVyYW5zIEFmZmFpcnM8L3RoPg0KCQkJCQkJCQkJPHRoPkJ1c2luZXNzIFJ1bGVzIGZvciBDb25zdHJ1Y3Rpb24gb2YgTWVkaWNhbCBJbmZvcm1hdGlvbjwvdGg+DQoJCQkJCQkJCTwvdHI+DQoJCQkJCQkJPC90aGVhZD4NCgkJCQkJCQk8dGJvZHk+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0ZD5Qcm9ibGVtcy9Db25kaXRpb25zPC90ZD4NCgkJCQkJCQkJCTx0ZD5UaGlzIHNlY3Rpb24gY29udGFpbnMgcGF0aWVudCBjb25kaXRpb25zIChhY3RpdmUgYW5kIGluYWN0aXZlKSBpbmZvcm1hdGlvbiBmcm9tIGFsbCBWQSB0cmVhdG1lbnQgZmFjaWxpdGllcy4gSXQgZG9lcyBub3QgY29udGFpbiBwYXRpZW50IGNvbmRpdGlvbnMgdGhhdCB3ZXJlIGRlbGV0ZWQuPC90ZD4NCgkJCQkJCQkJPC90cj4NCgkJCQkJCQk8L3Rib2R5Pg0KCQkJCQkJPC90YWJsZT4NCgkJCQkJCTx0YWJsZSBJRD0icHJvYmxlbU5hcnJpdGl2ZSIgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+DQoJCQkJCQkJPHRoZWFkPg0KCQkJCQkJCQk8dHI+DQoJCQkJCQkJCQk8dGg+UHJvYmxlbTwvdGg+DQoJCQkJCQkJCQk8dGg+U3RhdHVzPC90aD4NCgkJCQkJCQkJCTx0aD5Qcm9ibGVtIENvZGU8L3RoPg0KCQkJCQkJCQkJPHRoPkRhdGUgb2YgT25zZXQ8L3RoPg0KCQkJCQkJCQkJPHRoPlByb3ZpZGVyPC90aD4NCgkJCQkJCQkJCTx0aD5Tb3VyY2U8L3RoPg0KCQkJCQkJCQk8L3RyPg0KCQkJCQkJCTwvdGhlYWQ+DQoJCQkJCQkJPHRib2R5Pg0KCQkJCQkJCQk8dHI+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb2JsZW0xIj5Db3VnaCAoSUNELTktQ00gNzg2LjIpPC9jb250ZW50Pg0KCQkJCQkJCQkgICAgPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU3RhdHVzMSI+QWN0aXZlPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbUNvZGUxIj43ODYuMjwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZERhdGVPZk9uc2V0MSI+MjAxMjAzMTQ8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm92aWRlcjEiPkJSVVVOLEpFU1NFPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU291cmNlMSI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm9ibGVtMiI+QWxsZXJnaWMgYXJ0aHJpdGlzIG9mIG11bHRpcGxlIHNpdGVzIChJQ0QtOS1DTSA3MTYuMjkpPC9jb250ZW50Pg0KCQkJCQkJCQkgICAgPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU3RhdHVzMiI+QWN0aXZlPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbUNvZGUyIj43MTYuMjk8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmREYXRlT2ZPbnNldDIiPjIwMTIwMzEwPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvdmlkZXIyIj5DSERSQU1EUFJPVixBTElDSUEgTTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFNvdXJjZTIiPk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbTMiPldlYWtuZXNzIG9mIGxpbWIgKElDRC05LUNNIDcyOC44Nyk8L2NvbnRlbnQ+DQoJCQkJCQkJCSAgICA8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRTdGF0dXMzIj5BY3RpdmU8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm9ibGVtQ29kZTMiPjcyOC44NzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZERhdGVPZk9uc2V0MyIgLz4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb3ZpZGVyMyI+UHJvdmlkZXIsIE9uZTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFNvdXJjZTMiPk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbTQiPkFydGhyaXRpcywgUmhldW1hdG9pZCAoSUNELTktQ00gNzE0LjApPC9jb250ZW50Pg0KCQkJCQkJCQkgICAgPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU3RhdHVzNCI+QWN0aXZlPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbUNvZGU0Ij43MTQuMDwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZERhdGVPZk9uc2V0NCI+MjAxMTEwMjA8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm92aWRlcjQiPlByb3ZpZGVyLCBPbmU8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRTb3VyY2U0Ij5DSEVZRU5ORSBIRFIgU1FBPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb2JsZW01Ij5PYmVzaXR5IGluIERpYWJldGVzIChJQ0QtOS1DTSAyNzguMDApPC9jb250ZW50Pg0KCQkJCQkJCQkgICAgPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU3RhdHVzNSI+QWN0aXZlPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbUNvZGU1Ij4yNzguMDA8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmREYXRlT2ZPbnNldDUiPjIwMTExMDI0PC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvdmlkZXI1Ij5Qcm92aWRlciwgT25lPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU291cmNlNSI+Q0hFWUVOTkUgSERSIFNRQTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm9ibGVtNiI+RGlhYmV0aWMgRm9vdCBVbGNlcjwvY29udGVudD4NCgkJCQkJCQkJICAgIDwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFN0YXR1czYiPkFjdGl2ZTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb2JsZW1Db2RlNiI+MjUwLjgwPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kRGF0ZU9mT25zZXQ2Ij4yMDExMTAxMTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb3ZpZGVyNiI+UE9ORCxORUFMPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU291cmNlNiI+Q0hFWUVOTkUgSERSIFNRQTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm9ibGVtNyI+QW5ldXJ5c20sIEFvcnRhLCBBYmRvbWluYWw8L2NvbnRlbnQ+DQoJCQkJCQkJCSAgICA8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRTdGF0dXM3Ij5BY3RpdmU8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm9ibGVtQ29kZTciPjQ0MS40PC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kRGF0ZU9mT25zZXQ3IiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvdmlkZXI3Ij5QT05ELE5FQUw8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRTb3VyY2U3Ij5DSEVZRU5ORSBIRFIgU1FBPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb2JsZW04Ij5Db3VnaDwvY29udGVudD4NCgkJCQkJCQkJICAgIDwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFN0YXR1czgiPkFjdGl2ZTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb2JsZW1Db2RlOCI+Nzg2LjI8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmREYXRlT2ZPbnNldDgiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm92aWRlcjgiPlBPTkQsTkVBTDwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFNvdXJjZTgiPkNIRVlFTk5FIEhEUiBTUUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbTkiPkRlcm1hdG9teW9zaXRpczwvY29udGVudD4NCgkJCQkJCQkJICAgIDwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFN0YXR1czkiPkFjdGl2ZTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFByb2JsZW1Db2RlOSI+NzEwLjM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmREYXRlT2ZPbnNldDkiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRQcm92aWRlcjkiPlBPTkQsTkVBTDwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBuZFNvdXJjZTkiPkNIRVlFTk5FIEhEUiBTUUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbTEwIj5IeXBlcnRlbnNpb248L2NvbnRlbnQ+DQoJCQkJCQkJCSAgICA8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmRTdGF0dXMxMCI+QWN0aXZlPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvYmxlbUNvZGUxMCI+NDAxLjk8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwbmREYXRlT2ZPbnNldDEwIiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kUHJvdmlkZXIxMCI+UE9ORCxORUFMPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icG5kU291cmNlMTAiPkNIRVlFTk5FIEhEUiBTUUE8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPg0KCQkJCQkJCTwvdGJvZHk+DQoJCQkJCQk8L3RhYmxlPg0KCQkJCQk8L3RleHQ+DQoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8IS0tIENDRCBQcm9ibGVtIEFjdCBUZW1wbGF0ZSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuNyIgLz4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4xIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBDQ0QgUHJvYmxlbSBBY3QgSUQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIFYyLjUgSUhFIFByb2JsZW0gQ29uY2VybiBUZW1wbGF0ZXMgUmVxdWlyZXMgc3RhdHVzQ29kZSAtLT4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJPCEtLSAgNy4wMSBQUk9CTEVNIERBVEUgKGNkYTpsb3c9RGF0ZSBvZiBPbnNldCwgY2RhOmhpZ2g9RGF0ZSBSZXNvbHZlZCksIE9wdGlvbmFsIFIyIC0tPg0KCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDEyMDMxNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJICAgIDwhLS0gNy4wNSBUUkVBVElORyBQUk9WSURFUiBpZCBsaW5rIHRvIEhlYWx0aENhcmUgUHJvdmlkZXIgRW50cnktLT4gDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249InByb3ZpZGVyMSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQoJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIFBST0JMRU0sIE9wdGlvbmFsIC0tPg0KCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRpbWUgYXMgbnVsbEZsYXZvciBiZWNhdXNlIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9ImZhbHNlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCTwhLS0gQ0NEIFByb2JsZW0gb2JzZXJ2YXRpb24gLSBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCTwhLS0gUHJvYmxlbSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBDODMgVGVtcGxhdGVzIGZvciBQcm9ibGVtIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQkJICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkgIAk8IS0tIENDRCBQcm9ibGVtIE9icyBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8IS0tIDcuMDIgUFJPQkxFTSBUWVBFLCBSMiwgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA3LjAyIFBST0JMRU0gVFlQRSwgT3B0aW9uYWwgU05PTUVEIENULCBwcm92aWRlZCBhcyBudWxsRmFsdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJPGNvZGUgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PlByb2JsZW0gVHlwZSBOb3QgQXZhaWxhYmxlPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQk8IS0tIDcuMDMgUFJPQkxFTSBOQU1FLCBSRVFVSVJFRCAtLT4NCgkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNwbmRQcm9ibGVtMSIgLz4NCgkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIGxvdyB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPiANCgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCTwhLS0gIDcuMDQgUFJPQkxFTSBDT0RFLCBPcHRpb25hbCwgV2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9IkNEIiBhbGxvd2VkLCBBdmFpbGFibGUgYXMgSUNELTksIG5vdCBTTk9NRUQgQ1QsICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCI+DQoJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9Ijc4Ni4yIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRC05LUNNIiAvPg0KCQkJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCQkJCTwhLS0gIDcuMTIgUFJPQkxFTSBTVEFUVVMgZW50cnlSZWxhdGlvbnNoaXAgYmxvY2ssIE9wdGlvbmFsLCAtLT4NCgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQ0NEIFByb2JsZW0gc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUwIiAvPiANCgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iU3RhdHVzIiAvPg0KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCTwhLS0gIEhJVFNQIEMzMiBWMi41OiA3LjEyIFBST0JMRU0gU1RBVFVTICBPcHRpb25hbCwgVHJhbnNsYXRlZCBmdG9tIFZpc3RBIHZhbHVlIC0tPg0KCQkJCQkJCQkJCQk8dmFsdWUgY29kZT0iNTU1NjEwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBY3RpdmUiIHhzaTp0eXBlPSJDRSI+DQoJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PkFDVElWRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQk8L2FjdD4NCgkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBBY3QgVGVtcGxhdGUgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNyIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBDODMgVGVtcGxhdGVzIGZvciBQcm9ibGVtIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjciIC8+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4yIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gQ0NEIFByb2JsZW0gQWN0IElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBWMi41IElIRSBQcm9ibGVtIENvbmNlcm4gVGVtcGxhdGVzIFJlcXVpcmVzIHN0YXR1c0NvZGUgLS0+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCTwhLS0gIDcuMDEgUFJPQkxFTSBEQVRFIChjZGE6bG93PURhdGUgb2YgT25zZXQsIGNkYTpoaWdoPURhdGUgUmVzb2x2ZWQpLCBPcHRpb25hbCBSMiAtLT4NCgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJPGxvdyB2YWx1ZT0iMjAxMjAzMTAiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCSAgICA8IS0tIDcuMDUgVFJFQVRJTkcgUFJPVklERVIgaWQgbGluayB0byBIZWFsdGhDYXJlIFByb3ZpZGVyIEVudHJ5LS0+IA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSJwcm92aWRlcjIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBQUk9CTEVNLCBPcHRpb25hbCAtLT4NCgkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUaW1lIGFzIG51bGxGbGF2b3IgYmVjYXVzZSBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJmYWxzZSIgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCQkJCQk8IS0tIENDRCBQcm9ibGVtIG9ic2VydmF0aW9uIC0gUmVxdWlyZWQgLS0+DQoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQk8IS0tIFByb2JsZW0gb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgQzgzIFRlbXBsYXRlcyBmb3IgUHJvYmxlbSBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJCSAgICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJICAJPCEtLSBDQ0QgUHJvYmxlbSBPYnMgSUQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPCEtLSA3LjAyIFBST0JMRU0gVFlQRSwgUjIsIFNOT01FRCBDVCAgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgNy4wMiBQUk9CTEVNIFRZUEUsIE9wdGlvbmFsIFNOT01FRCBDVCwgcHJvdmlkZWQgYXMgbnVsbEZhbHZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCTxjb2RlIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5Qcm9ibGVtIFR5cGUgTm90IEF2YWlsYWJsZTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCQkJPCEtLSA3LjAzIFBST0JMRU0gTkFNRSwgUkVRVUlSRUQgLS0+DQoJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcG5kUHJvYmxlbTIiIC8+DQoJCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBJSEUgUHJvYmxlbSBUZW1wbGF0ZXMgUmVxdWlyZSBsb3cgdmFsdWUgZW50cnkgLS0+DQoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4gDQoJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQk8IS0tICA3LjA0IFBST0JMRU0gQ09ERSwgT3B0aW9uYWwsIFdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPSJDRCIgYWxsb3dlZCwgQXZhaWxhYmxlIGFzIElDRC05LCBub3QgU05PTUVEIENULCAgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBJSEUgUHJvYmxlbSBUZW1wbGF0ZXMgUmVxdWlyZSB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiPg0KCQkJCQkJCQkJCTx0cmFuc2xhdGlvbiBjb2RlPSI3MTYuMjkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNELTktQ00iIC8+DQoJCQkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJCQkJPCEtLSAgNy4xMiBQUk9CTEVNIFNUQVRVUyBlbnRyeVJlbGF0aW9uc2hpcCBibG9jaywgT3B0aW9uYWwsIC0tPg0KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCgkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBDQ0QgUHJvYmxlbSBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTAiIC8+IA0KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIC8+DQoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQkJPCEtLSAgSElUU1AgQzMyIFYyLjU6IDcuMTIgUFJPQkxFTSBTVEFUVVMgIE9wdGlvbmFsLCBUcmFuc2xhdGVkIGZ0b20gVmlzdEEgdmFsdWUgLS0+DQoJCQkJCQkJCQkJCTx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgeHNpOnR5cGU9IkNFIj4NCgkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+QUNUSVZFPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCTwvYWN0Pg0KCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8IS0tIENDRCBQcm9ibGVtIEFjdCBUZW1wbGF0ZSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuNyIgLz4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4xIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBDQ0QgUHJvYmxlbSBBY3QgSUQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIFYyLjUgSUhFIFByb2JsZW0gQ29uY2VybiBUZW1wbGF0ZXMgUmVxdWlyZXMgc3RhdHVzQ29kZSAtLT4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJPCEtLSAgNy4wMSBQUk9CTEVNIERBVEUgKGNkYTpsb3c9RGF0ZSBvZiBPbnNldCwgY2RhOmhpZ2g9RGF0ZSBSZXNvbHZlZCksIE9wdGlvbmFsIFIyIC0tPg0KCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJICAgIDwhLS0gNy4wNSBUUkVBVElORyBQUk9WSURFUiBpZCBsaW5rIHRvIEhlYWx0aENhcmUgUHJvdmlkZXIgRW50cnktLT4gDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249InByb3ZpZGVyMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQoJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIFBST0JMRU0sIE9wdGlvbmFsIC0tPg0KCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRpbWUgYXMgbnVsbEZsYXZvciBiZWNhdXNlIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9ImZhbHNlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCTwhLS0gQ0NEIFByb2JsZW0gb2JzZXJ2YXRpb24gLSBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCTwhLS0gUHJvYmxlbSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBDODMgVGVtcGxhdGVzIGZvciBQcm9ibGVtIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQkJICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkgIAk8IS0tIENDRCBQcm9ibGVtIE9icyBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8IS0tIDcuMDIgUFJPQkxFTSBUWVBFLCBSMiwgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA3LjAyIFBST0JMRU0gVFlQRSwgT3B0aW9uYWwgU05PTUVEIENULCBwcm92aWRlZCBhcyBudWxsRmFsdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJPGNvZGUgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PlByb2JsZW0gVHlwZSBOb3QgQXZhaWxhYmxlPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQk8IS0tIDcuMDMgUFJPQkxFTSBOQU1FLCBSRVFVSVJFRCAtLT4NCgkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNwbmRQcm9ibGVtMyIgLz4NCgkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIGxvdyB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPiANCgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCTwhLS0gIDcuMDQgUFJPQkxFTSBDT0RFLCBPcHRpb25hbCwgV2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9IkNEIiBhbGxvd2VkLCBBdmFpbGFibGUgYXMgSUNELTksIG5vdCBTTk9NRUQgQ1QsICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCI+DQoJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjcyOC44NyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0QtOS1DTSIgLz4NCgkJCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQkJCQk8IS0tICA3LjEyIFBST0JMRU0gU1RBVFVTIGVudHJ5UmVsYXRpb25zaGlwIGJsb2NrLCBPcHRpb25hbCwgLS0+DQoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIENDRCBQcm9ibGVtIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MCIgLz4gDQoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IlN0YXR1cyIgLz4NCgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQk8IS0tICBISVRTUCBDMzIgVjIuNTogNy4xMiBQUk9CTEVNIFNUQVRVUyAgT3B0aW9uYWwsIFRyYW5zbGF0ZWQgZnRvbSBWaXN0QSB2YWx1ZSAtLT4NCgkJCQkJCQkJCQkJPHZhbHVlIGNvZGU9IjU1NTYxMDAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQWN0aXZlIiB4c2k6dHlwZT0iQ0UiPg0KCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5BQ1RJVkU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJPC9hY3Q+DQoJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTwhLS0gQ0NEIFByb2JsZW0gQWN0IFRlbXBsYXRlIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjciIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgQzgzIFRlbXBsYXRlcyBmb3IgUHJvYmxlbSBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My43IiAvPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIENDRCBQcm9ibGVtIEFjdCBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgVjIuNSBJSEUgUHJvYmxlbSBDb25jZXJuIFRlbXBsYXRlcyBSZXF1aXJlcyBzdGF0dXNDb2RlIC0tPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQk8IS0tICA3LjAxIFBST0JMRU0gREFURSAoY2RhOmxvdz1EYXRlIG9mIE9uc2V0LCBjZGE6aGlnaD1EYXRlIFJlc29sdmVkKSwgT3B0aW9uYWwgUjIgLS0+DQoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCTxsb3cgdmFsdWU9IjIwMTExMDIwIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkgICAgPCEtLSA3LjA1IFRSRUFUSU5HIFBST1ZJREVSIGlkIGxpbmsgdG8gSGVhbHRoQ2FyZSBQcm92aWRlciBFbnRyeS0tPiANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0icHJvdmlkZXI0IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCgkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgUFJPQkxFTSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGltZSBhcyBudWxsRmxhdm9yIGJlY2F1c2UgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBvYnNlcnZhdGlvbiAtIFJlcXVpcmVkIC0tPg0KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJPCEtLSBQcm9ibGVtIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCQkgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCSAgCTwhLS0gQ0NEIFByb2JsZW0gT2JzIElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTwhLS0gNy4wMiBQUk9CTEVNIFRZUEUsIFIyLCBTTk9NRUQgQ1QgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDcuMDIgUFJPQkxFTSBUWVBFLCBPcHRpb25hbCBTTk9NRUQgQ1QsIHByb3ZpZGVkIGFzIG51bGxGYWx2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQk8Y29kZSBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+UHJvYmxlbSBUeXBlIE5vdCBBdmFpbGFibGU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCTwhLS0gNy4wMyBQUk9CTEVNIE5BTUUsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3BuZFByb2JsZW00IiAvPg0KCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgSUhFIFByb2JsZW0gVGVtcGxhdGVzIFJlcXVpcmUgbG93IHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+IA0KCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJPCEtLSAgNy4wNCBQUk9CTEVNIENPREUsIE9wdGlvbmFsLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT0iQ0QiIGFsbG93ZWQsIEF2YWlsYWJsZSBhcyBJQ0QtOSwgbm90IFNOT01FRCBDVCwgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgSUhFIFByb2JsZW0gVGVtcGxhdGVzIFJlcXVpcmUgdmFsdWUgZW50cnkgLS0+DQoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIj4NCgkJCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iNzE0LjAiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNELTktQ00iIC8+DQoJCQkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJCQkJPCEtLSAgNy4xMiBQUk9CTEVNIFNUQVRVUyBlbnRyeVJlbGF0aW9uc2hpcCBibG9jaywgT3B0aW9uYWwsIC0tPg0KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCgkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBDQ0QgUHJvYmxlbSBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTAiIC8+IA0KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIC8+DQoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQkJPCEtLSAgSElUU1AgQzMyIFYyLjU6IDcuMTIgUFJPQkxFTSBTVEFUVVMgIE9wdGlvbmFsLCBUcmFuc2xhdGVkIGZ0b20gVmlzdEEgdmFsdWUgLS0+DQoJCQkJCQkJCQkJCTx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgeHNpOnR5cGU9IkNFIj4NCgkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+QUNUSVZFPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCTwvYWN0Pg0KCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8IS0tIENDRCBQcm9ibGVtIEFjdCBUZW1wbGF0ZSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuNyIgLz4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4xIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBDQ0QgUHJvYmxlbSBBY3QgSUQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIFYyLjUgSUhFIFByb2JsZW0gQ29uY2VybiBUZW1wbGF0ZXMgUmVxdWlyZXMgc3RhdHVzQ29kZSAtLT4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJPCEtLSAgNy4wMSBQUk9CTEVNIERBVEUgKGNkYTpsb3c9RGF0ZSBvZiBPbnNldCwgY2RhOmhpZ2g9RGF0ZSBSZXNvbHZlZCksIE9wdGlvbmFsIFIyIC0tPg0KCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQk8bG93IHZhbHVlPSIyMDExMTAyNCIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJICAgIDwhLS0gNy4wNSBUUkVBVElORyBQUk9WSURFUiBpZCBsaW5rIHRvIEhlYWx0aENhcmUgUHJvdmlkZXIgRW50cnktLT4gDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249InByb3ZpZGVyNSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQoJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIFBST0JMRU0sIE9wdGlvbmFsIC0tPg0KCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRpbWUgYXMgbnVsbEZsYXZvciBiZWNhdXNlIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCTxpZCBleHRlbnNpb249Ijk5MiIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQk8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9ImZhbHNlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCTwhLS0gQ0NEIFByb2JsZW0gb2JzZXJ2YXRpb24gLSBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCTwhLS0gUHJvYmxlbSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBDODMgVGVtcGxhdGVzIGZvciBQcm9ibGVtIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQkJICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkgIAk8IS0tIENDRCBQcm9ibGVtIE9icyBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8IS0tIDcuMDIgUFJPQkxFTSBUWVBFLCBSMiwgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA3LjAyIFBST0JMRU0gVFlQRSwgT3B0aW9uYWwgU05PTUVEIENULCBwcm92aWRlZCBhcyBudWxsRmFsdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJPGNvZGUgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PlByb2JsZW0gVHlwZSBOb3QgQXZhaWxhYmxlPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQk8IS0tIDcuMDMgUFJPQkxFTSBOQU1FLCBSRVFVSVJFRCAtLT4NCgkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNwbmRQcm9ibGVtNSIgLz4NCgkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIGxvdyB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPiANCgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCTwhLS0gIDcuMDQgUFJPQkxFTSBDT0RFLCBPcHRpb25hbCwgV2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9IkNEIiBhbGxvd2VkLCBBdmFpbGFibGUgYXMgSUNELTksIG5vdCBTTk9NRUQgQ1QsICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCI+DQoJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjI3OC4wMCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0QtOS1DTSIgLz4NCgkJCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQkJCQk8IS0tICA3LjEyIFBST0JMRU0gU1RBVFVTIGVudHJ5UmVsYXRpb25zaGlwIGJsb2NrLCBPcHRpb25hbCwgLS0+DQoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIENDRCBQcm9ibGVtIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MCIgLz4gDQoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IlN0YXR1cyIgLz4NCgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQk8IS0tICBISVRTUCBDMzIgVjIuNTogNy4xMiBQUk9CTEVNIFNUQVRVUyAgT3B0aW9uYWwsIFRyYW5zbGF0ZWQgZnRvbSBWaXN0QSB2YWx1ZSAtLT4NCgkJCQkJCQkJCQkJPHZhbHVlIGNvZGU9IjU1NTYxMDAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQWN0aXZlIiB4c2k6dHlwZT0iQ0UiPg0KCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5BQ1RJVkU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJPC9hY3Q+DQoJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTwhLS0gQ0NEIFByb2JsZW0gQWN0IFRlbXBsYXRlIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjciIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgQzgzIFRlbXBsYXRlcyBmb3IgUHJvYmxlbSBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My43IiAvPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIENDRCBQcm9ibGVtIEFjdCBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgVjIuNSBJSEUgUHJvYmxlbSBDb25jZXJuIFRlbXBsYXRlcyBSZXF1aXJlcyBzdGF0dXNDb2RlIC0tPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQk8IS0tICA3LjAxIFBST0JMRU0gREFURSAoY2RhOmxvdz1EYXRlIG9mIE9uc2V0LCBjZGE6aGlnaD1EYXRlIFJlc29sdmVkKSwgT3B0aW9uYWwgUjIgLS0+DQoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCTxsb3cgdmFsdWU9IjIwMTExMDExIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkgICAgPCEtLSA3LjA1IFRSRUFUSU5HIFBST1ZJREVSIGlkIGxpbmsgdG8gSGVhbHRoQ2FyZSBQcm92aWRlciBFbnRyeS0tPiANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0icHJvdmlkZXI2IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCgkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgUFJPQkxFTSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGltZSBhcyBudWxsRmxhdm9yIGJlY2F1c2UgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBvYnNlcnZhdGlvbiAtIFJlcXVpcmVkIC0tPg0KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJPCEtLSBQcm9ibGVtIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCQkgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCSAgCTwhLS0gQ0NEIFByb2JsZW0gT2JzIElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTwhLS0gNy4wMiBQUk9CTEVNIFRZUEUsIFIyLCBTTk9NRUQgQ1QgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDcuMDIgUFJPQkxFTSBUWVBFLCBPcHRpb25hbCBTTk9NRUQgQ1QsIHByb3ZpZGVkIGFzIG51bGxGYWx2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQk8Y29kZSBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+UHJvYmxlbSBUeXBlIE5vdCBBdmFpbGFibGU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCTwhLS0gNy4wMyBQUk9CTEVNIE5BTUUsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3BuZFByb2JsZW02IiAvPg0KCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgSUhFIFByb2JsZW0gVGVtcGxhdGVzIFJlcXVpcmUgbG93IHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+IA0KCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJPCEtLSAgNy4wNCBQUk9CTEVNIENPREUsIE9wdGlvbmFsLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT0iQ0QiIGFsbG93ZWQsIEF2YWlsYWJsZSBhcyBJQ0QtOSwgbm90IFNOT01FRCBDVCwgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgSUhFIFByb2JsZW0gVGVtcGxhdGVzIFJlcXVpcmUgdmFsdWUgZW50cnkgLS0+DQoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIj4NCgkJCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iMjUwLjgwIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRC05LUNNIiAvPg0KCQkJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCQkJCTwhLS0gIDcuMTIgUFJPQkxFTSBTVEFUVVMgZW50cnlSZWxhdGlvbnNoaXAgYmxvY2ssIE9wdGlvbmFsLCAtLT4NCgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQ0NEIFByb2JsZW0gc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUwIiAvPiANCgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iU3RhdHVzIiAvPg0KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCTwhLS0gIEhJVFNQIEMzMiBWMi41OiA3LjEyIFBST0JMRU0gU1RBVFVTICBPcHRpb25hbCwgVHJhbnNsYXRlZCBmdG9tIFZpc3RBIHZhbHVlIC0tPg0KCQkJCQkJCQkJCQk8dmFsdWUgY29kZT0iNTU1NjEwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBY3RpdmUiIHhzaTp0eXBlPSJDRSI+DQoJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PkFDVElWRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQk8L2FjdD4NCgkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBBY3QgVGVtcGxhdGUgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNyIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBDODMgVGVtcGxhdGVzIGZvciBQcm9ibGVtIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjciIC8+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4yIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gQ0NEIFByb2JsZW0gQWN0IElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBWMi41IElIRSBQcm9ibGVtIENvbmNlcm4gVGVtcGxhdGVzIFJlcXVpcmVzIHN0YXR1c0NvZGUgLS0+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCTwhLS0gIDcuMDEgUFJPQkxFTSBEQVRFIChjZGE6bG93PURhdGUgb2YgT25zZXQsIGNkYTpoaWdoPURhdGUgUmVzb2x2ZWQpLCBPcHRpb25hbCBSMiAtLT4NCgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCSAgICA8IS0tIDcuMDUgVFJFQVRJTkcgUFJPVklERVIgaWQgbGluayB0byBIZWFsdGhDYXJlIFByb3ZpZGVyIEVudHJ5LS0+IA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSJwcm92aWRlcjciIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Fzc2lnbmVkRW50aXR5Pg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcGVyZm9ybWVyPg0KCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBQUk9CTEVNLCBPcHRpb25hbCAtLT4NCgkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUaW1lIGFzIG51bGxGbGF2b3IgYmVjYXVzZSBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI5OTIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJPG5hbWU+Q0hFWUVOTkUgSERSIFNRQTwvbmFtZT4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJmYWxzZSIgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCQkJCQk8IS0tIENDRCBQcm9ibGVtIG9ic2VydmF0aW9uIC0gUmVxdWlyZWQgLS0+DQoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQk8IS0tIFByb2JsZW0gb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgQzgzIFRlbXBsYXRlcyBmb3IgUHJvYmxlbSBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJCSAgICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJICAJPCEtLSBDQ0QgUHJvYmxlbSBPYnMgSUQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPCEtLSA3LjAyIFBST0JMRU0gVFlQRSwgUjIsIFNOT01FRCBDVCAgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgNy4wMiBQUk9CTEVNIFRZUEUsIE9wdGlvbmFsIFNOT01FRCBDVCwgcHJvdmlkZWQgYXMgbnVsbEZhbHZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB2aWEgVkEgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCTxjb2RlIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGNvZGVTeXN0ZW1OYW1lPSJTTk9NRUQgQ1QiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5Qcm9ibGVtIFR5cGUgTm90IEF2YWlsYWJsZTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCQkJPCEtLSA3LjAzIFBST0JMRU0gTkFNRSwgUkVRVUlSRUQgLS0+DQoJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcG5kUHJvYmxlbTciIC8+DQoJCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBJSEUgUHJvYmxlbSBUZW1wbGF0ZXMgUmVxdWlyZSBsb3cgdmFsdWUgZW50cnkgLS0+DQoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4gDQoJCQkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQk8IS0tICA3LjA0IFBST0JMRU0gQ09ERSwgT3B0aW9uYWwsIFdoZW4gdW5jb2RlZCBvbmx5IHhzaTp0eXBlPSJDRCIgYWxsb3dlZCwgQXZhaWxhYmxlIGFzIElDRC05LCBub3QgU05PTUVEIENULCAgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBJSEUgUHJvYmxlbSBUZW1wbGF0ZXMgUmVxdWlyZSB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiPg0KCQkJCQkJCQkJCTx0cmFuc2xhdGlvbiBjb2RlPSI0NDEuNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMDMiIGNvZGVTeXN0ZW1OYW1lPSJJQ0QtOS1DTSIgLz4NCgkJCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQkJCQk8IS0tICA3LjEyIFBST0JMRU0gU1RBVFVTIGVudHJ5UmVsYXRpb25zaGlwIGJsb2NrLCBPcHRpb25hbCwgLS0+DQoJCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KCQkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIENDRCBQcm9ibGVtIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MCIgLz4gDQoJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IlN0YXR1cyIgLz4NCgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQk8IS0tICBISVRTUCBDMzIgVjIuNTogNy4xMiBQUk9CTEVNIFNUQVRVUyAgT3B0aW9uYWwsIFRyYW5zbGF0ZWQgZnRvbSBWaXN0QSB2YWx1ZSAtLT4NCgkJCQkJCQkJCQkJPHZhbHVlIGNvZGU9IjU1NTYxMDAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQWN0aXZlIiB4c2k6dHlwZT0iQ0UiPg0KCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5BQ1RJVkU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJPC9hY3Q+DQoJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTwhLS0gQ0NEIFByb2JsZW0gQWN0IFRlbXBsYXRlIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjciIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgQzgzIFRlbXBsYXRlcyBmb3IgUHJvYmxlbSBNb2R1bGUvRW50cnkgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My43IiAvPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjEiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMiIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIENDRCBQcm9ibGVtIEFjdCBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgVjIuNSBJSEUgUHJvYmxlbSBDb25jZXJuIFRlbXBsYXRlcyBSZXF1aXJlcyBzdGF0dXNDb2RlIC0tPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQk8IS0tICA3LjAxIFBST0JMRU0gREFURSAoY2RhOmxvdz1EYXRlIG9mIE9uc2V0LCBjZGE6aGlnaD1EYXRlIFJlc29sdmVkKSwgT3B0aW9uYWwgUjIgLS0+DQoJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkgICAgPCEtLSA3LjA1IFRSRUFUSU5HIFBST1ZJREVSIGlkIGxpbmsgdG8gSGVhbHRoQ2FyZSBQcm92aWRlciBFbnRyeS0tPiANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0icHJvdmlkZXI4IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCgkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgUFJPQkxFTSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGltZSBhcyBudWxsRmxhdm9yIGJlY2F1c2UgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBvYnNlcnZhdGlvbiAtIFJlcXVpcmVkIC0tPg0KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJPCEtLSBQcm9ibGVtIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCQkgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCSAgCTwhLS0gQ0NEIFByb2JsZW0gT2JzIElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTwhLS0gNy4wMiBQUk9CTEVNIFRZUEUsIFIyLCBTTk9NRUQgQ1QgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDcuMDIgUFJPQkxFTSBUWVBFLCBPcHRpb25hbCBTTk9NRUQgQ1QsIHByb3ZpZGVkIGFzIG51bGxGYWx2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQk8Y29kZSBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+UHJvYmxlbSBUeXBlIE5vdCBBdmFpbGFibGU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCTwhLS0gNy4wMyBQUk9CTEVNIE5BTUUsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3BuZFByb2JsZW04IiAvPg0KCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgSUhFIFByb2JsZW0gVGVtcGxhdGVzIFJlcXVpcmUgbG93IHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+IA0KCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJPCEtLSAgNy4wNCBQUk9CTEVNIENPREUsIE9wdGlvbmFsLCBXaGVuIHVuY29kZWQgb25seSB4c2k6dHlwZT0iQ0QiIGFsbG93ZWQsIEF2YWlsYWJsZSBhcyBJQ0QtOSwgbm90IFNOT01FRCBDVCwgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBWMi41OiAgSUhFIFByb2JsZW0gVGVtcGxhdGVzIFJlcXVpcmUgdmFsdWUgZW50cnkgLS0+DQoJCQkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIj4NCgkJCQkJCQkJCQk8dHJhbnNsYXRpb24gY29kZT0iNzg2LjIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTAzIiBjb2RlU3lzdGVtTmFtZT0iSUNELTktQ00iIC8+DQoJCQkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJCQkJPCEtLSAgNy4xMiBQUk9CTEVNIFNUQVRVUyBlbnRyeVJlbGF0aW9uc2hpcCBibG9jaywgT3B0aW9uYWwsIC0tPg0KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCgkJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBDQ0QgUHJvYmxlbSBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTAiIC8+IA0KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiIC8+DQoJCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQkJPCEtLSAgSElUU1AgQzMyIFYyLjU6IDcuMTIgUFJPQkxFTSBTVEFUVVMgIE9wdGlvbmFsLCBUcmFuc2xhdGVkIGZ0b20gVmlzdEEgdmFsdWUgLS0+DQoJCQkJCQkJCQkJCTx2YWx1ZSBjb2RlPSI1NTU2MTAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFjdGl2ZSIgeHNpOnR5cGU9IkNFIj4NCgkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+QUNUSVZFPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCTwvYWN0Pg0KCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCQkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8IS0tIENDRCBQcm9ibGVtIEFjdCBUZW1wbGF0ZSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3IiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuNyIgLz4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4xIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41LjIiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBDQ0QgUHJvYmxlbSBBY3QgSUQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIFYyLjUgSUhFIFByb2JsZW0gQ29uY2VybiBUZW1wbGF0ZXMgUmVxdWlyZXMgc3RhdHVzQ29kZSAtLT4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJPCEtLSAgNy4wMSBQUk9CTEVNIERBVEUgKGNkYTpsb3c9RGF0ZSBvZiBPbnNldCwgY2RhOmhpZ2g9RGF0ZSBSZXNvbHZlZCksIE9wdGlvbmFsIFIyIC0tPg0KCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJICAgIDwhLS0gNy4wNSBUUkVBVElORyBQUk9WSURFUiBpZCBsaW5rIHRvIEhlYWx0aENhcmUgUHJvdmlkZXIgRW50cnktLT4gDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249InByb3ZpZGVyOSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXNzaWduZWRFbnRpdHk+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wZXJmb3JtZXI+DQoJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIFBST0JMRU0sIE9wdGlvbmFsIC0tPg0KCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRpbWUgYXMgbnVsbEZsYXZvciBiZWNhdXNlIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCTxpZCBleHRlbnNpb249Ijk5MiIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQk8bmFtZT5DSEVZRU5ORSBIRFIgU1FBPC9uYW1lPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9ImZhbHNlIiB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCTwhLS0gQ0NEIFByb2JsZW0gb2JzZXJ2YXRpb24gLSBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCTwhLS0gUHJvYmxlbSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBDODMgVGVtcGxhdGVzIGZvciBQcm9ibGVtIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQkJICAgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJCQkgIAk8IS0tIENDRCBQcm9ibGVtIE9icyBJRCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8IS0tIDcuMDIgUFJPQkxFTSBUWVBFLCBSMiwgU05PTUVEIENUICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICA3LjAyIFBST0JMRU0gVFlQRSwgT3B0aW9uYWwgU05PTUVEIENULCBwcm92aWRlZCBhcyBudWxsRmFsdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJPGNvZGUgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PlByb2JsZW0gVHlwZSBOb3QgQXZhaWxhYmxlPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQk8IS0tIDcuMDMgUFJPQkxFTSBOQU1FLCBSRVFVSVJFRCAtLT4NCgkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNwbmRQcm9ibGVtOSIgLz4NCgkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIGxvdyB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPiANCgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCTwhLS0gIDcuMDQgUFJPQkxFTSBDT0RFLCBPcHRpb25hbCwgV2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9IkNEIiBhbGxvd2VkLCBBdmFpbGFibGUgYXMgSUNELTksIG5vdCBTTk9NRUQgQ1QsICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCI+DQoJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjcxMC4zIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRC05LUNNIiAvPg0KCQkJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCQkJCTwhLS0gIDcuMTIgUFJPQkxFTSBTVEFUVVMgZW50cnlSZWxhdGlvbnNoaXAgYmxvY2ssIE9wdGlvbmFsLCAtLT4NCgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQ0NEIFByb2JsZW0gc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUwIiAvPiANCgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iU3RhdHVzIiAvPg0KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCTwhLS0gIEhJVFNQIEMzMiBWMi41OiA3LjEyIFBST0JMRU0gU1RBVFVTICBPcHRpb25hbCwgVHJhbnNsYXRlZCBmdG9tIFZpc3RBIHZhbHVlIC0tPg0KCQkJCQkJCQkJCQk8dmFsdWUgY29kZT0iNTU1NjEwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBY3RpdmUiIHhzaTp0eXBlPSJDRSI+DQoJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PkFDVElWRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQk8L2FjdD4NCgkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBBY3QgVGVtcGxhdGUgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNyIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIFYyLjU6ICBDODMgVGVtcGxhdGVzIGZvciBQcm9ibGVtIE1vZHVsZS9FbnRyeSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjciIC8+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUuMSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNS4yIiAvPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gQ0NEIFByb2JsZW0gQWN0IElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBWMi41IElIRSBQcm9ibGVtIENvbmNlcm4gVGVtcGxhdGVzIFJlcXVpcmVzIHN0YXR1c0NvZGUgLS0+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCTwhLS0gIDcuMDEgUFJPQkxFTSBEQVRFIChjZGE6bG93PURhdGUgb2YgT25zZXQsIGNkYTpoaWdoPURhdGUgUmVzb2x2ZWQpLCBPcHRpb25hbCBSMiAtLT4NCgkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCSAgICA8IS0tIDcuMDUgVFJFQVRJTkcgUFJPVklERVIgaWQgbGluayB0byBIZWFsdGhDYXJlIFByb3ZpZGVyIEVudHJ5LS0+IA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSJwcm92aWRlcjEwIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc3NpZ25lZEVudGl0eT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3BlcmZvcm1lcj4NCgkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgUFJPQkxFTSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGltZSBhcyBudWxsRmxhdm9yIGJlY2F1c2UgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iOTkyIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIEhEUiBTUUE8L25hbWU+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJPCEtLSBDQ0QgUHJvYmxlbSBvYnNlcnZhdGlvbiAtIFJlcXVpcmVkIC0tPg0KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJPCEtLSBQcm9ibGVtIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIEM4MyBUZW1wbGF0ZXMgZm9yIFByb2JsZW0gTW9kdWxlL0VudHJ5IC0tPg0KCQkJCQkJCQkgICAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCSAgCTwhLS0gQ0NEIFByb2JsZW0gT2JzIElEIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTwhLS0gNy4wMiBQUk9CTEVNIFRZUEUsIFIyLCBTTk9NRUQgQ1QgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDcuMDIgUFJPQkxFTSBUWVBFLCBPcHRpb25hbCBTTk9NRUQgQ1QsIHByb3ZpZGVkIGFzIG51bGxGYWx2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQk8Y29kZSBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBjb2RlU3lzdGVtTmFtZT0iU05PTUVEIENUIiBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+UHJvYmxlbSBUeXBlIE5vdCBBdmFpbGFibGU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCTwhLS0gNy4wMyBQUk9CTEVNIE5BTUUsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3BuZFByb2JsZW0xMCIgLz4NCgkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIGxvdyB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPiANCgkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCTwhLS0gIDcuMDQgUFJPQkxFTSBDT0RFLCBPcHRpb25hbCwgV2hlbiB1bmNvZGVkIG9ubHkgeHNpOnR5cGU9IkNEIiBhbGxvd2VkLCBBdmFpbGFibGUgYXMgSUNELTksIG5vdCBTTk9NRUQgQ1QsICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgVjIuNTogIElIRSBQcm9ibGVtIFRlbXBsYXRlcyBSZXF1aXJlIHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCI+DQoJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjQwMS45IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEwMyIgY29kZVN5c3RlbU5hbWU9IklDRC05LUNNIiAvPg0KCQkJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCQkJCTwhLS0gIDcuMTIgUFJPQkxFTSBTVEFUVVMgZW50cnlSZWxhdGlvbnNoaXAgYmxvY2ssIE9wdGlvbmFsLCAtLT4NCgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQ0NEIFByb2JsZW0gc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUwIiAvPiANCgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iU3RhdHVzIiAvPg0KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCTwhLS0gIEhJVFNQIEMzMiBWMi41OiA3LjEyIFBST0JMRU0gU1RBVFVTICBPcHRpb25hbCwgVHJhbnNsYXRlZCBmdG9tIFZpc3RBIHZhbHVlIC0tPg0KCQkJCQkJCQkJCQk8dmFsdWUgY29kZT0iNTU1NjEwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBY3RpdmUiIHhzaTp0eXBlPSJDRSI+DQoJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PkFDVElWRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQk8L2FjdD4NCgkJCQkJPC9lbnRyeT4NCiAgICAgICAgICAgICAgICA8L3NlY3Rpb24+DQoJCQk8L2NvbXBvbmVudD4NCiAJCQk8IS0tIA0KCQkJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgkJCU1FRElDQVRJT05TIChSWCAmIE5vbi1SWCkgIFNFQ1RJT04NCgkJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJCQktLT4NCgkJCQ0KCQkJPCEtLSANCgkJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJCQlWTEVSIFNFRyAxQjogIFZJVEFMIFNJR05TIFNFQ1RJT04NCgkJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJCQktLT4NCgkJCTxjb21wb25lbnQ+IDwhLS0gQ29tcG9uZW50IDQgLS0+DQoJCQkJPHNlY3Rpb24+DQoJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBITDcgQ0NEIFZpdGFsIHNpZ25zIHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTYiIC8+IA0KCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSElUU1AgQ0RBIFZpdGFsIFNpZ25zIFNlY3Rpb24gVGVtcGxhdGUgLS0+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTE5IiAvPiANCgkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBDb2RlZCBWaXRhbCBTaWducyBTZWN0aW9uIFRlbXBsYXRlcyAtLT4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS4zLjI1IiAvPiANCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS4xLjUuMy4yIiAvPiANCgkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEhMNyBDQ0QgODcxNi0zIExPSU5DIENvZGUgZm9yIFBoeXNpY2FsIEZpbmRpbmdzL1ZpdGFsIFNpZ25zIC0tPg0KCQkJCQk8Y29kZSBjb2RlPSI4NzE2LTMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IlZJVEFMIFNJR05TIiAvPg0KCQkJCQk8dGl0bGU+Vml0YWwgU2lnbnM8L3RpdGxlPg0KCQkJCQk8IS0tICBWSVRBTCBTSUdOUyBOQVJSQVRJVkUgQkxPQ0sgLCBSRVFVSVJFRCAtLT4NCgkJCQkJPHRleHQ+DQoJCQkJCSA8IS0tIFZMRVIgU0VHIDFCOiBWaXRhbCBTaWducyBCdXNpbmVzcyBSdWxlcyBmb3IgTWVkaWNhbCBDb250ZW50ICAtLT4NCgkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCQkJCQk8dGhlYWQ+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0aD5EZXBhcnRtZW50IG9mIFZldGVyYW5zIEFmZmFpcnM8L3RoPg0KCQkJCQkJCQkJPHRoPkJ1c2luZXNzIFJ1bGVzIGZvciBDb25zdHJ1Y3Rpb24gb2YgTWVkaWNhbCBJbmZvcm1hdGlvbjwvdGg+DQoJCQkJCQkJCTwvdHI+DQoJCQkJCQkJPC90aGVhZD4NCgkJCQkJCQk8dGJvZHk+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0ZD5WaXRhbCBTaWduczwvdGQ+DQoJCQkJCQkJCQk8dGQ+VGhpcyBzZWN0aW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGZyb20gdGhlIHRlbiBtb3N0IHJlY2VudCBwYXRpZW50IHZpdGFsIHNpZ25zIChpbnBhdGllbnQgYW5kIG91dHBhdGllbnQpIGZyb20gYWxsIFZBIHRyZWF0bWVudCBmYWNpbGl0aWVzIGZvciB3aGljaCB0aGUgcGFuZWwgZGF0ZSB0YWtlbiB3YXMgd2l0aGluIHRoZSBsYXN0IDEyIG1vbnRocy4gTm90ZTogSWYgbW9yZSB0aGFuIG9uZSBwYW5lbCB3YXMgdGFrZW4gb24gdGhlIHNhbWUgZGF0ZSwgb25seSB0aGUgbW9zdCByZWNlbnQgcGFuZWwgaXMgcG9wdWxhdGVkIGZvciB0aGF0IGRhdGUuPC90ZD4NCgkJCQkJCQkJPC90cj4NCgkJCQkJCQk8L3Rib2R5Pg0KCQkJCQkJPC90YWJsZT4NCgkJCQkJCTx0YWJsZSBJRD0idml0YWxOYXJyaXRpdmUiIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJCQkJCTx0aGVhZD4NCgkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJPHRoPkRhdGU8L3RoPg0KCQkJCQkJCQkJPHRoPk1lYXN1cmVtZW50czwvdGg+DQoJCQkJCQkJCQk8dGg+U291cmNlPC90aD4NCgkJCQkJCQkJPC90cj4NCgkJCQkJCQk8L3RoZWFkPg0KCQkJCQkJCTx0Ym9keT4NCgkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJ2bmREYXRlMSI+MjAxMjA1MTUxMzIwNTQ8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxsaXN0Pg0KCQkJCQkJCQkJCQk8aXRlbT4NCgkJCQkJCQkJCQkJCTxjb250ZW50IElEPSJ2bmRNZWFzdXJlbWVudDEtMSI+SGVhcnQgcmF0ZTogODUvbWluPC9jb250ZW50Pg0KCQkJCQkJCQkJCQk8L2l0ZW0+PGl0ZW0+DQoJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0idm5kTWVhc3VyZW1lbnQxLTIiPkJvZHkgdGVtcGVyYXR1cmU6IDk5W2RlZ0ZdPC9jb250ZW50Pg0KCQkJCQkJCQkJCQk8L2l0ZW0+DQoJCQkJCQkJCQkJPC9saXN0Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0idm5kU291cmNlMSI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+DQoJCQkJCQkJPC90Ym9keT4NCgkJCQkJCTwvdGFibGU+DQoJCQkJCQkJPCEtLSAgQ0RBIE9ic2VydmF0aW9uIFRleHQgYXMgYSBSZWZlcmVuY2UgdGFnIC0tPg0KCQkJCQkJCTxjb250ZW50IElEPSJ2aXRhbDEiIHJldmlzZWQ9ImRlbGV0ZSI+Vml0YWwgU2lnbiBPYnNlcnZhdGlvbiBUZXh0IE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+DQoJCQkJCTwvdGV4dD4gICAgICAgICAgDQoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+IDwhLS0gUmVwZWF0IEVudHJ5L09yZ2FuaXplciBibG9jayBmb3IgZWFjaCB2aXRhbCBzaWduIHBhbmVsIC0tPg0KCQkJCQkJPG9yZ2FuaXplciBjbGFzc0NvZGU9IkNMVVNURVIiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBBU1RNL0hMNyBDQ0QgU3BlY2lmaWNhdGlvbiBmb3IgVml0YWwgU2lnbnMsIE9yZ2FuaXplciBwYXJlbnQgdGVtcGxhdGVzIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzIiIC8+IA0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzUiIC8+IA0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBWaXRhbCBTaWducyBPcmdhbml6ZXIgVGVtcGxhdGUsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xMy4xIiAvPiANCgkJCQkJCQk8IS0tIFZpdGFsIFNpZ24gT3JnYW5pemVyIElEIGFzIG51bGxGbGF2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8Y29kZSBjb2RlPSI0NjY4MDAwNSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgY29kZVN5c3RlbU5hbWU9IlNOT01FRCBDVCIgZGlzcGxheU5hbWU9IlZpdGFsIHNpZ25zIiAvPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQWxsIFZpdGFsIFNpZ25zIFJlY29yZGVkIG9uIHRoaXMgZGF0ZSB3aWxsIGJlIGdyb3VwZWQgdW5kZXIgdGhlIG9ic2VydmF0aW9uIGJsb2NrIC0tPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IGlmIGJsYW5rLCB0aGVuIGVmZmVjdGl2ZVRpbWUgbnVsbEZsYXZvcj0iVU5LIiAtLT4NCgkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAxMjA1MTUxMzIwNTQiIC8+DQoJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIFZJVEFMIFNJR04gT1JHQU5JWkVSL1BBTkVMLCBPcHRpb25hbCAtLT4NCgkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEM4MyBhdXRob3IvYXNzaWduZWRQZXJzb24vTmFtZSAgUmVxdWlyZWQgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE9JRCAoSUQgPSBWQSBPSUQsIEVYVCA9IFRSRUFUSU5HIEZBQ0lMSVRZIE5CUikgLS0+DQoJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIE9uZSBjb21wb25lbnQgYmxvY2sgZm9yIGVhY2ggVml0YWwgU2lnbiAtLT4NCgkJCQkJCQk8Y29tcG9uZW50PiA8IS0tIFJlcGVhdCBDb21wb25lbnQvT3JnYW5pemVyIGJsb2NrIGZvciBlYWNoIHZpdGFsIHNpZ24gaW4gdGhlIHBhbmVsIC0tPg0KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJIDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zMSIgLz4gDQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgVml0YWwgU2lnbiBNb2R1bGUvRW50cnkgVGVtcGxhdGVzIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNCIgLz4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xMy4yIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEFTVE0vSEw3IENDRCBTcGVjaWZpY2F0aW9uIGZvciBWaXRhbCBTaWducywgcGFyZW50IHRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzEiIC8+IA0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjEzIiAvPiANCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNC4wMS1WSVRBTCBTSUdOIFJFU1VMVCBJRCwgUkVRVUlSRUQgIC0tPg0KCQkJCQkJCQkJPCEtLSAxNC4wMS1WSVRBTCBTSUdOIFJFU1VMVCBJRCAgLS0+DQoJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI3MDAyMDM0IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNC4wMy1WSVRBTCBTSUdOIFJFU1VMVCBUWVBFLCBSRVFVSVJFRCwgTE9JTkMgIC0tPg0KCQkJCQkJCQkJPGNvZGUgY29kZT0iODg2Ny00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJIZWFydCByYXRlIj4NCgkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PlBVTFNFPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJPHRyYW5zbGF0aW9uIGNvZGU9IjQ1MDA2MzYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMjMzIiBjb2RlU3lzdGVtTmFtZT0iVkhBIEVudGVycHJpc2UgUmVmZXJlbmNlIFRlcm1pbm9sb2d5IiBkaXNwbGF5TmFtZT0iUFVMU0UiIC8+DQoJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQk8IS0tIENEQSBiYXNlZCB1c2VzIG9mIFNpbXBsZSBPYnNlcnZhdGlvbnMgVGV4dCBlbGVtZW50IFJlcXVpcmVkIC0tPg0KCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3ZpdGFsMSIgLz4NCgkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNC4wNC1WSVRBTCBTSUdOIFJFU1VMVCBTVEFUVVMsIFJFUVVJUkVELCBTdGF0aWMgdmFsdWUgb2YgY29tcGxldGVkICAtLT4NCgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNC4wMi1WSVRBTCBTSUdOIFJFU1VMVCBEQVRFL1RJTUUsIFJFUVVSSUVEICAtLT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IGlmIGJsYW5rLCB0aGVuIGVmZmVjdGl2ZVRpbWUgbnVsbEZsYXZvcj0iVU5LIiAtLT4NCgkJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDEyMDUxNTEzMjQzMiIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNC4wNS1WSVRBTCBTSUdOIFJFU1VMVCBWQUxVRSwgQ09ORElUSU9OQUwgUkVRVUlSRUQgd2hlbiBtb29kQ29kZT1FVk4gIC0tPg0KCQkJCQkJCQkJPCEtLSAxNC4wNS1WSVRBTCBTSUdOIFJFU1VMVCBWQUxVRSB3aXRoIFVuaXQgb2YgTWVhc3VyZSAtLT4NCgkJCQkJCQkJCTx2YWx1ZSB1bml0PSIvbWluIiB2YWx1ZT0iODUiIHhzaTp0eXBlPSJQUSIgLz4NCgkJCQkJCQkJCTwhLS0gMTQuMDUtVklUQUwgU0lHTiBSRVNVTFQgVkFMVUUgd2hlbiBVbml0IG9mIE1lYXN1cmUgaXMgYmxhbmsgdGhlbiBvbWl0IHVuaXQgYXR0cmlidXRlLS0+DQoJCQkJCQkJCQk8IS0tIHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IiIgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTQuMDYtVklUQUwgU0lHTiBSRVNVTFQgSU5URVJQUkVUQVRJT04sIE9wdGlvbmFsLCBITDcgUmVzdWx0IE5vcm1hbGN5IFN0YXR1cyBWYWx1ZSBTZXQgLS0+DQoJCQkJCQkJCQk8IS0tICBISVRTUCBDMzIgVjIuNTogIDE0LjA2LVZJVEFMIFNJR04gUkVTVUxUIElOVEVSUFJFVEFUSU9OLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNC4wNy1WSVRBTCBTSUdOIFJFU1VMVCBSRUZFUkVOQ0UgUkFOR0UsIE9wdGlvbmFsLCAtLT4NCgkJCQkJCQkJCQk8IS0tICAgSElUU1AgQzMyIFYyLjU6ICAxNC4wNy1WSVRBTCBTSUdOIFJFU1VMVCBSRUZFUkVOQ0UgUkFOR0UsIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJPC9jb21wb25lbnQ+PGNvbXBvbmVudD4gPCEtLSBSZXBlYXQgQ29tcG9uZW50L09yZ2FuaXplciBibG9jayBmb3IgZWFjaCB2aXRhbCBzaWduIGluIHRoZSBwYW5lbCAtLT4NCgkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCSA8IS0tIFJlc3VsdCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzEiIC8+IA0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFZpdGFsIFNpZ24gTW9kdWxlL0VudHJ5IFRlbXBsYXRlcyAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTQiIC8+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMTMuMiIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBBU1RNL0hMNyBDQ0QgU3BlY2lmaWNhdGlvbiBmb3IgVml0YWwgU2lnbnMsIHBhcmVudCB0ZW1wbGF0ZXMgLS0+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIiAvPiANCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xMyIgLz4gDQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTQuMDEtVklUQUwgU0lHTiBSRVNVTFQgSUQsIFJFUVVJUkVEICAtLT4NCgkJCQkJCQkJCTwhLS0gMTQuMDEtVklUQUwgU0lHTiBSRVNVTFQgSUQgIC0tPg0KCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNzAwMjAzMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTQuMDMtVklUQUwgU0lHTiBSRVNVTFQgVFlQRSwgUkVRVUlSRUQsIExPSU5DICAtLT4NCgkJCQkJCQkJCTxjb2RlIGNvZGU9IjgzMTAtNSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iQm9keSB0ZW1wZXJhdHVyZSI+DQoJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5URU1QRVJBVFVSRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCTx0cmFuc2xhdGlvbiBjb2RlPSI0NTAwNjM4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjIzMyIgY29kZVN5c3RlbU5hbWU9IlZIQSBFbnRlcnByaXNlIFJlZmVyZW5jZSBUZXJtaW5vbG9neSIgZGlzcGxheU5hbWU9IlRFTVBFUkFUVVJFIiAvPg0KCQkJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCQkJPCEtLSBDREEgYmFzZWQgdXNlcyBvZiBTaW1wbGUgT2JzZXJ2YXRpb25zIFRleHQgZWxlbWVudCBSZXF1aXJlZCAtLT4NCgkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiN2aXRhbDEiIC8+DQoJCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTQuMDQtVklUQUwgU0lHTiBSRVNVTFQgU1RBVFVTLCBSRVFVSVJFRCwgU3RhdGljIHZhbHVlIG9mIGNvbXBsZXRlZCAgLS0+DQoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTQuMDItVklUQUwgU0lHTiBSRVNVTFQgREFURS9USU1FLCBSRVFVUklFRCAgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBpZiBibGFuaywgdGhlbiBlZmZlY3RpdmVUaW1lIG51bGxGbGF2b3I9IlVOSyIgLS0+DQoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAxMjA1MTUxMzI0MzIiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTQuMDUtVklUQUwgU0lHTiBSRVNVTFQgVkFMVUUsIENPTkRJVElPTkFMIFJFUVVJUkVEIHdoZW4gbW9vZENvZGU9RVZOICAtLT4NCgkJCQkJCQkJCTwhLS0gMTQuMDUtVklUQUwgU0lHTiBSRVNVTFQgVkFMVUUgd2l0aCBVbml0IG9mIE1lYXN1cmUgLS0+DQoJCQkJCQkJCQk8dmFsdWUgdW5pdD0iW2RlZ0ZdIiB2YWx1ZT0iOTkiIHhzaTp0eXBlPSJQUSIgLz4NCgkJCQkJCQkJCTwhLS0gMTQuMDUtVklUQUwgU0lHTiBSRVNVTFQgVkFMVUUgd2hlbiBVbml0IG9mIE1lYXN1cmUgaXMgYmxhbmsgdGhlbiBvbWl0IHVuaXQgYXR0cmlidXRlLS0+DQoJCQkJCQkJCQk8IS0tIHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IiIgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTQuMDYtVklUQUwgU0lHTiBSRVNVTFQgSU5URVJQUkVUQVRJT04sIE9wdGlvbmFsLCBITDcgUmVzdWx0IE5vcm1hbGN5IFN0YXR1cyBWYWx1ZSBTZXQgLS0+DQoJCQkJCQkJCQk8IS0tICBISVRTUCBDMzIgVjIuNTogIDE0LjA2LVZJVEFMIFNJR04gUkVTVUxUIElOVEVSUFJFVEFUSU9OLCBSZW1vdmVkIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHZpYSBWQSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNC4wNy1WSVRBTCBTSUdOIFJFU1VMVCBSRUZFUkVOQ0UgUkFOR0UsIE9wdGlvbmFsLCAtLT4NCgkJCQkJCQkJCQk8IS0tICAgSElUU1AgQzMyIFYyLjU6ICAxNC4wNy1WSVRBTCBTSUdOIFJFU1VMVCBSRUZFUkVOQ0UgUkFOR0UsIFJlbW92ZWQgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdmlhIFZBIFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJPC9jb21wb25lbnQ+DQoJCQkJCQk8L29yZ2FuaXplcj4NCgkJCQkJPC9lbnRyeT4NCgkJCQk8L3NlY3Rpb24+DQoJCQk8L2NvbXBvbmVudD4NCiAgICAgICAgICAgIDwhLS0gDQoJCQkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCQkJVkxFUiBTRUcgMUI6ICBMQUIgUkVTVUxUUyBTRUNUSU9OIChDaGVtaXN0cnkvSGVtYXRvbG9neSkNCgkJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJCQktLT4NCgkJCTxjb21wb25lbnQ+IA0KCQkJCTxzZWN0aW9uPjwhLS0gQ29tcG9uZW50IDUgLS0+DQoJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBITDcgQ0NEIExhYiBSZXN1bHRzIHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTQiIC8+IA0KCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSElUU1AgQ0RBIERpYWduaW9zdGljIFJlc3VsdHMgU2VjdGlvbiBUZW1wbGF0ZSAtLT4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xMjIiIC8+IA0KCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSUhFIENvZGVkIFJlc3VsdHMgU2VjdGlvbiBUZW1wbGF0ZXMgLS0+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuMy4yOCIgLz4gDQoJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBITDcgQ0NEIDMwOTU0LTIgTE9JTkMgQ29kZSAoUmVxdWlyZWQpIGZvciBEaWFnbm9zdGljIHRlc3RzIGFuZC9vciBMYWJvcmF0b3J5IERhdGEgLS0+DQoJCQkJCTxjb2RlIGNvZGU9IjMwOTU0LTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBkaXNwbGF5TmFtZT0iUmVsZXZhbnQgZGlhZ25vc3RpYyB0ZXN0cyBhbmQvb3IgbGFib3JhdG9yeSBkYXRhIiAvPg0KCQkJCQk8dGl0bGU+TGFiIFJlc3VsdHMgLSBDaGVtaXN0cnkgYW5kIEhlbWF0b2xvZ3k8L3RpdGxlPg0KCQkJCQk8IS0tICBMQUIgUkVTVUxUUyAgTkFSUkFUSVZFIEJMT0NLICwgUkVRVUlSRUQgLS0+DQoJCQkJCTx0ZXh0Pg0KCQkJCQkJCSA8IS0tIFZMRVIgU0VHIDFCOiBMYWIgUmVzdWx0cyBCdXNpbmVzcyBSdWxlcyBmb3IgTWVkaWNhbCBDb250ZW50ICAtLT4NCgkJCQkJCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+DQoJCQkJCQkJCTx0aGVhZD4NCgkJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCQk8dGg+RGVwYXJ0bWVudCBvZiBWZXRlcmFucyBBZmZhaXJzPC90aD4NCgkJCQkJCQkJCQk8dGg+QnVzaW5lc3MgUnVsZXMgZm9yIENvbnN0cnVjdGlvbiBvZiBNZWRpY2FsIEluZm9ybWF0aW9uPC90aD4NCgkJCQkJCQkJCTwvdHI+DQoJCQkJCQkJCTwvdGhlYWQ+DQoJCQkJCQkJCTx0Ym9keT4NCgkJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCQk8dGQ+TGFiIFJlc3VsdHM8L3RkPg0KCQkJCQkJCQkJCTx0ZD5UaGlzIHNlY3Rpb24gY29udGFpbnMgdGhlIGZpdmUgbW9zdCByZWNlbnQgcGF0aWVudCBDaGVtaXN0cnkgYW5kIEhlbWF0b2xvZ3kgbGFiIHJlc3VsdHMgZnJvbSBhbGwgVkEgdHJlYXRtZW50IGZhY2lsaXRpZXMgZm9yIHdoaWNoIHRoZSByZXN1bHQgZGF0ZSB3YXMgd2l0aGluIHRoZSBsYXN0IDEyIG1vbnRocy48L3RkPg0KCQkJCQkJCQkJPC90cj4NCgkJCQkJCQkJPC90Ym9keT4NCgkJCQkJCQk8L3RhYmxlPg0KCQkJCQkJCTx0YWJsZSBJRD0ibGFiTmFycml0aXZlIiBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCQkJCQkJPHRoZWFkPg0KCQkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJCTx0aD5EYXRlL1RpbWU8L3RoPg0KCQkJCQkJCQkJCTx0aD5SZXN1bHQgVHlwZTwvdGg+DQoJCQkJCQkJCQkJPHRoPlNvdXJjZTwvdGg+DQoJCQkJCQkJCQkJPHRoPlJlc3VsdCAtIFVuaXQ8L3RoPg0KCQkJCQkJCQkJCTx0aD5JbnRlcnByZXRhdGlvbjwvdGg+DQoJCQkJCQkJCQkJPHRoPlJlZmVyZW5jZSBSYW5nZTwvdGg+DQoJCQkJCQkJCQkJPHRoPlN0YXR1czwvdGg+DQoJCQkJCQkJCQkJPHRoPkNvbW1lbnQ8L3RoPg0KCQkJCQkJCQkJPC90cj4NCgkJCQkJCQkJPC90aGVhZD4NCgkJCQkJCQkJPHRib2R5Pg0KCQkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImxuZERhdGVUaW1lMSI+MjAxMjEyMDYwOTwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImxuZFJlc3VsdFR5cGUxIj5HTFVDT1NFPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0ibG5kU291cmNlMSI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgLz4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgLz4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgLz4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImxuZFN0YXR1czEiPmNvbXBsZXRlZDwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImxuZENvbW1lbnQxIj5+Rm9yIFRlc3Q6IEdMVUNPU0UgfkdsdWNvc2UgZm9yIHRlc3RpbmcgT3JkZXJpbmcgUHJvdmlkZXI6IFJpY2hhcmQgQyBSb3RlbGxhIE1EIFJlcG9ydCBSZWxlYXNlZCBEYXRlL1RpbWU6IERlYyAwNiwgMjAxMkAxODozMw0KIFBlcmZvcm1pbmcgTGFiOiBNQVJUSU5TQlVSRyBWQU1DDQogICAgICAgICAgICAgICAgNTEwIEJVVExFUiBBVkVOVUUgTk8gU0VDT05EIFNUUkVFVCBERVNJR05BVElPTiBNQVJUSU5TQlVSRywgV1YgMjU0MDENCiA8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQ+MjAxMjEyMDYwOTwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImxuZFJlc3VsdFR5cGUxLTEiPkdMVUNPU0U8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50Pk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJsbmRSZXN1bHRVbml0MS0xIj4xNTUgTUcvREw8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJsbmRJbnRlcnByZXRhdGlvbjEtMSI+SDwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImxuZFJlZmVyZW5jZVJhbmdlMS0xIj43NC0xMTg8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50PmNvbXBsZXRlZDwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQ+fkZvciBUZXN0OiBHTFVDT1NFIH5HbHVjb3NlIGZvciB0ZXN0aW5nIE9yZGVyaW5nIFByb3ZpZGVyOiBSaWNoYXJkIEMgUm90ZWxsYSBNRCBSZXBvcnQgUmVsZWFzZWQgRGF0ZS9UaW1lOiBEZWMgMDYsIDIwMTJAMTg6MzMNCiBQZXJmb3JtaW5nIExhYjogTUFSVElOU0JVUkcgVkFNQw0KICAgICAgICAgICAgICAgIDUxMCBCVVRMRVIgQVZFTlVFIE5PIFNFQ09ORCBTVFJFRVQgREVTSUdOQVRJT04gTUFSVElOU0JVUkcsIFdWIDI1NDAxDQogPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8L3RyPg0KCQkJCQkJCQk8L3Rib2R5Pg0KCQkJCQkJCTwvdGFibGU+DQoJCQkJCQkJPCEtLSAgQ0RBIE9ic2VydmF0aW9uIFRleHQgYXMgYSBSZWZlcmVuY2UgdGFnIC0tPg0KCQkJCQkJCTwhLS0gSUhFIFNpbXBsZSBPYnNlcnZhdGlvbnMgVGV4dCBFbGVtZW50IFJlcXVpcmVkLCBGb3IgMTUuMDMtTEFCIFJFU1VMVCBUWVBFICBTdGF0aWMgIk9ic2VydmF0aW9uIFRleHQgTm90IEF2YWlsYWJsZSIgLS0+DQoJCQkJCQkJPGNvbnRlbnQgSUQ9ImxhYi0xIiByZXZpc2VkPSJkZWxldGUiPlJlc3VsdCBPYnNlcnZhdGlvbiBUZXh0IE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+CQ0KCQkJCQkJCTwhLS0gSUhFIFByb2NlZHVyZSBUZXh0IEVsZW1lbnQgUmVxdWlyZWQsICBTdGF0aWMgIlByb2NlZHVyZSBUZXh0IE5vdCBBdmFpbGFibGUiIC0tPgkNCgkJCQkJCQk8Y29udGVudCBJRD0ibGFicHJvYzEiIHJldmlzZWQ9ImRlbGV0ZSI+UmVzdWx0IFByb2NlZHVyZSBUZXh0IE5vdCBBdmFpbGFibGU8L2NvbnRlbnQ+CQkNCgkJCQkJPC90ZXh0Pg0KCQkJCQk8ZW50cnk+IDwhLS0gRG8gTm90IFJlcGVhdCBwZXIgUmVzdWx0ICAtLT4NCgkJCQkJCQk8IS0tIFJlcXVpcmVkIElIRSBQcm9jZWR1cmUgRW50cnkgZWxlbWVudCwgUkVRVUlSRUQgLS0+DQoJCQkJCQkJPCEtLSBISVRTUCAzMiBWMi41OiAgSUhFIFByb2NldXJlIEVsZW1lbnQgUmVxdWlyZWQsIGJ1dCBkYXRhIG5vdCBhdmFpbGFibGUgdGhyb3VnaCBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCTxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4JICAgIA0KCQkJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIGFzc2lnbmluZ0F1dGhvcml0eU5hbWU9IkhJVFNQIEM4MyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNyIgLz4NCgkJCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCBhc3NpZ25pbmdBdXRob3JpdHlOYW1lPSJDQ0QiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjkiIC8+DQoJCQkJCQkJCQkJCQkJPHRlbXBsYXRlSWQgYXNzaWduaW5nQXV0aG9yaXR5TmFtZT0iSUhFIFBDQyIgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjE5IiAvPg0KCQkJCQkJCQkgIDxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCSAgPGNvZGUgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjbGFicHJvYzEiIC8+DQoJCQkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCSAgPC9jb2RlPg0KCQkJCQkJCQkgIDx0ZXh0Pg0KCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNsYWJwcm9jMSIgLz4NCgkJCQkJCQkJICA8L3RleHQ+DQoJCQkJCQkJCSAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCTwvcHJvY2VkdXJlPg0KCQkJCQk8L2VudHJ5Pg0KCQkJCQk8IS0tIFJlcXVpcmVkIElIRSBTaW1wbGUgT2JlcnNlcnZhdGlvbiBFbnRyeSBlbGVtZW50IC0tPg0KCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPiANCgkJCQkJCTwhLS0gVkxFUiAxQmlpOiAgTGFiIFJlc3VsdCBPcmdhbml6ZXIsIFJlYXBlYXRzIGZvciBFYWNoIFZBIE9yZGVyIC0tPg0KCQkJCQkJPG9yZ2FuaXplciBjbGFzc0NvZGU9IkJBVFRFUlkiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTwhLS0gSEw3IENDRCBMYWIgUmVzdWx0IE9yZ2FuaXplciBUZW1wbGF0ZSwgUmVxdWlyZWQgIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzIiIC8+DQoJCQkJCQkJPCEtLSBMYWIgUmVzdWx0IE9yZ2FuaXplciBJZCAtLT4NCgkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTM7MTUxOTQ4MTszMTIxMjA2OzE7MSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJPCEtLSBMYWIgUmVzdWx0IE9yZ2FuaXplciBDb2RlLS0+DQoJCQkJCQkJPGNvZGUgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJPG9yaWdpbmFsVGV4dD5HTFVDT1NFPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCTwhLS0gTGFiIFJlc3VsdCBPcmdhbml6ZXIgU3RhdHVzLCBzdGF0aWMtLT4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJPCEtLSBMYWIgUmVzdWx0IE9yZ2FuaXplciAgRGF0ZS9UaW1lLS0+DQoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTIxMjA2MDkiIC8+IDwhLS1Db2xsZWN0ZWQgRGF0ZS9UaW1lIC0tPg0KCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBMQUIgUkVTVUxUIE9SR0FOSVpFUiwgT3B0aW9uYWwgLS0+CQ0KCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQzgzIGF1dGhvci9hc3NpZ25lZFBlcnNvbi9OYW1lICBSZXF1aXJlZCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBPSUQgKElEID0gVkEgT0lELCBFWFQgPSBUUkVBVElORyBGQUNJTElUWSBOQlIpIC0tPg0KCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCTxjb21wb25lbnQ+IDwhLS0gQ29tcG9uZW50IFJlcGVhdHMgZm9yIEVhY2ggVkEgVGVzdCBSZXN1bHQgLS0+DQoJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkgPCEtLSBSZXN1bHQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIiAvPiANCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTUiIC8+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjE1LjEiIC8+DQoJCQkJCQkJCQk8IS0tIElIRSBTaW1wbGUgT2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMTMiIC8+DQoJCQkJCQkJCQk8IS0tICBISVRTUCBDMzIgVjIuNTogIDE1LjAxLUxBQiBSRVNVTFQgSUQsIFJFUVVJUkVEICAtLT4NCgkJCQkJCQkJCTwhLS0gMTUuMDEtTEFCIFJFU1VMVCBJRCAgLS0+DQoJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSJDSDs2ODc4NzkyLjkxOzYwMSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTUuMDMtTEFCIFJFU1VMVCBUWVBFLCBSRVFVSVJFRCwgTE9JTkMgIC0tPg0KCQkJCQkJCQkJPCEtLSAxNS4wMy1MQUIgUkVTVUxUIFRZUEUsICBBZGFwdGVyIG11c3Qgb2J0YWluIExPSU5DIENvZGUgTG9uZyBDb21tb24gTmFtZSBmcm9tIExPSU5DIERCICAtLT4NCgkJCQkJCQkJCTxjb2RlIGNvZGU9IlVOSyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiPg0KCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+R0xVQ09TRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCQkJPCEtLSBJSEUgU2ltcGxlIE9ic2VydmF0aW9ucyBUZXh0IGVsZW1lbnQgUmVxdWlyZWQgLS0+DQoJCQkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjbGFiLTEiIC8+DQoJCQkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTUuMDQtUkVTVUxUIFNUQVRVUywgUkVRVUlSRUQsIElIRSBSZXF1aXJlcyBTdGF0aWMgdmFsdWUgb2YgY29tcGxldGVkICAtLT4NCgkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNS4wMi1SRVNVTFQgREFURS9USU1FLCBSRVFVUklFRCAgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBpZiBibGFuaywgdGhlbiBlZmZlY3RpdmVUaW1lIG51bGxGbGF2b3I9IlVOSyIgLS0+DQoJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAxMjEyMDYwOSIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNS4wNS0gUkVTVUxUIFZBTFVFLCBDT05ESVRJT05BTCBSRVFVSVJFRCB3aGVuIG1vb2RDb2RlPUVWTiAgLS0+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTUuMDUtIFJFU1VMVCBWQUxVRSwgU2VudCBhcyBTdHJpbmcgKG5vdCBJTlQpIGZvciBWaXN0QSByZXN1bHRzIHRoYXQgYXJlIFBPUywgTkVHLCBwZW5kaW5nIC0tPg0KCQkJCQkJCQkJPHZhbHVlIHJlcHJlc2VudGF0aW9uPSJUWFQiIHhzaTp0eXBlPSJTVCI+MTU1IE1HL0RMPC92YWx1ZT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAxNS4wNi1SRVNVTFQgSU5URVJQUkVUQVRJT04sIE9wdGlvbmFsLCBUcmFuc2xhdGlvbiB0byBITDcgUmVzdWx0IE5vcm1hbGN5IFN0YXR1cyBWYWx1ZSBTZXQgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8IS0tIElmIDE1LjA2LVJFU1VMVCBJTlRFUlBSRVRBVElPTiBpcyBibGFuaywgb21pdCBYTUwgdGFncyAtLT4NCgkJCQkJCQkJCTwhLS0gaW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9IkgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjEuMTEuNzgiIGNvZGVTeXN0ZW1OYW1lPSJITDcgUmVzdWx0IE5vcm1hbGN5IFN0YXR1cyBWYWx1ZSBTZXQiIGRpc3BsYXlOYW1lPSJIaWdoIi8gLS0+DQoJCQkJCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD5IPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQk8L2ludGVycHJldGF0aW9uQ29kZT4NCgkJCQkJCQkJCTwhLS0gQ09NTUVOVCBGT1IgTEFCIFJFU1VMVCwgT3B0aW9uYWwgLS0+CQ0KCQkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0idHJ1ZSIgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCQkJCQkJCSAgPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDAiIC8+DQoJCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4yIiAvPg0KCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSI0ODc2Ny04IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9IkFubm90YXRpb24gQ29tbWVudCIgLz4NCgkJCQkJCQkJCQkJPCEtLSBDT01NRU5UIFJFRkVSRU5DRSBwb2ludHMgdG8gTmFycmF0aXZlIEJsb2NrIC0tPg0KCQkJCQkJCQkJCQk8dGV4dD48cmVmZXJlbmNlIHZhbHVlPSIjbG5kQ29tbWVudDEiIC8+PC90ZXh0Pg0KCQkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCQkJCSAgPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQkgIDxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJICA8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQkJCQkgIDwvYWN0Pg0KCQkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDE1LjA3LVJFU1VMVCBSRUZFUkVOQ0UgUkFOR0UsIE9wdGlvbmFsLCBMbzpIaSAtLT4NCgkJCQkJCQkJCTwhLS0gSWYgMTUuMDctUkVTVUxUIFJFRkVSRU5DRSBSQU5HRSBpcyBibGFuaywgb21pdCBYTUwgdGFncyAtLT4NCgkJCQkJCQkJCTxyZWZlcmVuY2VSYW5nZT4NCgkJCQkJCQkJCQk8b2JzZXJ2YXRpb25SYW5nZT4NCgkJCQkJCQkJCQkJPHRleHQ+NzQtMTE4PC90ZXh0Pg0KCQkJCQkJCQkJCTwvb2JzZXJ2YXRpb25SYW5nZT4NCgkJCQkJCQkJCTwvcmVmZXJlbmNlUmFuZ2U+DQoJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJPC9jb21wb25lbnQ+DQoJCQkJCQk8L29yZ2FuaXplcj4NCgkJCQkJPC9lbnRyeT4NCgkJCQkJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4gDQoJCQkJCQk8IS0tIFZMRVIgMUJpaTogIExhYiBSZXN1bHQgT3JnYW5pemVyLCBSZWFwZWF0cyBmb3IgRWFjaCBWQSBPcmRlciAtLT4NCgkJCQkJCTxvcmdhbml6ZXIgY2xhc3NDb2RlPSJCQVRURVJZIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8IS0tIEhMNyBDQ0QgTGFiIFJlc3VsdCBPcmdhbml6ZXIgVGVtcGxhdGUsIFJlcXVpcmVkICAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMyIiAvPg0KCQkJCQkJCTwhLS0gTGFiIFJlc3VsdCBPcmdhbml6ZXIgSWQgLS0+DQoJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzOzE1MTk0ODE7MzEyMTIwNjsxOzEiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCTwhLS0gTGFiIFJlc3VsdCBPcmdhbml6ZXIgQ29kZS0tPg0KCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCTxvcmlnaW5hbFRleHQ+R0xVQ09TRTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCTwvY29kZT4NCgkJCQkJCQk8IS0tIExhYiBSZXN1bHQgT3JnYW5pemVyIFN0YXR1cywgc3RhdGljLS0+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCTwhLS0gTGFiIFJlc3VsdCBPcmdhbml6ZXIgIERhdGUvVGltZS0tPg0KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDEyMTIwNTA5IiAvPiA8IS0tQ29sbGVjdGVkIERhdGUvVGltZSAtLT4NCgkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgTEFCIFJFU1VMVCBPUkdBTklaRVIsIE9wdGlvbmFsIC0tPgkNCgkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEM4MyBhdXRob3IvYXNzaWduZWRQZXJzb24vTmFtZSAgUmVxdWlyZWQgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJPG5hbWUgLz4NCgkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgT0lEIChJRCA9IFZBIE9JRCwgRVhUID0gVFJFQVRJTkcgRkFDSUxJVFkgTkJSKSAtLT4NCgkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQk8Y29tcG9uZW50PiA8IS0tIENvbXBvbmVudCBSZXBlYXRzIGZvciBFYWNoIFZBIFRlc3QgUmVzdWx0IC0tPg0KCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJIDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zMSIgLz4gDQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjE1IiAvPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNS4xIiAvPg0KCQkJCQkJCQkJPCEtLSBJSEUgU2ltcGxlIE9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjEzIiAvPg0KCQkJCQkJCQkJPCEtLSAgSElUU1AgQzMyIFYyLjU6ICAxNS4wMS1MQUIgUkVTVUxUIElELCBSRVFVSVJFRCAgLS0+DQoJCQkJCQkJCQk8IS0tIDE1LjAxLUxBQiBSRVNVTFQgSUQgIC0tPg0KCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iQ0g7Njg3ODc5Mi45MTs2MDEiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDE1LjAzLUxBQiBSRVNVTFQgVFlQRSwgUkVRVUlSRUQsIExPSU5DICAtLT4NCgkJCQkJCQkJCTwhLS0gMTUuMDMtTEFCIFJFU1VMVCBUWVBFLCAgQWRhcHRlciBtdXN0IG9idGFpbiBMT0lOQyBDb2RlIExvbmcgQ29tbW9uIE5hbWUgZnJvbSBMT0lOQyBEQiAgLS0+DQoJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIj4NCgkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0PkdMVUNPU0U8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCTwhLS0gSUhFIFNpbXBsZSBPYnNlcnZhdGlvbnMgVGV4dCBlbGVtZW50IFJlcXVpcmVkIC0tPg0KCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2xhYi0xIiAvPg0KCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDE1LjA0LVJFU1VMVCBTVEFUVVMsIFJFUVVJUkVELCBJSEUgUmVxdWlyZXMgU3RhdGljIHZhbHVlIG9mIGNvbXBsZXRlZCAgLS0+DQoJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTUuMDItUkVTVUxUIERBVEUvVElNRSwgUkVRVVJJRUQgIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogaWYgYmxhbmssIHRoZW4gZWZmZWN0aXZlVGltZSBudWxsRmxhdm9yPSJVTksiIC0tPg0KCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTIxMjA2MDkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTUuMDUtIFJFU1VMVCBWQUxVRSwgQ09ORElUSU9OQUwgUkVRVUlSRUQgd2hlbiBtb29kQ29kZT1FVk4gIC0tPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIDE1LjA1LSBSRVNVTFQgVkFMVUUsIFNlbnQgYXMgU3RyaW5nIChub3QgSU5UKSBmb3IgVmlzdEEgcmVzdWx0cyB0aGF0IGFyZSBQT1MsIE5FRywgcGVuZGluZyAtLT4NCgkJCQkJCQkJCTx2YWx1ZSByZXByZXNlbnRhdGlvbj0iVFhUIiB4c2k6dHlwZT0iU1QiPjE1MiBNRy9ETDwvdmFsdWU+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgMTUuMDYtUkVTVUxUIElOVEVSUFJFVEFUSU9OLCBPcHRpb25hbCwgVHJhbnNsYXRpb24gdG8gSEw3IFJlc3VsdCBOb3JtYWxjeSBTdGF0dXMgVmFsdWUgU2V0IG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPCEtLSBJZiAxNS4wNi1SRVNVTFQgSU5URVJQUkVUQVRJT04gaXMgYmxhbmssIG9taXQgWE1MIHRhZ3MgLS0+DQoJCQkJCQkJCQk8IS0tIGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJIIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My4xLjExLjc4IiBjb2RlU3lzdGVtTmFtZT0iSEw3IFJlc3VsdCBOb3JtYWxjeSBTdGF0dXMgVmFsdWUgU2V0IiBkaXNwbGF5TmFtZT0iSGlnaCIvIC0tPg0KCQkJCQkJCQkJPGludGVycHJldGF0aW9uQ29kZSBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+SDwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJPC9pbnRlcnByZXRhdGlvbkNvZGU+DQoJCQkJCQkJCQk8IS0tIENPTU1FTlQgRk9SIExBQiBSRVNVTFQsIE9wdGlvbmFsIC0tPgkNCgkJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCBpbnZlcnNpb25JbmQ9InRydWUiIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQkJCQkJCQkgIDxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQwIiAvPg0KCQkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMiIgLz4NCgkJCQkJCQkJCQkJPGNvZGUgY29kZT0iNDg3NjctOCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIGRpc3BsYXlOYW1lPSJBbm5vdGF0aW9uIENvbW1lbnQiIC8+DQoJCQkJCQkJCQkJCTwhLS0gQ09NTUVOVCBSRUZFUkVOQ0UgcG9pbnRzIHRvIE5hcnJhdGl2ZSBCbG9jayAtLT4NCgkJCQkJCQkJCQkJPHRleHQ+PHJlZmVyZW5jZSB2YWx1ZT0iI2xuZENvbW1lbnQxIiAvPjwvdGV4dD4NCgkJCQkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQkJCQkgIDx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJICA8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCSAgPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJCQkJICA8L2FjdD4NCgkJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAxNS4wNy1SRVNVTFQgUkVGRVJFTkNFIFJBTkdFLCBPcHRpb25hbCwgTG86SGkgLS0+DQoJCQkJCQkJCQk8IS0tIElmIDE1LjA3LVJFU1VMVCBSRUZFUkVOQ0UgUkFOR0UgaXMgYmxhbmssIG9taXQgWE1MIHRhZ3MgLS0+DQoJCQkJCQkJCQk8cmVmZXJlbmNlUmFuZ2U+DQoJCQkJCQkJCQkJPG9ic2VydmF0aW9uUmFuZ2U+DQoJCQkJCQkJCQkJCTx0ZXh0Pjc0LTExODwvdGV4dD4NCgkJCQkJCQkJCQk8L29ic2VydmF0aW9uUmFuZ2U+DQoJCQkJCQkJCQk8L3JlZmVyZW5jZVJhbmdlPg0KCQkJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkJCTwvY29tcG9uZW50Pg0KCQkJCQkJPC9vcmdhbml6ZXI+DQoJCQkJCTwvZW50cnk+DQoJCQkJPC9zZWN0aW9uPg0KCQkJPC9jb21wb25lbnQ+DQoJCQkJPCEtLSANCgkJCQkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCQkJCVZMRVIgU0VHTUVOVCAxQjogIElNTVVOSVpBVElPTiBTRUNUSU9ODQoJCQkJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgkJCQktLT4NCgkJCQk8Y29tcG9uZW50PiA8IS0tIENvbXBvbmVudCA2IC0tPg0KCQkJCQk8c2VjdGlvbj4NCgkJCQkJCTwhLS0gSW1tdW5pemF0aW9ucyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS42IiAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjMuMjMiIC8+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xMTciIC8+DQogDQoJCQkJCQk8Y29kZSBjb2RlPSIxMTM2OS02IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9IiBIaXN0b3J5IG9mIGltbXVuaXphdGlvbnMgIiAvPg0KCQkJCQkJPHRpdGxlPkltbXVuaXphdGlvbnM8L3RpdGxlPg0KCQkJCQkJPCEtLSAgSU1NVU5JWkFUSU9OUyBOQVJSQVRJVkUgQkxPQ0sgLCBSRVFVSVJFRCAtLT4NCgkJCQkJCTx0ZXh0Pg0KCQkJCQkJPCEtLSBWTEVSIFNFRyAxQjogSW1tdW5pemF0aW9uIEJ1c2luZXNzIFJ1bGVzIGZvciBNZWRpY2FsIENvbnRlbnQgIC0tPg0KCQkJCQkJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCQkJCQkJPHRoZWFkPg0KCQkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJCTx0aD5EZXBhcnRtZW50IG9mIFZldGVyYW5zIEFmZmFpcnM8L3RoPg0KCQkJCQkJCQkJCTx0aD5CdXNpbmVzcyBSdWxlcyBmb3IgQ29uc3RydWN0aW9uIG9mIE1lZGljYWwgSW5mb3JtYXRpb248L3RoPg0KCQkJCQkJCQkJPC90cj4NCgkJCQkJCQkJPC90aGVhZD4NCgkJCQkJCQkJPHRib2R5Pg0KCQkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJCTx0ZD5JbW11bml6YXRpb25zPC90ZD4NCgkJCQkJCQkJCQk8dGQ+VGhpcyBzZWN0aW9uIGNvbnRhaW5zIHBhdGllbnQgaW1tdW5pemF0aW9ucyBpbmZvcm1hdGlvbiBmcm9tIGFsbCBWQSB0cmVhdG1lbnQgZmFjaWxpdGllcy4gT25seSBhZG1pbmlzdHJlZCAoaS5lLiwgbm90IHJlZnVzZWQpIGltbXVuaXphdGlvbnMgYXJlIGluY2x1ZGVkLjwvdGQ+DQoJCQkJCQkJCQk8L3RyPg0KCQkJCQkJCQk8L3Rib2R5Pg0KCQkJCQkJCTwvdGFibGU+DQoJCQkJCQkJPHRhYmxlIElEPSJpbW11bml6YXRpb25OYXJyaXRpdmUiIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJCQkJCQk8dGhlYWQ+DQoJCQkJCQkJCQk8dHI+DQoJCQkJCQkJCQkJPHRoPkltbXVuaXphdGlvbjwvdGg+DQoJCQkJCQkJCQkJPHRoPlNlcmllczwvdGg+DQoJCQkJCQkJCQkJPHRoPkRhdGUgSXNzdWVkPC90aD4NCgkJCQkJCQkJCQk8dGg+UmVhY3Rpb248L3RoPg0KCQkJCQkJCQkJCTx0aD5Db21tZW50czwvdGg+DQoJCQkJCQkJCQk8L3RyPg0KCQkJCQkJCQk8L3RoZWFkPg0KCQkJCQkJCQk8dGJvZHk+DQoJCQkJCQkJCQk8dHI+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kSW1tdW5pemF0aW9uMSI+QURFTk9WSVJVUyxUWVBFIDQ8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmRTZXJpZXMxIiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kRGF0ZUlzc3VlZDEiPjIwMTIxMjEwPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kUmVhY3Rpb24xIiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kQ29tbWVudHMxIj5ldGUgTk8gQ09OVFJBSU5ESUNBVElPTjsgT0sgVE8gVVNFIElOIEZVVFVSRS48L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImluZEltbXVuaXphdGlvbjIiPk1FQVNMRVM8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmRTZXJpZXMyIiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kRGF0ZUlzc3VlZDIiPjIwMTIwNTI1PC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kUmVhY3Rpb24yIiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kQ29tbWVudHMyIj5zZXJpb3VzIGNvbmRpdGlvbiBOTyBDT05UUkFJTkRJQ0FUSU9OOyBPSyBUTyBVU0UgSU4gRlVUVVJFLjwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kSW1tdW5pemF0aW9uMyI+QURFTk9WSVJVUyxUWVBFIDc8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmRTZXJpZXMzIiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kRGF0ZUlzc3VlZDMiPjIwMTExMTAyPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kUmVhY3Rpb24zIiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kQ29tbWVudHMzIj5maXJzdCBpbW11bml6YXRpb24gTk8gQ09OVFJBSU5ESUNBVElPTjsgT0sgVE8gVVNFIElOIEZVVFVSRS48L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImluZEltbXVuaXphdGlvbjQiPkNIT0xFUkEsIE9SQUw8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmRTZXJpZXM0IiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kRGF0ZUlzc3VlZDQiPjIwMTExMTAyPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kUmVhY3Rpb240IiAvPg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kQ29tbWVudHM0Ij5zZWNvbmQgaW1tdW5pemF0aW9uIE5PIENPTlRSQUlORElDQVRJT047IE9LIFRPIFVTRSBJTiBGVVRVUkUuPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmRJbW11bml6YXRpb241Ij5DSElDS0VOUE9YPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kU2VyaWVzNSI+MTwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImluZERhdGVJc3N1ZWQ1Ij4yMDExMTEwMTwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImluZFJlYWN0aW9uNSI+RkVWRVI8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmRDb21tZW50czUiPiBOTyBDT05UUkFJTkRJQ0FUSU9OOyBPSyBUTyBVU0UgSU4gRlVUVVJFLjwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCQk8Y29udGVudCBJRD0iaW5kSW1tdW5pemF0aW9uNiI+Q0hPTEVSQTwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImluZFNlcmllczYiIC8+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmREYXRlSXNzdWVkNiI+MjAxMTExMDE8L2NvbnRlbnQ+DQoJCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJCTxjb250ZW50IElEPSJpbmRSZWFjdGlvbjYiPklSUklUQUJJTElUWTwvY29udGVudD4NCgkJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImluZENvbW1lbnRzNiI+SXJyaXRhYmlsaXR5IE5PIENPTlRSQUlORElDQVRJT047IE9LIFRPIFVTRSBJTiBGVVRVUkUuPC9jb250ZW50Pg0KCQkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8L3RyPg0KCQkJCQkJCQk8L3Rib2R5Pg0KCQkJCQkJCTwvdGFibGU+DQoJCQkJCQk8L3RleHQ+DQoJCQkJCQk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPiA8IS0tIFJlcGVhdCBlbnRyeS9zdWJzdGFuY2VBZG1pbnN0cmF0aW9uIGJsb2NrIGZvciBlYWNoIEltbXVuaXphdGlvbiAtLT4NCgkJCQkJCQk8IS0tIDEzLjAxLVJFRlVTQUwsIFJFUVVJUkVELCBzdGF0aWMgdmFsdWUgb2YgImZhbHNlIiAtLT4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSEw3IENEQSBSMi1JZiBJbW11bml6YXRpb24gd2FzIGFkbWluaXN0ZXJlZCwgQG5lZ2F0aW9uSW5kPWZhbHNlIC0tPg0KCQkJCQkJCTxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIFRlbXBsYXRlcyAgLS0+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjQiIC8+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTMiIC8+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xMiIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogSW1tdW5pemF0aW9uIElkIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8Y29kZSBjb2RlPSJJTU1VTklaIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIiAvPg0KCQkJCQkJCQk8IS0tIENPTU1FTlQgUkVGRVJFTkNFIHBvaW50cyB0byBOYXJyYXRpdmUgQmxvY2sgLS0+DQoJCQkJCQkJCTx0ZXh0PjxyZWZlcmVuY2UgdmFsdWU9IiNpbmRDb21tZW50czEiIC8+PC90ZXh0Pg0KCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCTwhLS0gMTMuMDItQURNSU5JU1RFUkVEIERBVEUsIFJFUVVJUkVELCAgLS0+DQoJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDEyMTIxMCIgLz4NCgkJCQkJCQkJPGNvbnN1bWFibGU+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIE1lZGljYXRpb24gIC0tPg0KCQkJCQkJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCQkJCQkJPCEtLSBQcm9kdWN0IHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTMiIC8+IA0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC43LjIiIC8+DQoJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJPCEtLW1hbnVmYWN0dXJlZExhYmVsZWREcnVnPjwvbWFudWZhY3R1cmVkTGFiZWxlZERydWcgLS0+DQoJCQkJCQkJCQkJCTxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQkJCQkJCQkJPCEtLSAxMy4wNi1DT0RFRCBQUk9EVUNUIE5BTUUsIE9wdGlvbmFsLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHRocnUgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIENPREVEIFBST0RVQ1QgTkFNRSwgT3B0aW9uYWwsIFJlcXVpcmVzIENWWC1WYWNjaW5lcyBBZG1pbnN0ZXJlZCAsIFZBIHByb3ZpZGVzIENQVC00LS0+DQoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuNTkiIGNvZGVTeXN0ZW1OYW1lPSJDVlgiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJPCEtLSAxMy4wNy1GUkVFIFRFWFRQUk9EVUNUIE5BTUUsIFJFUVVJUkVELCBQb2ludGVyIHRvIE5hcnJhdGl2ZSBCbG9jayAgLS0+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2luZEltbXVuaXphdGlvbjEiIC8+DQoJCQkJCQkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJDQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIDEzLjA5LUxPVCBOVU1CRVIsIE9wdGlvbmFsLCBYTUwgb21pdHRlZCBiL2Mgbm90IHlldCAgZGF0YSBhdmFpbGFibGUgdGhydSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQk8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQkJPCEtLSAxMy4wOCBEUlVHIE1BTlVGQUNUVVJFUiwgT3B0aW9uYWwsIFhNTCBvbWl0dGVkIGIvYyBub3QgeWV0IGRhdGEgYXZhaWxhYmxlIHRocnUgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJPC9tYW51ZmFjdHVyZXJPcmdhbml6YXRpb24+DQoJCQkJCQkJCQk8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCQkJCTwvY29uc3VtYWJsZT4NCgkJCQkJCQkJPCEtLSAxMy4wNS1QRVJGT1JNRVIsIE9wdGlvbmFsICAtLT4NCgkJCQkJCQkJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCgkJCQkJCQkJCTwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS4zMi40IiAvPg0KCQkJCQkJCQkJPHRpbWU+DQoJCQkJCQkJCQkJIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTwvdGltZT4NCgkJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJCTwhLS0gUHJvdmlkZXIgSUQsIGV4dGVuc2lvbiA9IFByb3ZpZGVyIElELCByb290PVZBIE9JRCAgLS0+DQoJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2NTU4NyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCQk8bmFtZT5Qcm92aWRlciwgT25lPC9uYW1lPg0KCQkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQk8L3BlcmZvcm1lcj4NCgkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIElNTVVOSVpBVElPTiwgT3B0aW9uYWwgLS0+CQ0KCQkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQzgzIGF1dGhvci9hc3NpZ25lZFBlcnNvbi9OYW1lICBSZXF1aXJlZCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE9JRCAoSUQgPSBWQSBPSUQsIEVYVCA9IFRSRUFUSU5HIEZBQ0lMSVRZIE5CUikgLS0+DQoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIE1lZGljYXRpb24gU2VyaWVzIE5iciAtLT4NCgkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4gDQoJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDYiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFJlcXVpcmVkIENvZGUgdW5kZXIgT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzA5NzMtMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIGRpc3BsYXlOYW1lPSJEb3NlIE51bWJlciIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgUmVxdWlyZWQgc3RhdHVzQ29kZSB1bmRlciBPYnNlcnZhdGlvbiAtLT4NCgkJCQkJCQkJCQkgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQk8IS0tIDEzLjAzLU1FRElDQVRJT04gU0VSSUVTIE5VTUJFUiwgIE9wdGlvbmFsLCBTZW50IGFzIFNUcmluZyBub3QgSU5UZWdlciAgdG8gYWNjb21tb2RhdGUgVkEgVmlzdEEgZGF0YSBzdWNoIGFzIFAtUGFydGlhbCwgQi1Cb29zdGVyLCBDLUNvbXBsZXRlIC0tPg0KCQkJCQkJCQkJCTx2YWx1ZSBudWxsRmxhdm9yPSJVTksiIHhzaTp0eXBlPSJJTlQiIC8+DQoJCQkJCQkJCQk8L29ic2VydmF0aW9uPgkNCgkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBSZWFjdGlvbiAgLS0+DQoJCQkJCQkJCQ0KCQkJCQkJCTwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQoJCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+IDwhLS0gUmVwZWF0IGVudHJ5L3N1YnN0YW5jZUFkbWluc3RyYXRpb24gYmxvY2sgZm9yIGVhY2ggSW1tdW5pemF0aW9uIC0tPg0KCQkJCQkJCTwhLS0gMTMuMDEtUkVGVVNBTCwgUkVRVUlSRUQsIHN0YXRpYyB2YWx1ZSBvZiAiZmFsc2UiIC0tPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBITDcgQ0RBIFIyLUlmIEltbXVuaXphdGlvbiB3YXMgYWRtaW5pc3RlcmVkLCBAbmVnYXRpb25JbmQ9ZmFsc2UgLS0+DQoJCQkJCQkJPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJbW11bml6YXRpb24gVGVtcGxhdGVzICAtLT4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNCIgLz4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xMyIgLz4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjEyIiAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBJbW11bml6YXRpb24gSWQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTxjb2RlIGNvZGU9IklNTVVOSVoiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiIC8+DQoJCQkJCQkJCTwhLS0gQ09NTUVOVCBSRUZFUkVOQ0UgcG9pbnRzIHRvIE5hcnJhdGl2ZSBCbG9jayAtLT4NCgkJCQkJCQkJPHRleHQ+PHJlZmVyZW5jZSB2YWx1ZT0iI2luZENvbW1lbnRzMiIgLz48L3RleHQ+DQoJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJPCEtLSAxMy4wMi1BRE1JTklTVEVSRUQgREFURSwgUkVRVUlSRUQsICAtLT4NCgkJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTIwNTI1IiAvPg0KCQkJCQkJCQk8Y29uc3VtYWJsZT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJbW11bml6YXRpb24gTWVkaWNhdGlvbiAgLS0+DQoJCQkJCQkJCQk8bWFudWZhY3R1cmVkUHJvZHVjdD4NCgkJCQkJCQkJCQk8IS0tIFByb2R1Y3QgdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MyIgLz4gDQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjcuMiIgLz4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQk8IS0tbWFudWZhY3R1cmVkTGFiZWxlZERydWc+PC9tYW51ZmFjdHVyZWRMYWJlbGVkRHJ1ZyAtLT4NCgkJCQkJCQkJCQkJPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCQkJCQkJCQk8IS0tIDEzLjA2LUNPREVEIFBST0RVQ1QgTkFNRSwgT3B0aW9uYWwsIG51bGxGbGF2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdGhydSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQ09ERUQgUFJPRFVDVCBOQU1FLCBPcHRpb25hbCwgUmVxdWlyZXMgQ1ZYLVZhY2NpbmVzIEFkbWluc3RlcmVkICwgVkEgcHJvdmlkZXMgQ1BULTQtLT4NCgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IlVOSyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi41OSIgY29kZVN5c3RlbU5hbWU9IkNWWCIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQkJCQk8IS0tIDEzLjA3LUZSRUUgVEVYVFBST0RVQ1QgTkFNRSwgUkVRVUlSRUQsIFBvaW50ZXIgdG8gTmFycmF0aXZlIEJsb2NrICAtLT4NCgkJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjaW5kSW1tdW5pemF0aW9uMiIgLz4NCgkJCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkNCgkJCQkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCQkJCTwhLS0gMTMuMDktTE9UIE5VTUJFUiwgT3B0aW9uYWwsIFhNTCBvbWl0dGVkIGIvYyBub3QgeWV0ICBkYXRhIGF2YWlsYWJsZSB0aHJ1IFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQkJCTwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQkJCQkJCTxtYW51ZmFjdHVyZXJPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCQk8IS0tIDEzLjA4IERSVUcgTUFOVUZBQ1RVUkVSLCBPcHRpb25hbCwgWE1MIG9taXR0ZWQgYi9jIG5vdCB5ZXQgZGF0YSBhdmFpbGFibGUgdGhydSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQk8L21hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCgkJCQkJCQkJPC9jb25zdW1hYmxlPg0KCQkJCQkJCQk8IS0tIDEzLjA1LVBFUkZPUk1FUiwgT3B0aW9uYWwgIC0tPg0KCQkJCQkJCQk8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KCQkJCQkJCQkJPCEtLSBQcm92aWRlciBUZW1wbGF0ZSBJZCAgLS0+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQoJCQkJCQkJCQk8dGltZT4NCgkJCQkJCQkJCQkgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPC90aW1lPg0KCQkJCQkJCQkJPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQkJPCEtLSBQcm92aWRlciBJRCwgZXh0ZW5zaW9uID0gUHJvdmlkZXIgSUQsIHJvb3Q9VkEgT0lEICAtLT4NCgkJCQkJCQkJCTxpZCBleHRlbnNpb249IjY1MzY1IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGlhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJCTxuYW1lPkNQUlNET0NUT1IsQkVUSCBQPC9uYW1lPg0KCQkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQk8L3BlcmZvcm1lcj4NCgkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIElNTVVOSVpBVElPTiwgT3B0aW9uYWwgLS0+CQ0KCQkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQzgzIGF1dGhvci9hc3NpZ25lZFBlcnNvbi9OYW1lICBSZXF1aXJlZCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE9JRCAoSUQgPSBWQSBPSUQsIEVYVCA9IFRSRUFUSU5HIEZBQ0lMSVRZIE5CUikgLS0+DQoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIE1lZGljYXRpb24gU2VyaWVzIE5iciAtLT4NCgkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4gDQoJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDYiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFJlcXVpcmVkIENvZGUgdW5kZXIgT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzA5NzMtMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIGRpc3BsYXlOYW1lPSJEb3NlIE51bWJlciIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgUmVxdWlyZWQgc3RhdHVzQ29kZSB1bmRlciBPYnNlcnZhdGlvbiAtLT4NCgkJCQkJCQkJCQkgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQk8IS0tIDEzLjAzLU1FRElDQVRJT04gU0VSSUVTIE5VTUJFUiwgIE9wdGlvbmFsLCBTZW50IGFzIFNUcmluZyBub3QgSU5UZWdlciAgdG8gYWNjb21tb2RhdGUgVkEgVmlzdEEgZGF0YSBzdWNoIGFzIFAtUGFydGlhbCwgQi1Cb29zdGVyLCBDLUNvbXBsZXRlIC0tPg0KCQkJCQkJCQkJCTx2YWx1ZSBudWxsRmxhdm9yPSJVTksiIHhzaTp0eXBlPSJJTlQiIC8+DQoJCQkJCQkJCQk8L29ic2VydmF0aW9uPgkNCgkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBSZWFjdGlvbiAgLS0+DQoJCQkJCQkJCQ0KCQkJCQkJCTwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQoJCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+IDwhLS0gUmVwZWF0IGVudHJ5L3N1YnN0YW5jZUFkbWluc3RyYXRpb24gYmxvY2sgZm9yIGVhY2ggSW1tdW5pemF0aW9uIC0tPg0KCQkJCQkJCTwhLS0gMTMuMDEtUkVGVVNBTCwgUkVRVUlSRUQsIHN0YXRpYyB2YWx1ZSBvZiAiZmFsc2UiIC0tPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBITDcgQ0RBIFIyLUlmIEltbXVuaXphdGlvbiB3YXMgYWRtaW5pc3RlcmVkLCBAbmVnYXRpb25JbmQ9ZmFsc2UgLS0+DQoJCQkJCQkJPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJFVk4iIG5lZ2F0aW9uSW5kPSJmYWxzZSI+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJbW11bml6YXRpb24gVGVtcGxhdGVzICAtLT4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNCIgLz4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xMyIgLz4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjEyIiAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBJbW11bml6YXRpb24gSWQgYXMgbnVsbEZsYXZvciAgLS0+DQoJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTxjb2RlIGNvZGU9IklNTVVOSVoiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgY29kZVN5c3RlbU5hbWU9IkFjdENvZGUiIC8+DQoJCQkJCQkJCTwhLS0gQ09NTUVOVCBSRUZFUkVOQ0UgcG9pbnRzIHRvIE5hcnJhdGl2ZSBCbG9jayAtLT4NCgkJCQkJCQkJPHRleHQ+PHJlZmVyZW5jZSB2YWx1ZT0iI2luZENvbW1lbnRzMyIgLz48L3RleHQ+DQoJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJPCEtLSAxMy4wMi1BRE1JTklTVEVSRUQgREFURSwgUkVRVUlSRUQsICAtLT4NCgkJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTExMTAyIiAvPg0KCQkJCQkJCQk8Y29uc3VtYWJsZT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJbW11bml6YXRpb24gTWVkaWNhdGlvbiAgLS0+DQoJCQkJCQkJCQk8bWFudWZhY3R1cmVkUHJvZHVjdD4NCgkJCQkJCQkJCQk8IS0tIFByb2R1Y3QgdGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MyIgLz4gDQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjcuMiIgLz4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCQk8IS0tbWFudWZhY3R1cmVkTGFiZWxlZERydWc+PC9tYW51ZmFjdHVyZWRMYWJlbGVkRHJ1ZyAtLT4NCgkJCQkJCQkJCQkJPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCQkJCQkJCQk8IS0tIDEzLjA2LUNPREVEIFBST0RVQ1QgTkFNRSwgT3B0aW9uYWwsIG51bGxGbGF2b3IgYi9jIGRhdGEgbm90IHlldCBhdmFpbGFibGUgdGhydSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgQ09ERUQgUFJPRFVDVCBOQU1FLCBPcHRpb25hbCwgUmVxdWlyZXMgQ1ZYLVZhY2NpbmVzIEFkbWluc3RlcmVkICwgVkEgcHJvdmlkZXMgQ1BULTQtLT4NCgkJCQkJCQkJCQkJCTxjb2RlIGNvZGU9IlVOSyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi41OSIgY29kZVN5c3RlbU5hbWU9IkNWWCIgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCQkJCQkJCQk8IS0tIDEzLjA3LUZSRUUgVEVYVFBST0RVQ1QgTkFNRSwgUkVRVUlSRUQsIFBvaW50ZXIgdG8gTmFycmF0aXZlIEJsb2NrICAtLT4NCgkJCQkJCQkJCQkJCQk8b3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjaW5kSW1tdW5pemF0aW9uMyIgLz4NCgkJCQkJCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkNCgkJCQkJCQkJCQkJCTwvY29kZT4NCgkJCQkJCQkJCQkJCTwhLS0gMTMuMDktTE9UIE5VTUJFUiwgT3B0aW9uYWwsIFhNTCBvbWl0dGVkIGIvYyBub3QgeWV0ICBkYXRhIGF2YWlsYWJsZSB0aHJ1IFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQkJCTwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQkJCQkJCTxtYW51ZmFjdHVyZXJPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCQk8IS0tIDEzLjA4IERSVUcgTUFOVUZBQ1RVUkVSLCBPcHRpb25hbCwgWE1MIG9taXR0ZWQgYi9jIG5vdCB5ZXQgZGF0YSBhdmFpbGFibGUgdGhydSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQk8L21hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCgkJCQkJCQkJPC9jb25zdW1hYmxlPg0KCQkJCQkJCQk8IS0tIDEzLjA1LVBFUkZPUk1FUiwgT3B0aW9uYWwgIC0tPg0KCQkJCQkJCQk8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KCQkJCQkJCQkJPCEtLSBQcm92aWRlciBUZW1wbGF0ZSBJZCAgLS0+DQoJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQoJCQkJCQkJCQk8dGltZT4NCgkJCQkJCQkJCQkgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPC90aW1lPg0KCQkJCQkJCQkJPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQkJPCEtLSBQcm92aWRlciBJRCwgZXh0ZW5zaW9uID0gUHJvdmlkZXIgSUQsIHJvb3Q9VkEgT0lEICAtLT4NCgkJCQkJCQkJCTxpZCBleHRlbnNpb249IjY1NTg3IiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGlhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJCTxuYW1lPlByb3ZpZGVyLCBPbmU8L25hbWU+DQoJCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCTwvcGVyZm9ybWVyPg0KCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgSU1NVU5JWkFUSU9OLCBPcHRpb25hbCAtLT4JDQoJCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRBdXRob3IsIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBDODMgYXV0aG9yL2Fzc2lnbmVkUGVyc29uL05hbWUgIFJlcXVpcmVkIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQkJPG5hbWUgLz4NCgkJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgT0lEIChJRCA9IFZBIE9JRCwgRVhUID0gVFJFQVRJTkcgRkFDSUxJVFkgTkJSKSAtLT4NCgkJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQkJPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJbW11bml6YXRpb24gTWVkaWNhdGlvbiBTZXJpZXMgTmJyIC0tPg0KCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPiANCgkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NiIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgUmVxdWlyZWQgQ29kZSB1bmRlciBPYnNlcnZhdGlvbiAtLT4NCgkJCQkJCQkJCQk8Y29kZSBjb2RlPSIzMDk3My0yIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9IkRvc2UgTnVtYmVyIiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBSZXF1aXJlZCBzdGF0dXNDb2RlIHVuZGVyIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCSAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQkJCTwhLS0gMTMuMDMtTUVESUNBVElPTiBTRVJJRVMgTlVNQkVSLCAgT3B0aW9uYWwsIFNlbnQgYXMgU1RyaW5nIG5vdCBJTlRlZ2VyICB0byBhY2NvbW1vZGF0ZSBWQSBWaXN0QSBkYXRhIHN1Y2ggYXMgUC1QYXJ0aWFsLCBCLUJvb3N0ZXIsIEMtQ29tcGxldGUgLS0+DQoJCQkJCQkJCQkJPHZhbHVlIG51bGxGbGF2b3I9IlVOSyIgeHNpOnR5cGU9IklOVCIgLz4NCgkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CQ0KCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIFJlYWN0aW9uICAtLT4NCgkJCQkJCQkJDQoJCQkJCQkJPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCgkJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4gPCEtLSBSZXBlYXQgZW50cnkvc3Vic3RhbmNlQWRtaW5zdHJhdGlvbiBibG9jayBmb3IgZWFjaCBJbW11bml6YXRpb24gLS0+DQoJCQkJCQkJPCEtLSAxMy4wMS1SRUZVU0FMLCBSRVFVSVJFRCwgc3RhdGljIHZhbHVlIG9mICJmYWxzZSIgLS0+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEhMNyBDREEgUjItSWYgSW1tdW5pemF0aW9uIHdhcyBhZG1pbmlzdGVyZWQsIEBuZWdhdGlvbkluZD1mYWxzZSAtLT4NCgkJCQkJCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiIgbmVnYXRpb25JbmQ9ImZhbHNlIj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBUZW1wbGF0ZXMgIC0tPg0KCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI0IiAvPg0KCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjEzIiAvPg0KCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMTIiIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IEltbXVuaXphdGlvbiBJZCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGNvZGUgY29kZT0iSU1NVU5JWiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSIgLz4NCgkJCQkJCQkJPCEtLSBDT01NRU5UIFJFRkVSRU5DRSBwb2ludHMgdG8gTmFycmF0aXZlIEJsb2NrIC0tPg0KCQkJCQkJCQk8dGV4dD48cmVmZXJlbmNlIHZhbHVlPSIjaW5kQ29tbWVudHM0IiAvPjwvdGV4dD4NCgkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQk8IS0tIDEzLjAyLUFETUlOSVNURVJFRCBEQVRFLCBSRVFVSVJFRCwgIC0tPg0KCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAxMTExMDIiIC8+DQoJCQkJCQkJCTxjb25zdW1hYmxlPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBNZWRpY2F0aW9uICAtLT4NCgkJCQkJCQkJCTxtYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJCQkJCQkJCTwhLS0gUHJvZHVjdCB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUzIiAvPiANCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNy4yIiAvPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCTwhLS1tYW51ZmFjdHVyZWRMYWJlbGVkRHJ1Zz48L21hbnVmYWN0dXJlZExhYmVsZWREcnVnIC0tPg0KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQkJCQkJCTwhLS0gMTMuMDYtQ09ERUQgUFJPRFVDVCBOQU1FLCBPcHRpb25hbCwgbnVsbEZsYXZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB0aHJ1IFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBDT0RFRCBQUk9EVUNUIE5BTUUsIE9wdGlvbmFsLCBSZXF1aXJlcyBDVlgtVmFjY2luZXMgQWRtaW5zdGVyZWQgLCBWQSBwcm92aWRlcyBDUFQtNC0tPg0KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iVU5LIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjU5IiBjb2RlU3lzdGVtTmFtZT0iQ1ZYIiBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCQkJCTwhLS0gMTMuMDctRlJFRSBURVhUUFJPRFVDVCBOQU1FLCBSRVFVSVJFRCwgUG9pbnRlciB0byBOYXJyYXRpdmUgQmxvY2sgIC0tPg0KCQkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNpbmRJbW11bml6YXRpb240IiAvPg0KCQkJCQkJCQkJCQkJCTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQ0KCQkJCQkJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCQkJCQkJPCEtLSAxMy4wOS1MT1QgTlVNQkVSLCBPcHRpb25hbCwgWE1MIG9taXR0ZWQgYi9jIG5vdCB5ZXQgIGRhdGEgYXZhaWxhYmxlIHRocnUgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQkJCQkJCQkJPG1hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJCTwhLS0gMTMuMDggRFJVRyBNQU5VRkFDVFVSRVIsIE9wdGlvbmFsLCBYTUwgb21pdHRlZCBiL2Mgbm90IHlldCBkYXRhIGF2YWlsYWJsZSB0aHJ1IFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQkJCTwvbWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJCQkJCQk8L2NvbnN1bWFibGU+DQoJCQkJCQkJCTwhLS0gMTMuMDUtUEVSRk9STUVSLCBPcHRpb25hbCAgLS0+DQoJCQkJCQkJCTxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQoJCQkJCQkJCQk8IS0tIFByb3ZpZGVyIFRlbXBsYXRlIElkICAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuNCIgLz4NCgkJCQkJCQkJCTx0aW1lPg0KCQkJCQkJCQkJCSA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8L3RpbWU+DQoJCQkJCQkJCQk8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCQk8IS0tIFByb3ZpZGVyIElELCBleHRlbnNpb24gPSBQcm92aWRlciBJRCwgcm9vdD1WQSBPSUQgIC0tPg0KCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjU1ODciIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQkJPG5hbWU+UHJvdmlkZXIsIE9uZTwvbmFtZT4NCgkJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPC9hc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJPC9wZXJmb3JtZXI+DQoJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBJTU1VTklaQVRJT04sIE9wdGlvbmFsIC0tPgkNCgkJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEM4MyBhdXRob3IvYXNzaWduZWRQZXJzb24vTmFtZSAgUmVxdWlyZWQgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBPSUQgKElEID0gVkEgT0lELCBFWFQgPSBUUkVBVElORyBGQUNJTElUWSBOQlIpIC0tPg0KCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBNZWRpY2F0aW9uIFNlcmllcyBOYnIgLS0+DQoJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+IA0KCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ2IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBSZXF1aXJlZCBDb2RlIHVuZGVyIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMwOTczLTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBkaXNwbGF5TmFtZT0iRG9zZSBOdW1iZXIiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFJlcXVpcmVkIHN0YXR1c0NvZGUgdW5kZXIgT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJPCEtLSAxMy4wMy1NRURJQ0FUSU9OIFNFUklFUyBOVU1CRVIsICBPcHRpb25hbCwgU2VudCBhcyBTVHJpbmcgbm90IElOVGVnZXIgIHRvIGFjY29tbW9kYXRlIFZBIFZpc3RBIGRhdGEgc3VjaCBhcyBQLVBhcnRpYWwsIEItQm9vc3RlciwgQy1Db21wbGV0ZSAtLT4NCgkJCQkJCQkJCQk8dmFsdWUgbnVsbEZsYXZvcj0iVU5LIiB4c2k6dHlwZT0iSU5UIiAvPg0KCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4JDQoJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJbW11bml6YXRpb24gUmVhY3Rpb24gIC0tPg0KCQkJCQkJCQkNCgkJCQkJCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KCQkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPiA8IS0tIFJlcGVhdCBlbnRyeS9zdWJzdGFuY2VBZG1pbnN0cmF0aW9uIGJsb2NrIGZvciBlYWNoIEltbXVuaXphdGlvbiAtLT4NCgkJCQkJCQk8IS0tIDEzLjAxLVJFRlVTQUwsIFJFUVVJUkVELCBzdGF0aWMgdmFsdWUgb2YgImZhbHNlIiAtLT4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSEw3IENEQSBSMi1JZiBJbW11bml6YXRpb24gd2FzIGFkbWluaXN0ZXJlZCwgQG5lZ2F0aW9uSW5kPWZhbHNlIC0tPg0KCQkJCQkJCTxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iRVZOIiBuZWdhdGlvbkluZD0iZmFsc2UiPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIFRlbXBsYXRlcyAgLS0+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjQiIC8+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTMiIC8+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xMiIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogSW1tdW5pemF0aW9uIElkIGFzIG51bGxGbGF2b3IgIC0tPg0KCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8Y29kZSBjb2RlPSJJTU1VTklaIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiIGNvZGVTeXN0ZW1OYW1lPSJBY3RDb2RlIiAvPg0KCQkJCQkJCQk8IS0tIENPTU1FTlQgUkVGRVJFTkNFIHBvaW50cyB0byBOYXJyYXRpdmUgQmxvY2sgLS0+DQoJCQkJCQkJCTx0ZXh0PjxyZWZlcmVuY2UgdmFsdWU9IiNpbmRDb21tZW50czUiIC8+PC90ZXh0Pg0KCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCTwhLS0gMTMuMDItQURNSU5JU1RFUkVEIERBVEUsIFJFUVVJUkVELCAgLS0+DQoJCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDExMTEwMSIgLz4NCgkJCQkJCQkJPGNvbnN1bWFibGU+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIE1lZGljYXRpb24gIC0tPg0KCQkJCQkJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCQkJCQkJPCEtLSBQcm9kdWN0IHRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTMiIC8+IA0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC43LjIiIC8+DQoJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQkJPCEtLW1hbnVmYWN0dXJlZExhYmVsZWREcnVnPjwvbWFudWZhY3R1cmVkTGFiZWxlZERydWcgLS0+DQoJCQkJCQkJCQkJCTxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQkJCQkJCQkJPCEtLSAxMy4wNi1DT0RFRCBQUk9EVUNUIE5BTUUsIE9wdGlvbmFsLCBudWxsRmxhdm9yIGIvYyBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIHRocnUgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIENPREVEIFBST0RVQ1QgTkFNRSwgT3B0aW9uYWwsIFJlcXVpcmVzIENWWC1WYWNjaW5lcyBBZG1pbnN0ZXJlZCAsIFZBIHByb3ZpZGVzIENQVC00LS0+DQoJCQkJCQkJCQkJCQk8Y29kZSBjb2RlPSJVTksiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuNTkiIGNvZGVTeXN0ZW1OYW1lPSJDVlgiIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQkJCQkJCQkJPCEtLSAxMy4wNy1GUkVFIFRFWFRQUk9EVUNUIE5BTUUsIFJFUVVJUkVELCBQb2ludGVyIHRvIE5hcnJhdGl2ZSBCbG9jayAgLS0+DQoJCQkJCQkJCQkJCQkJPG9yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2luZEltbXVuaXphdGlvbjUiIC8+DQoJCQkJCQkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJDQoJCQkJCQkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJCQkJCQk8IS0tIDEzLjA5LUxPVCBOVU1CRVIsIE9wdGlvbmFsLCBYTUwgb21pdHRlZCBiL2Mgbm90IHlldCAgZGF0YSBhdmFpbGFibGUgdGhydSBWaXN0QSBSUENzIC0tPg0KCQkJCQkJCQkJCQk8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQkJPCEtLSAxMy4wOCBEUlVHIE1BTlVGQUNUVVJFUiwgT3B0aW9uYWwsIFhNTCBvbWl0dGVkIGIvYyBub3QgeWV0IGRhdGEgYXZhaWxhYmxlIHRocnUgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJPC9tYW51ZmFjdHVyZXJPcmdhbml6YXRpb24+DQoJCQkJCQkJCQk8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCQkJCTwvY29uc3VtYWJsZT4NCgkJCQkJCQkJPCEtLSAxMy4wNS1QRVJGT1JNRVIsIE9wdGlvbmFsICAtLT4NCgkJCQkJCQkJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCgkJCQkJCQkJCTwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS4zMi40IiAvPg0KCQkJCQkJCQkJPHRpbWU+DQoJCQkJCQkJCQkJIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTwvdGltZT4NCgkJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJCTwhLS0gUHJvdmlkZXIgSUQsIGV4dGVuc2lvbiA9IFByb3ZpZGVyIElELCByb290PVZBIE9JRCAgLS0+DQoJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2NTU4NyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCQk8bmFtZT5Qcm92aWRlciwgT25lPC9uYW1lPg0KCQkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQk8L3BlcmZvcm1lcj4NCgkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIElNTVVOSVpBVElPTiwgT3B0aW9uYWwgLS0+CQ0KCQkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkQXV0aG9yLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQzgzIGF1dGhvci9hc3NpZ25lZFBlcnNvbi9OYW1lICBSZXF1aXJlZCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE9JRCAoSUQgPSBWQSBPSUQsIEVYVCA9IFRSRUFUSU5HIEZBQ0lMSVRZIE5CUikgLS0+DQoJCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIE1lZGljYXRpb24gU2VyaWVzIE5iciAtLT4NCgkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4gDQoJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDYiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFJlcXVpcmVkIENvZGUgdW5kZXIgT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJPGNvZGUgY29kZT0iMzA5NzMtMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBjb2RlU3lzdGVtTmFtZT0iTE9JTkMiIGRpc3BsYXlOYW1lPSJEb3NlIE51bWJlciIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgUmVxdWlyZWQgc3RhdHVzQ29kZSB1bmRlciBPYnNlcnZhdGlvbiAtLT4NCgkJCQkJCQkJCQkgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQk8IS0tIDEzLjAzLU1FRElDQVRJT04gU0VSSUVTIE5VTUJFUiwgIE9wdGlvbmFsLCBTZW50IGFzIFNUcmluZyBub3QgSU5UZWdlciAgdG8gYWNjb21tb2RhdGUgVkEgVmlzdEEgZGF0YSBzdWNoIGFzIFAtUGFydGlhbCwgQi1Cb29zdGVyLCBDLUNvbXBsZXRlIC0tPg0KCQkJCQkJCQkJCTx2YWx1ZSB2YWx1ZT0iMSIgeHNpOnR5cGU9IklOVCIgLz4NCgkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+CQ0KCQkJCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSW1tdW5pemF0aW9uIFJlYWN0aW9uICAtLT4NCgkJCQkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIGludmVyc2lvbkluZD0iZmFsc2UiIHR5cGVDb2RlPSJDQVVTIj4gIDwhLS0gUmVwZWF0IGVudHJ5UmVsYXRpb25zaGlwL29ic2VydmF0aW9uIGJsb2NrIGZvciBlYWNoIGltbXVuaXogcmVhY3Rpb24gLS0+DQoJCQkJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41NCIgLz4NCgkJCQkJCQkJCQk8IS0tIDEzLjA0LVJFQUNUSU9OLCAgT3B0aW9uYWwsIFJlcGVhdGFibGUgLS0+DQoJCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgUmVxdWlyZWQgQ29kZSB1bmRlciBPYnNlcnZhdGlvbiAtLT4NCgkJCQkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFJlcXVpcmVkIHN0YXR1c0NvZGUgdW5kZXIgT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJPCEtLSAxMy4wNC1SRUFDVElPTiwgIFBvaW50ZXIgdG8gSU1NVU5JWkFUSU9OIE5BUlJBVElWRSBCTE9DSyBub3QgQWxsZXJneSBFbnRyeSBwZXIgSUhFIFRlbXBsYXRlIC0tPg0KCQkJCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjaW5kUmVhY3Rpb241IiAvPg0KCQkJCQkJCQkJCTwvdGV4dD4NCgkJCQkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIElIRSBUZW1wbGF0ZSByZXF1aXJlcyBsb3cgdmFsdWUgZW50cnkgLS0+DQoJCQkJCQkJCQkJPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSUhFIFRlbXBsYXRlIHJlcXVpcmVzIHZhbHVlIGVudHJ5IC0tPg0KCQkJCQkJCQkJCTx2YWx1ZSBudWxsRmxhdm9yPSJVTksiIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCgkJCQkJCTwvZW50cnk+PGVudHJ5IHR5cGVDb2RlPSJEUklWIj4gPCEtLSBSZXBlYXQgZW50cnkvc3Vic3RhbmNlQWRtaW5zdHJhdGlvbiBibG9jayBmb3IgZWFjaCBJbW11bml6YXRpb24gLS0+DQoJCQkJCQkJPCEtLSAxMy4wMS1SRUZVU0FMLCBSRVFVSVJFRCwgc3RhdGljIHZhbHVlIG9mICJmYWxzZSIgLS0+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEhMNyBDREEgUjItSWYgSW1tdW5pemF0aW9uIHdhcyBhZG1pbmlzdGVyZWQsIEBuZWdhdGlvbkluZD1mYWxzZSAtLT4NCgkJCQkJCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiIgbmVnYXRpb25JbmQ9ImZhbHNlIj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBUZW1wbGF0ZXMgIC0tPg0KCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI0IiAvPg0KCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjEzIiAvPg0KCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMTIiIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IEltbXVuaXphdGlvbiBJZCBhcyBudWxsRmxhdm9yICAtLT4NCgkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGNvZGUgY29kZT0iSU1NVU5JWiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40IiBjb2RlU3lzdGVtTmFtZT0iQWN0Q29kZSIgLz4NCgkJCQkJCQkJPCEtLSBDT01NRU5UIFJFRkVSRU5DRSBwb2ludHMgdG8gTmFycmF0aXZlIEJsb2NrIC0tPg0KCQkJCQkJCQk8dGV4dD48cmVmZXJlbmNlIHZhbHVlPSIjaW5kQ29tbWVudHM2IiAvPjwvdGV4dD4NCgkJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCQk8IS0tIDEzLjAyLUFETUlOSVNURVJFRCBEQVRFLCBSRVFVSVJFRCwgIC0tPg0KCQkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAxMTExMDEiIC8+DQoJCQkJCQkJCTxjb25zdW1hYmxlPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBNZWRpY2F0aW9uICAtLT4NCgkJCQkJCQkJCTxtYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJCQkJCQkJCTwhLS0gUHJvZHVjdCB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUzIiAvPiANCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNy4yIiAvPg0KCQkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJCTwhLS1tYW51ZmFjdHVyZWRMYWJlbGVkRHJ1Zz48L21hbnVmYWN0dXJlZExhYmVsZWREcnVnIC0tPg0KCQkJCQkJCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQkJCQkJCTwhLS0gMTMuMDYtQ09ERUQgUFJPRFVDVCBOQU1FLCBPcHRpb25hbCwgbnVsbEZsYXZvciBiL2MgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSB0aHJ1IFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBDT0RFRCBQUk9EVUNUIE5BTUUsIE9wdGlvbmFsLCBSZXF1aXJlcyBDVlgtVmFjY2luZXMgQWRtaW5zdGVyZWQgLCBWQSBwcm92aWRlcyBDUFQtNC0tPg0KCQkJCQkJCQkJCQkJPGNvZGUgY29kZT0iVU5LIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjU5IiBjb2RlU3lzdGVtTmFtZT0iQ1ZYIiBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJCQkJCQkJCTwhLS0gMTMuMDctRlJFRSBURVhUUFJPRFVDVCBOQU1FLCBSRVFVSVJFRCwgUG9pbnRlciB0byBOYXJyYXRpdmUgQmxvY2sgIC0tPg0KCQkJCQkJCQkJCQkJCTxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNpbmRJbW11bml6YXRpb242IiAvPg0KCQkJCQkJCQkJCQkJCTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJCQkJCQ0KCQkJCQkJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCQkJCQkJPCEtLSAxMy4wOS1MT1QgTlVNQkVSLCBPcHRpb25hbCwgWE1MIG9taXR0ZWQgYi9jIG5vdCB5ZXQgIGRhdGEgYXZhaWxhYmxlIHRocnUgVmlzdEEgUlBDcyAtLT4NCgkJCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQkJCQkJCQkJPG1hbnVmYWN0dXJlck9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQkJCTwhLS0gMTMuMDggRFJVRyBNQU5VRkFDVFVSRVIsIE9wdGlvbmFsLCBYTUwgb21pdHRlZCBiL2Mgbm90IHlldCBkYXRhIGF2YWlsYWJsZSB0aHJ1IFZpc3RBIFJQQ3MgLS0+DQoJCQkJCQkJCQkJCTwvbWFudWZhY3R1cmVyT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJCQkJCQk8L2NvbnN1bWFibGU+DQoJCQkJCQkJCTwhLS0gMTMuMDUtUEVSRk9STUVSLCBPcHRpb25hbCAgLS0+DQoJCQkJCQkJCTxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQoJCQkJCQkJCQk8IS0tIFByb3ZpZGVyIFRlbXBsYXRlIElkICAtLT4NCgkJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuNCIgLz4NCgkJCQkJCQkJCTx0aW1lPg0KCQkJCQkJCQkJCSA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8L3RpbWU+DQoJCQkJCQkJCQk8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCQk8IS0tIFByb3ZpZGVyIElELCBleHRlbnNpb24gPSBQcm92aWRlciBJRCwgcm9vdD1WQSBPSUQgIC0tPg0KCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjU1ODciIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQkJPG5hbWU+UHJvdmlkZXIsIE9uZTwvbmFtZT4NCgkJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPC9hc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJPC9wZXJmb3JtZXI+DQoJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBJTU1VTklaQVRJT04sIE9wdGlvbmFsIC0tPgkNCgkJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEF1dGhvciwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEM4MyBhdXRob3IvYXNzaWduZWRQZXJzb24vTmFtZSAgUmVxdWlyZWQgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBPSUQgKElEID0gVkEgT0lELCBFWFQgPSBUUkVBVElORyBGQUNJTElUWSBOQlIpIC0tPg0KCQkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIEltbXVuaXphdGlvbiBNZWRpY2F0aW9uIFNlcmllcyBOYnIgLS0+DQoJCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+IA0KCQkJCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ2IiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBSZXF1aXJlZCBDb2RlIHVuZGVyIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCTxjb2RlIGNvZGU9IjMwOTczLTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgY29kZVN5c3RlbU5hbWU9IkxPSU5DIiBkaXNwbGF5TmFtZT0iRG9zZSBOdW1iZXIiIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogIFJlcXVpcmVkIHN0YXR1c0NvZGUgdW5kZXIgT2JzZXJ2YXRpb24gLS0+DQoJCQkJCQkJCQkJICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJCQkJPCEtLSAxMy4wMy1NRURJQ0FUSU9OIFNFUklFUyBOVU1CRVIsICBPcHRpb25hbCwgU2VudCBhcyBTVHJpbmcgbm90IElOVGVnZXIgIHRvIGFjY29tbW9kYXRlIFZBIFZpc3RBIGRhdGEgc3VjaCBhcyBQLVBhcnRpYWwsIEItQm9vc3RlciwgQy1Db21wbGV0ZSAtLT4NCgkJCQkJCQkJCQk8dmFsdWUgbnVsbEZsYXZvcj0iVU5LIiB4c2k6dHlwZT0iSU5UIiAvPg0KCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4JDQoJCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJbW11bml6YXRpb24gUmVhY3Rpb24gIC0tPg0KCQkJCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgaW52ZXJzaW9uSW5kPSJmYWxzZSIgdHlwZUNvZGU9IkNBVVMiPiAgPCEtLSBSZXBlYXQgZW50cnlSZWxhdGlvbnNoaXAvb2JzZXJ2YXRpb24gYmxvY2sgZm9yIGVhY2ggaW1tdW5peiByZWFjdGlvbiAtLT4NCgkJCQkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjU0IiAvPg0KCQkJCQkJCQkJCTwhLS0gMTMuMDQtUkVBQ1RJT04sICBPcHRpb25hbCwgUmVwZWF0YWJsZSAtLT4NCgkJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBSZXF1aXJlZCBDb2RlIHVuZGVyIE9ic2VydmF0aW9uIC0tPg0KCQkJCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgUmVxdWlyZWQgc3RhdHVzQ29kZSB1bmRlciBPYnNlcnZhdGlvbiAtLT4NCgkJCQkJCQkJCQk8IS0tIDEzLjA0LVJFQUNUSU9OLCAgUG9pbnRlciB0byBJTU1VTklaQVRJT04gTkFSUkFUSVZFIEJMT0NLIG5vdCBBbGxlcmd5IEVudHJ5IHBlciBJSEUgVGVtcGxhdGUgLS0+DQoJCQkJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNpbmRSZWFjdGlvbjYiIC8+DQoJCQkJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgSUhFIFRlbXBsYXRlIHJlcXVpcmVzIGxvdyB2YWx1ZSBlbnRyeSAtLT4NCgkJCQkJCQkJCQk8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICBJSEUgVGVtcGxhdGUgcmVxdWlyZXMgdmFsdWUgZW50cnkgLS0+DQoJCQkJCQkJCQkJPHZhbHVlIG51bGxGbGF2b3I9IlVOSyIgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KCQkJCQkJPC9lbnRyeT4NCgkJCQkJPC9zZWN0aW9uPg0KCQkJCTwvY29tcG9uZW50Pg0KCQkJPCEtLSANCgkJCSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoJCQlOSElOX0NSXzEwMSwgQ1IxMDANCgkJCVZMRVIgU2VnbWVudCAxQmlpOiAgRU5DT1VOVEVSIFNFQ1RJT04gDQogICAgICAgICAgIAkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCQkJLS0+DQoJCQk8Y29tcG9uZW50PiA8IS0tIENvbXBvbmVudCA3IC0tPg0KCQkJCTxzZWN0aW9uPg0KCQkJCTwhLS1DQ0QgRW5jb3VudGVycyBTZWN0aW9uIENvbmZvcm1hbmNlIElkZW50aWZpZXItLT4NCgkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMyIgLz4NCgkJCQkgIDwhLS1DODMgRW5jb3VudGVycyBTZWN0aW9uIENvbmZvcm1hbmNlIElkZW50aWZpZXItLT4NCgkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTI3IiAvPg0KCQkJCSAgPCEtLUlIRSBFbmNvdW50ZXJzIEhpc3RvcnkgU2VjdGlvbiBDb25mb3JtYW5jZSBJZGVudGlmaWVyLS0+DQoJCQkJICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjEuNS4zLjMiIC8+DQoJCQkJICA8Y29kZSBjb2RlPSI0NjI0MC04IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGNvZGVTeXN0ZW1OYW1lPSJMT0lOQyIgZGlzcGxheU5hbWU9Ikhpc3Rvcnkgb2YgRW5jb3VudGVycyIgLz4NCgkJCQkgIDx0aXRsZT5IaXN0b3J5IG9mIEVuY291bnRlcnM8L3RpdGxlPg0KCQkJCSAgPCEtLSAgRU5DT1VOVEVSIE5BUlJBVElWRSBCTE9DSyAtLT4NCiAgICAgICAgICAgICAgICAgICAgPHRleHQ+DQogICAgICAgICAgICAgICAgICAgICAgICA8IS0tIFZMRVIgU0VHIDFCOiBFbmNvdW50ZXIgQnVzaW5lc3MgUnVsZXMgZm9yIE1lZGljYWwgQ29udGVudCAgLS0+DQogICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+DQoJCQkJCQkJPHRoZWFkPg0KCQkJCQkJCQk8dHI+DQoJCQkJCQkJCQk8dGg+RGVwYXJ0bWVudCBvZiBWZXRlcmFucyBBZmZhaXJzPC90aD4NCgkJCQkJCQkJCTx0aD5CdXNpbmVzcyBSdWxlcyBmb3IgQ29uc3RydWN0aW9uIG9mIEVuY291bnRlciBJbmZvcm1hdGlvbjwvdGg+DQoJCQkJCQkJCTwvdHI+DQoJCQkJCQkJPC90aGVhZD4NCgkJCQkJCQk8dGJvZHk+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0ZD5FbmNvdW50ZXJzPC90ZD4NCgkJCQkJCQkJCTx0ZD5UaGlzIHNlY3Rpb24gY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIHRoZSAyNSBtb3N0IHJlY2VudCBoaXN0b3JpY2FsIG91dHBhdGllbnQgZW5jb3VudGVycyAoY29tcGxldGVkKSBmb3IgdGhlIHBhdGllbnQgZnJvbSBhbGwgVkEgdHJlYXRtZW50IGZhY2lsaXRpZXMgZm9yIHdoaWNoIHRoZSBlbmNvdW50ZXIgZGF0ZSB3YXMgd2l0aGluIHRoZSBsYXN0IDM2IG1vbnRocy4gTm90ZTogQW5jaWxsYXJ5IHZpc2l0cyBhcmUgbm90IGluY2x1ZGVkLiBMaXN0cyBvZiBhc3NvY2lhdGVkIG5vdGUgdGl0bGVzIGZvciBlYWNoIGVuY291bnRlciBhcmUgbGltaXRlZCB0byBhIG1heGltdW0gb2YgMTAuPC90ZD4NCgkJCQkJCQkJPC90cj4NCgkJCQkJCQk8L3Rib2R5Pg0KCQkJCQkJPC90YWJsZT4NCgkJCQkJCTx0YWJsZSBJRD0iZW5jb3VudGVyTmFycml0aXZlIiBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCQkJCQk8dGhlYWQ+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0aD5EYXRlIFRpbWU8L3RoPg0KCQkJCQkJCQkJPHRoPkVuY291bnRlciBUeXBlPC90aD4NCgkJCQkJCQkJCTx0aD5FbmNvdW50ZXIgRGVzY3JpcHRpb248L3RoPg0KCQkJCQkJCQkJPHRoPlJlYXNvbjwvdGg+DQoJCQkJCQkJCQk8dGg+QXJyaXZhbDwvdGg+DQoJCQkJCQkJCQk8dGg+RGVwYXJ0dXJlPC90aD4NCgkJCQkJCQkJCTx0aD5Qcm92aWRlcjwvdGg+DQoJCQkJCQkJCQk8dGg+U291cmNlPC90aD4NCgkJCQkJCQkJPC90cj4NCgkJCQkJCQk8L3RoZWFkPg0KCQkJCQkJCTx0Ym9keT4NCgkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmREYXRlVGltZTEiPjIwMTIxMjEwMTcxNjEyPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRW5jb3VudGVyVHlwZTEiPk9GRklDRS9PVVRQQVRJRU5UIFZJU0lUIEVTVDwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZEVuY291bnRlckRlc2NyaXB0aW9uMSI+UFJJTUFSWSBDQVJFL01FRElDSU5FIHdpdGggYXNzb2NpYXRlZCBub3RlcyBOVVRSSVRJT04gUFJPQ0VEVVJFIE5PVEU8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRSZWFzb24xIj5DT1VHSCBJQ0Q5IDc4Ni4yIHdpdGggUHJvdmlkZXIgQ29tbWVudHMgQ291Z2ggKElDRC05LUNNIDc4Ni4yKTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZEFycml2YWwxIiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRGVwYXR1cmUxIiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kUHJvdmlkZXIxIj5Qcm92aWRlciwgT25lPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kU291cmNlMSI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmREYXRlVGltZTIiPjIwMTIwMjAxMTAzODU4PC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRW5jb3VudGVyVHlwZTIiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRFbmNvdW50ZXJEZXNjcmlwdGlvbjIiPlBSSU1BUlkgQ0FSRS9NRURJQ0lORTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZFJlYXNvbjIiPlVOU1BFQ0lGSUVEIERJU09SREVSIE9GIEVZRSBNT1ZFTUVOVFMgSUNEOSAzNzguOSB3aXRoIFByb3ZpZGVyIENvbW1lbnRzIEEgcGF0dGVybiBzdHJhYmlzbXVzIChTTk9NRUQgQ1QgNDEzMzgwMDA0KTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZEFycml2YWwyIiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRGVwYXR1cmUyIiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kUHJvdmlkZXIyIj5Qcm92aWRlciwgT25lPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kU291cmNlMiI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmREYXRlVGltZTMiPjIwMTIwMTExMTU1OTUwPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRW5jb3VudGVyVHlwZTMiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRFbmNvdW50ZXJEZXNjcmlwdGlvbjMiPkdFTkVSQUwgSU5URVJOQUwgTUVESUNJTkU8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRSZWFzb24zIiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kQXJyaXZhbDMiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmREZXBhdHVyZTMiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRQcm92aWRlcjMiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRTb3VyY2UzIj5DSEVZRU5ORSBWQU1DPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJPC90cj48dHI+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZERhdGVUaW1lNCI+MjAxMjAxMTAxMzQ1MzY8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRFbmNvdW50ZXJUeXBlNCIgLz4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZEVuY291bnRlckRlc2NyaXB0aW9uNCI+QURNSU4gUEFUIEFDVElWVElFUyAoTUFTTk9OQ1QpPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kUmVhc29uNCIgLz4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZEFycml2YWw0IiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRGVwYXR1cmU0IiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kUHJvdmlkZXI0IiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kU291cmNlNCI+Q0hFWUVOTkUgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmREYXRlVGltZTUiPjIwMTExMTAyMTQyNjA0PC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRW5jb3VudGVyVHlwZTUiIC8+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRFbmNvdW50ZXJEZXNjcmlwdGlvbjUiPlBSSU1BUlkgQ0FSRS9NRURJQ0lORSB3aXRoIGFzc29jaWF0ZWQgbm90ZXMgUkVGRVJSQUwgTk9URTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZFJlYXNvbjUiPlJIRVVNQVRPSUQgQVJUSFJJVElTIElDRDkgNzE0LjAgd2l0aCBQcm92aWRlciBDb21tZW50cyBBcnRocml0aXMsIFJoZXVtYXRvaWQ8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRBcnJpdmFsNSIgLz4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZERlcGF0dXJlNSIgLz4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZFByb3ZpZGVyNSI+UHJvdmlkZXIsIE9uZTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZFNvdXJjZTUiPk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRGF0ZVRpbWU2Ij4yMDExMTEwMTA4MDI0MTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZEVuY291bnRlclR5cGU2IiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0iZW5kRW5jb3VudGVyRGVzY3JpcHRpb242Ij5QUklNQVJZIENBUkUvTUVESUNJTkU8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRSZWFzb242Ij5PQkVTSVRZLCBVTlNQRUNJRklFRCBJQ0Q5IDI3OC4wMCB3aXRoIFByb3ZpZGVyIENvbW1lbnRzIE9iZXNpdHkgaW4gRGlhYmV0ZXM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJlbmRBcnJpdmFsNiIgLz4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZERlcGF0dXJlNiIgLz4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZFByb3ZpZGVyNiI+UHJvdmlkZXIsIE9uZTwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9ImVuZFNvdXJjZTYiPk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPg0KCQkJCQkJCTwvdGJvZHk+DQoJCQkJCQk8L3RhYmxlPg0KICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSAgQ0RBIE9ic2VydmF0aW9uIFRleHQgYXMgYSBSZWZlcmVuY2UgdGFnIC0tPg0KCQkJCQkJPGNvbnRlbnQgSUQ9ImVuY05vdGUtMSIgcmV2aXNlZD0iZGVsZXRlIj5JSEUgRW5jb3VudGVyIFRlbXBsYXRlIFRleHQgbm90IHVzZWQgYnkgVkE8L2NvbnRlbnQ+DQoJCQkJCTwvdGV4dD4NCgkJCQkgIDxlbnRyeT4gPCEtLSBFbnRyeSBibG9jayByZXBlYXRzIGZvciBlYWNoIEVuY291bnRlciAtLT4NCgkJCQkJPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCSAgPCEtLUNDRCBFbmNvdW50ZXIgQWN0aXZpdHktLT4NCgkJCQkJICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjIxIiAvPg0KCQkJCQkgIDwhLS1DODMgRW5jb3VudGVyIEVudHJ5LS0+DQoJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNiIgLz4NCgkJCQkJICA8IS0tSUhFIEVuY291bnRlciBFbnRyeS0tPg0KCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xNCIgLz4NCgkJCQkJICA8IS0tMTYuMDEgLSBFTkNPVU5URVIgSUQsICBSRVFVSVJFRCAtLT4NCgkJCQkJICA8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQk8IS0tICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIGV4dGVuc2lvbj0iZW5jMTIzNCIvPi0tPg0KCQkJCQkgIDwhLS0xNi4wMiAtIEVOQ09VTlRFUiBUWVBFLCBSMi1PcHRpb25hbCwgIFZBIFByb3ZpZGVzIENQVCAtLT4NCgkJCQkJICA8IS0tMTYuMDIgLSBXaGVuIENQVCBjb2RlIG5vdCBwcmVzZW50LCB0aGVuIGNvZGUgbnVsbEZsYXZvcj0iVU5LIiAtLT4NCgkJCQkJICA8Y29kZSBjb2RlPSI5OTIxMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMiIgY29kZVN5c3RlbU5hbWU9IkNQVC00IiBkaXNwbGF5TmFtZT0iT0ZGSUNFL09VVFBBVElFTlQgVklTSVQgRVNUIj4NCgkJCQkJCTwhLS0xNi4wMyAtIEVOQ09VTlRFUiBGUkVFIFRFWFQgVFlQRSwgUkVRVUlSRUQtLT4NCgkJCQkJCTxvcmlnaW5hbFRleHQ+DQoJCQkJCQkgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmRFbmNvdW50ZXJEZXNjcmlwdGlvbjEiIC8+DQoJCQkJCQk8L29yaWdpbmFsVGV4dD4NCgkJCQkJICA8L2NvZGU+DQoJCQkJCSAgPCEtLSBSZXF1aXJlZCBwZXIgSUhFIFRlbXBsYXRlLCBub3QgdXNlIGJ5IFZBICAtLT4NCgkJCQkJICA8dGV4dD4NCgkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNlbmNOb3RlLTEiIC8+DQoJCQkJCSAgPC90ZXh0Pg0KCQkJCQkgIDwhLS0xNi4wNCAtIEVOQ09VTlRFUiBEQVRFIC8gVElNRSwgUkVRVUlSRUQtLT4NCgkJCQkJICA8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCTxsb3cgdmFsdWU9IjIwMTIxMjEwMTcxNjEyIiAvPg0KCQkJCQkgIDwvZWZmZWN0aXZlVGltZT4NCgkJCQkJICA8IS0tMTYuMDcgLSBBRE1JU1NJT04gVFlQRSwgT3B0aW9uYWwsICBWQSBWaXN0QSBEYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkgICAgPHByaW9yaXR5Q29kZSBudWxsRmxhdm9yPSJVTksiIC8+CQ0KCQkJCQkgIDwhLS0xNi4wNSAtIEVOQ09VTlRFUiBQUk9WSURFUiwgUjItT3B0aW9uYWwgLS0+DQoJCQkJCSAgCTxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQoJCQkJCQkJPCEtLSBQcm92aWRlciBUZW1wbGF0ZSBJZCAgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS4zMi40IiAvPg0KCQkJCQkJCTx0aW1lPg0KCQkJCQkJCQk8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPC90aW1lPg0KCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJPCEtLSBQcm92aWRlciBJRCBudWxsRmxhdm9yPSJVTksiIGIvYyBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPHRlbGVjb20gLz4gDQoJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCTxuYW1lPlByb3ZpZGVyLCBPbmU8L25hbWU+DQoJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJPC9hc3NpZ25lZEVudGl0eT4NCgkJCQkJCTwvcGVyZm9ybWVyPg0KCQkJCQkgIDwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBFTkNPVU5URVIsIE9wdGlvbmFsIC0tPg0KCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQk8IS0tICBBREQgVElNRSBUTyBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEVOQ09VTlRFUiAtLT4NCgkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQzgzIGF1dGhvci9hc3NpZ25lZFBlcnNvbi9OYW1lICBSZXF1aXJlZCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPG5hbWUgLz4NCgkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCTwvYXV0aG9yPg0KCQkJCQkgIDwhLS0xNi4wNiAtIEFETUlTU0lPTiBTT1VSQ0UsIE9wdGlvbmFsLCBOb3QgWWV0IEF2YWlsYWJsZSBmcm9tIFZBIFZpc3RBIC0tPg0KCQkJCQkgIDwhLS0xNi4xMSAtIEZBQ0lMSVRZIExPQ0FUSU9OLCBPcHRpb25hbCAtLT4NCgkJCQkJICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQoJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ1IiAvPg0KCQkJCQkJPCEtLTE2LjIwIC0gSU4gRkFDSUxJVFkgTE9DQVRJT04gRFVSQVRJT04sIE9wdGlvbmFsIC0tPg0KCQkJCQkJPHRpbWU+DQoJCQkJCQkgIDwhLS0xNi4xMiAtIEFSUklWQUwgREFURS9USU1FLCBPcHRpb25hbCAtLT4NCgkJCQkJCSAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDwhLS0gMTYuMTIgLSBERVBBUlRVUkUgREFURS9USU1FLCBPcHRpb25hbCAtLT4NCgkJCQkJCSAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJPC90aW1lPg0KCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCgkJCQkJCSAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiIC8+DQoJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCQkJICA8L3BhcnRpY2lwYW50Pg0KCQkJCQkgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCSAgPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPGNvZGUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8IS0tMTYuMTMgLSBSRUFTT04gRk9SIFZJU0lULCBPcHRpb25hbCAtLT4NCgkJCQkJCSAgPHRleHQ+DQoJCQkJCQkJICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5kUmVhc29uMSIgLz4NCgkJCQkJCSAgPC90ZXh0Pg0KCQkJCQkJICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkgIDxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkgPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCSAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJPC9lbmNvdW50ZXI+DQoJCQkJICA8L2VudHJ5PjxlbnRyeT4gPCEtLSBFbnRyeSBibG9jayByZXBlYXRzIGZvciBlYWNoIEVuY291bnRlciAtLT4NCgkJCQkJPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCSAgPCEtLUNDRCBFbmNvdW50ZXIgQWN0aXZpdHktLT4NCgkJCQkJICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjIxIiAvPg0KCQkJCQkgIDwhLS1DODMgRW5jb3VudGVyIEVudHJ5LS0+DQoJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNiIgLz4NCgkJCQkJICA8IS0tSUhFIEVuY291bnRlciBFbnRyeS0tPg0KCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xNCIgLz4NCgkJCQkJICA8IS0tMTYuMDEgLSBFTkNPVU5URVIgSUQsICBSRVFVSVJFRCAtLT4NCgkJCQkJICA8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQk8IS0tICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIGV4dGVuc2lvbj0iZW5jMTIzNCIvPi0tPg0KCQkJCQkgIDwhLS0xNi4wMiAtIEVOQ09VTlRFUiBUWVBFLCBSMi1PcHRpb25hbCwgIFZBIFByb3ZpZGVzIENQVCAtLT4NCgkJCQkJICA8IS0tMTYuMDIgLSBXaGVuIENQVCBjb2RlIG5vdCBwcmVzZW50LCB0aGVuIGNvZGUgbnVsbEZsYXZvcj0iVU5LIiAtLT4NCgkJCQkJICA8Y29kZSBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJPCEtLTE2LjAzIC0gRU5DT1VOVEVSIEZSRUUgVEVYVCBUWVBFLCBSRVFVSVJFRC0tPg0KCQkJCQkJPG9yaWdpbmFsVGV4dD4NCgkJCQkJCSAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuZEVuY291bnRlckRlc2NyaXB0aW9uMiIgLz4NCgkJCQkJCTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkgIDwvY29kZT4NCgkJCQkJICA8IS0tIFJlcXVpcmVkIHBlciBJSEUgVGVtcGxhdGUsIG5vdCB1c2UgYnkgVkEgIC0tPg0KCQkJCQkgIDx0ZXh0Pg0KCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY05vdGUtMSIgLz4NCgkJCQkJICA8L3RleHQ+DQoJCQkJCSAgPCEtLTE2LjA0IC0gRU5DT1VOVEVSIERBVEUgLyBUSU1FLCBSRVFVSVJFRC0tPg0KCQkJCQkgIDxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJPGxvdyB2YWx1ZT0iMjAxMjAyMDExMDM4NTgiIC8+DQoJCQkJCSAgPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkgIDwhLS0xNi4wNyAtIEFETUlTU0lPTiBUWVBFLCBPcHRpb25hbCwgIFZBIFZpc3RBIERhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCSAgICA8cHJpb3JpdHlDb2RlIG51bGxGbGF2b3I9IlVOSyIgLz4JDQoJCQkJCSAgPCEtLTE2LjA1IC0gRU5DT1VOVEVSIFBST1ZJREVSLCBSMi1PcHRpb25hbCAtLT4NCgkJCQkJICAJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCgkJCQkJCQk8IS0tIFByb3ZpZGVyIFRlbXBsYXRlIElkICAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQoJCQkJCQkJPHRpbWU+DQoJCQkJCQkJCTxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8L3RpbWU+DQoJCQkJCQkJPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQk8IS0tIFByb3ZpZGVyIElEIG51bGxGbGF2b3I9IlVOSyIgYi9jIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8dGVsZWNvbSAvPiANCgkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPG5hbWU+UHJvdmlkZXIsIE9uZTwvbmFtZT4NCgkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJCQkJPC9wZXJmb3JtZXI+DQoJCQkJCSAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEVOQ09VTlRFUiwgT3B0aW9uYWwgLS0+DQoJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCTwhLS0gIEFERCBUSU1FIFRPIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRU5DT1VOVEVSIC0tPg0KCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBDODMgYXV0aG9yL2Fzc2lnbmVkUGVyc29uL05hbWUgIFJlcXVpcmVkIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJPC9hdXRob3I+DQoJCQkJCSAgPCEtLTE2LjA2IC0gQURNSVNTSU9OIFNPVVJDRSwgT3B0aW9uYWwsIE5vdCBZZXQgQXZhaWxhYmxlIGZyb20gVkEgVmlzdEEgLS0+DQoJCQkJCSAgPCEtLTE2LjExIC0gRkFDSUxJVFkgTE9DQVRJT04sIE9wdGlvbmFsIC0tPg0KCQkJCQkgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iTE9DIj4NCgkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDUiIC8+DQoJCQkJCQk8IS0tMTYuMjAgLSBJTiBGQUNJTElUWSBMT0NBVElPTiBEVVJBVElPTiwgT3B0aW9uYWwgLS0+DQoJCQkJCQk8dGltZT4NCgkJCQkJCSAgPCEtLTE2LjEyIC0gQVJSSVZBTCBEQVRFL1RJTUUsIE9wdGlvbmFsIC0tPg0KCQkJCQkJICA8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPCEtLSAxNi4xMiAtIERFUEFSVFVSRSBEQVRFL1RJTUUsIE9wdGlvbmFsIC0tPg0KCQkJCQkJICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQk8L3RpbWU+DQoJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iU0RMT0MiPg0KCQkJCQkJICA8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9IlBMQyIgLz4NCgkJCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJCQkgIDwvcGFydGljaXBhbnQ+DQoJCQkJCSAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSU09OIj4NCgkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJICA8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8Y29kZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDwhLS0xNi4xMyAtIFJFQVNPTiBGT1IgVklTSVQsIE9wdGlvbmFsIC0tPg0KCQkJCQkJICA8dGV4dD4NCgkJCQkJCQkgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmRSZWFzb24yIiAvPg0KCQkJCQkJICA8L3RleHQ+DQoJCQkJCQkgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCSAgPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCSA8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQk8L2VuY291bnRlcj4NCgkJCQkgIDwvZW50cnk+PGVudHJ5PiA8IS0tIEVudHJ5IGJsb2NrIHJlcGVhdHMgZm9yIGVhY2ggRW5jb3VudGVyIC0tPg0KCQkJCQk8ZW5jb3VudGVyIGNsYXNzQ29kZT0iRU5DIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJICA8IS0tQ0NEIEVuY291bnRlciBBY3Rpdml0eS0tPg0KCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjEiIC8+DQoJCQkJCSAgPCEtLUM4MyBFbmNvdW50ZXIgRW50cnktLT4NCgkJCQkJICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjE2IiAvPg0KCQkJCQkgIDwhLS1JSEUgRW5jb3VudGVyIEVudHJ5LS0+DQoJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjE0IiAvPg0KCQkJCQkgIDwhLS0xNi4wMSAtIEVOQ09VTlRFUiBJRCwgIFJFUVVJUkVEIC0tPg0KCQkJCQkgIDxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCTwhLS0gIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgZXh0ZW5zaW9uPSJlbmMxMjM0Ii8+LS0+DQoJCQkJCSAgPCEtLTE2LjAyIC0gRU5DT1VOVEVSIFRZUEUsIFIyLU9wdGlvbmFsLCAgVkEgUHJvdmlkZXMgQ1BUIC0tPg0KCQkJCQkgIDwhLS0xNi4wMiAtIFdoZW4gQ1BUIGNvZGUgbm90IHByZXNlbnQsIHRoZW4gY29kZSBudWxsRmxhdm9yPSJVTksiIC0tPg0KCQkJCQkgIDxjb2RlIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQk8IS0tMTYuMDMgLSBFTkNPVU5URVIgRlJFRSBURVhUIFRZUEUsIFJFUVVJUkVELS0+DQoJCQkJCQk8b3JpZ2luYWxUZXh0Pg0KCQkJCQkJICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5kRW5jb3VudGVyRGVzY3JpcHRpb24zIiAvPg0KCQkJCQkJPC9vcmlnaW5hbFRleHQ+DQoJCQkJCSAgPC9jb2RlPg0KCQkJCQkgIDwhLS0gUmVxdWlyZWQgcGVyIElIRSBUZW1wbGF0ZSwgbm90IHVzZSBieSBWQSAgLS0+DQoJCQkJCSAgPHRleHQ+DQoJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjZW5jTm90ZS0xIiAvPg0KCQkJCQkgIDwvdGV4dD4NCgkJCQkJICA8IS0tMTYuMDQgLSBFTkNPVU5URVIgREFURSAvIFRJTUUsIFJFUVVJUkVELS0+DQoJCQkJCSAgPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQk8bG93IHZhbHVlPSIyMDEyMDExMTE1NTk1MCIgLz4NCgkJCQkJICA8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCSAgPCEtLTE2LjA3IC0gQURNSVNTSU9OIFRZUEUsIE9wdGlvbmFsLCAgVkEgVmlzdEEgRGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJICAgIDxwcmlvcml0eUNvZGUgbnVsbEZsYXZvcj0iVU5LIiAvPgkNCgkJCQkJICA8IS0tMTYuMDUgLSBFTkNPVU5URVIgUFJPVklERVIsIFIyLU9wdGlvbmFsIC0tPg0KCQkJCQkgIAkNCgkJCQkJICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRU5DT1VOVEVSLCBPcHRpb25hbCAtLT4NCgkJCQkJCTxhdXRob3I+DQoJCQkJCQkJPCEtLSAgQUREIFRJTUUgVE8gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBFTkNPVU5URVIgLS0+DQoJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEM4MyBhdXRob3IvYXNzaWduZWRQZXJzb24vTmFtZSAgUmVxdWlyZWQgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI0NDIiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCTxuYW1lPkNIRVlFTk5FIFZBTUM8L25hbWU+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQk8L2F1dGhvcj4NCgkJCQkJICA8IS0tMTYuMDYgLSBBRE1JU1NJT04gU09VUkNFLCBPcHRpb25hbCwgTm90IFlldCBBdmFpbGFibGUgZnJvbSBWQSBWaXN0QSAtLT4NCgkJCQkJICA8IS0tMTYuMTEgLSBGQUNJTElUWSBMT0NBVElPTiwgT3B0aW9uYWwgLS0+DQoJCQkJCSAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJMT0MiPg0KCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NSIgLz4NCgkJCQkJCTwhLS0xNi4yMCAtIElOIEZBQ0lMSVRZIExPQ0FUSU9OIERVUkFUSU9OLCBPcHRpb25hbCAtLT4NCgkJCQkJCTx0aW1lPg0KCQkJCQkJICA8IS0tMTYuMTIgLSBBUlJJVkFMIERBVEUvVElNRSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkgIDxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8IS0tIDE2LjEyIC0gREVQQVJUVVJFIERBVEUvVElNRSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCTwvdGltZT4NCgkJCQkJCTxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJTRExPQyI+DQoJCQkJCQkgIDxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iUExDIiAvPg0KCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQkJCSAgPC9wYXJ0aWNpcGFudD4NCgkJCQkJICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkgIDxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDxjb2RlIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPCEtLTE2LjEzIC0gUkVBU09OIEZPUiBWSVNJVCwgT3B0aW9uYWwgLS0+DQoJCQkJCQkgIDx0ZXh0Pg0KCQkJCQkJCSAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuZFJlYXNvbjMiIC8+DQoJCQkJCQkgIDwvdGV4dD4NCgkJCQkJCSAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJICA8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJIDx2YWx1ZSB4c2k6dHlwZT0iQ0QiIC8+DQoJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCTwvZW5jb3VudGVyPg0KCQkJCSAgPC9lbnRyeT48ZW50cnk+IDwhLS0gRW50cnkgYmxvY2sgcmVwZWF0cyBmb3IgZWFjaCBFbmNvdW50ZXIgLS0+DQoJCQkJCTxlbmNvdW50ZXIgY2xhc3NDb2RlPSJFTkMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkgIDwhLS1DQ0QgRW5jb3VudGVyIEFjdGl2aXR5LS0+DQoJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yMSIgLz4NCgkJCQkJICA8IS0tQzgzIEVuY291bnRlciBFbnRyeS0tPg0KCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTYiIC8+DQoJCQkJCSAgPCEtLUlIRSBFbmNvdW50ZXIgRW50cnktLT4NCgkJCQkJICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMTQiIC8+DQoJCQkJCSAgPCEtLTE2LjAxIC0gRU5DT1VOVEVSIElELCAgUkVRVUlSRUQgLS0+DQoJCQkJCSAgPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJPCEtLSAgPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiBleHRlbnNpb249ImVuYzEyMzQiLz4tLT4NCgkJCQkJICA8IS0tMTYuMDIgLSBFTkNPVU5URVIgVFlQRSwgUjItT3B0aW9uYWwsICBWQSBQcm92aWRlcyBDUFQgLS0+DQoJCQkJCSAgPCEtLTE2LjAyIC0gV2hlbiBDUFQgY29kZSBub3QgcHJlc2VudCwgdGhlbiBjb2RlIG51bGxGbGF2b3I9IlVOSyIgLS0+DQoJCQkJCSAgPGNvZGUgbnVsbEZsYXZvcj0iVU5LIj4NCgkJCQkJCTwhLS0xNi4wMyAtIEVOQ09VTlRFUiBGUkVFIFRFWFQgVFlQRSwgUkVRVUlSRUQtLT4NCgkJCQkJCTxvcmlnaW5hbFRleHQ+DQoJCQkJCQkgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmRFbmNvdW50ZXJEZXNjcmlwdGlvbjQiIC8+DQoJCQkJCQk8L29yaWdpbmFsVGV4dD4NCgkJCQkJICA8L2NvZGU+DQoJCQkJCSAgPCEtLSBSZXF1aXJlZCBwZXIgSUhFIFRlbXBsYXRlLCBub3QgdXNlIGJ5IFZBICAtLT4NCgkJCQkJICA8dGV4dD4NCgkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNlbmNOb3RlLTEiIC8+DQoJCQkJCSAgPC90ZXh0Pg0KCQkJCQkgIDwhLS0xNi4wNCAtIEVOQ09VTlRFUiBEQVRFIC8gVElNRSwgUkVRVUlSRUQtLT4NCgkJCQkJICA8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCTxsb3cgdmFsdWU9IjIwMTIwMTEwMTM0NTM2IiAvPg0KCQkJCQkgIDwvZWZmZWN0aXZlVGltZT4NCgkJCQkJICA8IS0tMTYuMDcgLSBBRE1JU1NJT04gVFlQRSwgT3B0aW9uYWwsICBWQSBWaXN0QSBEYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkgICAgPHByaW9yaXR5Q29kZSBudWxsRmxhdm9yPSJVTksiIC8+CQ0KCQkJCQkgIDwhLS0xNi4wNSAtIEVOQ09VTlRFUiBQUk9WSURFUiwgUjItT3B0aW9uYWwgLS0+DQoJCQkJCSAgCQ0KCQkJCQkgIDwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBFTkNPVU5URVIsIE9wdGlvbmFsIC0tPg0KCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQk8IS0tICBBREQgVElNRSBUTyBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEVOQ09VTlRFUiAtLT4NCgkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQzgzIGF1dGhvci9hc3NpZ25lZFBlcnNvbi9OYW1lICBSZXF1aXJlZCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPG5hbWUgLz4NCgkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCTxpZCBleHRlbnNpb249IjQ0MiIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJPG5hbWU+Q0hFWUVOTkUgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCTwvYXV0aG9yPg0KCQkJCQkgIDwhLS0xNi4wNiAtIEFETUlTU0lPTiBTT1VSQ0UsIE9wdGlvbmFsLCBOb3QgWWV0IEF2YWlsYWJsZSBmcm9tIFZBIFZpc3RBIC0tPg0KCQkJCQkgIDwhLS0xNi4xMSAtIEZBQ0lMSVRZIExPQ0FUSU9OLCBPcHRpb25hbCAtLT4NCgkJCQkJICA8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQoJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ1IiAvPg0KCQkJCQkJPCEtLTE2LjIwIC0gSU4gRkFDSUxJVFkgTE9DQVRJT04gRFVSQVRJT04sIE9wdGlvbmFsIC0tPg0KCQkJCQkJPHRpbWU+DQoJCQkJCQkgIDwhLS0xNi4xMiAtIEFSUklWQUwgREFURS9USU1FLCBPcHRpb25hbCAtLT4NCgkJCQkJCSAgPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDwhLS0gMTYuMTIgLSBERVBBUlRVUkUgREFURS9USU1FLCBPcHRpb25hbCAtLT4NCgkJCQkJCSAgPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJPC90aW1lPg0KCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCgkJCQkJCSAgPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiIC8+DQoJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCQkJICA8L3BhcnRpY2lwYW50Pg0KCQkJCQkgIDxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJICA8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuNSIgLz4NCgkJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCIgLz4NCgkJCQkJCSAgPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPGNvZGUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8IS0tMTYuMTMgLSBSRUFTT04gRk9SIFZJU0lULCBPcHRpb25hbCAtLT4NCgkJCQkJCSAgPHRleHQ+DQoJCQkJCQkJICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5kUmVhc29uNCIgLz4NCgkJCQkJCSAgPC90ZXh0Pg0KCQkJCQkJICA8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkgIDxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJCTxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCQkgPHZhbHVlIHhzaTp0eXBlPSJDRCIgLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCSAgPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQkJPC9lbmNvdW50ZXI+DQoJCQkJICA8L2VudHJ5PjxlbnRyeT4gPCEtLSBFbnRyeSBibG9jayByZXBlYXRzIGZvciBlYWNoIEVuY291bnRlciAtLT4NCgkJCQkJPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCSAgPCEtLUNDRCBFbmNvdW50ZXIgQWN0aXZpdHktLT4NCgkJCQkJICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjIxIiAvPg0KCQkJCQkgIDwhLS1DODMgRW5jb3VudGVyIEVudHJ5LS0+DQoJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNiIgLz4NCgkJCQkJICA8IS0tSUhFIEVuY291bnRlciBFbnRyeS0tPg0KCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xNCIgLz4NCgkJCQkJICA8IS0tMTYuMDEgLSBFTkNPVU5URVIgSUQsICBSRVFVSVJFRCAtLT4NCgkJCQkJICA8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQk8IS0tICA8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIGV4dGVuc2lvbj0iZW5jMTIzNCIvPi0tPg0KCQkJCQkgIDwhLS0xNi4wMiAtIEVOQ09VTlRFUiBUWVBFLCBSMi1PcHRpb25hbCwgIFZBIFByb3ZpZGVzIENQVCAtLT4NCgkJCQkJICA8IS0tMTYuMDIgLSBXaGVuIENQVCBjb2RlIG5vdCBwcmVzZW50LCB0aGVuIGNvZGUgbnVsbEZsYXZvcj0iVU5LIiAtLT4NCgkJCQkJICA8Y29kZSBudWxsRmxhdm9yPSJVTksiPg0KCQkJCQkJPCEtLTE2LjAzIC0gRU5DT1VOVEVSIEZSRUUgVEVYVCBUWVBFLCBSRVFVSVJFRC0tPg0KCQkJCQkJPG9yaWdpbmFsVGV4dD4NCgkJCQkJCSAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuZEVuY291bnRlckRlc2NyaXB0aW9uNSIgLz4NCgkJCQkJCTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkgIDwvY29kZT4NCgkJCQkJICA8IS0tIFJlcXVpcmVkIHBlciBJSEUgVGVtcGxhdGUsIG5vdCB1c2UgYnkgVkEgIC0tPg0KCQkJCQkgIDx0ZXh0Pg0KCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI2VuY05vdGUtMSIgLz4NCgkJCQkJICA8L3RleHQ+DQoJCQkJCSAgPCEtLTE2LjA0IC0gRU5DT1VOVEVSIERBVEUgLyBUSU1FLCBSRVFVSVJFRC0tPg0KCQkJCQkgIDxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJPGxvdyB2YWx1ZT0iMjAxMTExMDIxNDI2MDQiIC8+DQoJCQkJCSAgPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkgIDwhLS0xNi4wNyAtIEFETUlTU0lPTiBUWVBFLCBPcHRpb25hbCwgIFZBIFZpc3RBIERhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCSAgICA8cHJpb3JpdHlDb2RlIG51bGxGbGF2b3I9IlVOSyIgLz4JDQoJCQkJCSAgPCEtLTE2LjA1IC0gRU5DT1VOVEVSIFBST1ZJREVSLCBSMi1PcHRpb25hbCAtLT4NCgkJCQkJICAJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCgkJCQkJCQk8IS0tIFByb3ZpZGVyIFRlbXBsYXRlIElkICAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQoJCQkJCQkJPHRpbWU+DQoJCQkJCQkJCTxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8L3RpbWU+DQoJCQkJCQkJPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQk8IS0tIFByb3ZpZGVyIElEIG51bGxGbGF2b3I9IlVOSyIgYi9jIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8dGVsZWNvbSAvPiANCgkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPG5hbWU+UHJvdmlkZXIsIE9uZTwvbmFtZT4NCgkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJCQkJPC9wZXJmb3JtZXI+DQoJCQkJCSAgPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEVOQ09VTlRFUiwgT3B0aW9uYWwgLS0+DQoJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCTwhLS0gIEFERCBUSU1FIFRPIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRU5DT1VOVEVSIC0tPg0KCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBDODMgYXV0aG9yL2Fzc2lnbmVkUGVyc29uL05hbWUgIFJlcXVpcmVkIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJPC9hdXRob3I+DQoJCQkJCSAgPCEtLTE2LjA2IC0gQURNSVNTSU9OIFNPVVJDRSwgT3B0aW9uYWwsIE5vdCBZZXQgQXZhaWxhYmxlIGZyb20gVkEgVmlzdEEgLS0+DQoJCQkJCSAgPCEtLTE2LjExIC0gRkFDSUxJVFkgTE9DQVRJT04sIE9wdGlvbmFsIC0tPg0KCQkJCQkgIDxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iTE9DIj4NCgkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDUiIC8+DQoJCQkJCQk8IS0tMTYuMjAgLSBJTiBGQUNJTElUWSBMT0NBVElPTiBEVVJBVElPTiwgT3B0aW9uYWwgLS0+DQoJCQkJCQk8dGltZT4NCgkJCQkJCSAgPCEtLTE2LjEyIC0gQVJSSVZBTCBEQVRFL1RJTUUsIE9wdGlvbmFsIC0tPg0KCQkJCQkJICA8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPCEtLSAxNi4xMiAtIERFUEFSVFVSRSBEQVRFL1RJTUUsIE9wdGlvbmFsIC0tPg0KCQkJCQkJICA8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQk8L3RpbWU+DQoJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iU0RMT0MiPg0KCQkJCQkJICA8cGxheWluZ0VudGl0eSBjbGFzc0NvZGU9IlBMQyIgLz4NCgkJCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJCQkgIDwvcGFydGljaXBhbnQ+DQoJCQkJCSAgPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSU09OIj4NCgkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC41IiAvPg0KCQkJCQkJICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4IiAvPg0KCQkJCQkJICA8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8Y29kZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDwhLS0xNi4xMyAtIFJFQVNPTiBGT1IgVklTSVQsIE9wdGlvbmFsIC0tPg0KCQkJCQkJICA8dGV4dD4NCgkJCQkJCQkgIDxyZWZlcmVuY2UgdmFsdWU9IiNlbmRSZWFzb241IiAvPg0KCQkJCQkJICA8L3RleHQ+DQoJCQkJCQkgIDxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCSAgPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQkJPGxvdyBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDwvZWZmZWN0aXZlVGltZT4NCgkJCQkJCSA8dmFsdWUgeHNpOnR5cGU9IkNEIiAvPg0KCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJICA8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQk8L2VuY291bnRlcj4NCgkJCQkgIDwvZW50cnk+PGVudHJ5PiA8IS0tIEVudHJ5IGJsb2NrIHJlcGVhdHMgZm9yIGVhY2ggRW5jb3VudGVyIC0tPg0KCQkJCQk8ZW5jb3VudGVyIGNsYXNzQ29kZT0iRU5DIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJICA8IS0tQ0NEIEVuY291bnRlciBBY3Rpdml0eS0tPg0KCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjEiIC8+DQoJCQkJCSAgPCEtLUM4MyBFbmNvdW50ZXIgRW50cnktLT4NCgkJCQkJICA8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjgzLjE2IiAvPg0KCQkJCQkgIDwhLS1JSEUgRW5jb3VudGVyIEVudHJ5LS0+DQoJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjE0IiAvPg0KCQkJCQkgIDwhLS0xNi4wMSAtIEVOQ09VTlRFUiBJRCwgIFJFUVVJUkVEIC0tPg0KCQkJCQkgIDxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCTwhLS0gIDxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgZXh0ZW5zaW9uPSJlbmMxMjM0Ii8+LS0+DQoJCQkJCSAgPCEtLTE2LjAyIC0gRU5DT1VOVEVSIFRZUEUsIFIyLU9wdGlvbmFsLCAgVkEgUHJvdmlkZXMgQ1BUIC0tPg0KCQkJCQkgIDwhLS0xNi4wMiAtIFdoZW4gQ1BUIGNvZGUgbm90IHByZXNlbnQsIHRoZW4gY29kZSBudWxsRmxhdm9yPSJVTksiIC0tPg0KCQkJCQkgIDxjb2RlIG51bGxGbGF2b3I9IlVOSyI+DQoJCQkJCQk8IS0tMTYuMDMgLSBFTkNPVU5URVIgRlJFRSBURVhUIFRZUEUsIFJFUVVJUkVELS0+DQoJCQkJCQk8b3JpZ2luYWxUZXh0Pg0KCQkJCQkJICA8cmVmZXJlbmNlIHZhbHVlPSIjZW5kRW5jb3VudGVyRGVzY3JpcHRpb242IiAvPg0KCQkJCQkJPC9vcmlnaW5hbFRleHQ+DQoJCQkJCSAgPC9jb2RlPg0KCQkJCQkgIDwhLS0gUmVxdWlyZWQgcGVyIElIRSBUZW1wbGF0ZSwgbm90IHVzZSBieSBWQSAgLS0+DQoJCQkJCSAgPHRleHQ+DQoJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjZW5jTm90ZS0xIiAvPg0KCQkJCQkgIDwvdGV4dD4NCgkJCQkJICA8IS0tMTYuMDQgLSBFTkNPVU5URVIgREFURSAvIFRJTUUsIFJFUVVJUkVELS0+DQoJCQkJCSAgPGVmZmVjdGl2ZVRpbWU+DQoJCQkJCQk8bG93IHZhbHVlPSIyMDExMTEwMTA4MDI0MSIgLz4NCgkJCQkJICA8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCSAgPCEtLTE2LjA3IC0gQURNSVNTSU9OIFRZUEUsIE9wdGlvbmFsLCAgVkEgVmlzdEEgRGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJICAgIDxwcmlvcml0eUNvZGUgbnVsbEZsYXZvcj0iVU5LIiAvPgkNCgkJCQkJICA8IS0tMTYuMDUgLSBFTkNPVU5URVIgUFJPVklERVIsIFIyLU9wdGlvbmFsIC0tPg0KCQkJCQkgIAk8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KCQkJCQkJCTwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuNCIgLz4NCgkJCQkJCQk8dGltZT4NCgkJCQkJCQkJPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwvdGltZT4NCgkJCQkJCQk8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCTwhLS0gUHJvdmlkZXIgSUQgbnVsbEZsYXZvcj0iVU5LIiBiL2MgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGlhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTx0ZWxlY29tIC8+IA0KCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8bmFtZT5Qcm92aWRlciwgT25lPC9uYW1lPg0KCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+DQoJCQkJCQk8L3BlcmZvcm1lcj4NCgkJCQkJICA8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRU5DT1VOVEVSLCBPcHRpb25hbCAtLT4NCgkJCQkJCTxhdXRob3I+DQoJCQkJCQkJPCEtLSAgQUREIFRJTUUgVE8gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBFTkNPVU5URVIgLS0+DQoJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEM4MyBhdXRob3IvYXNzaWduZWRQZXJzb24vTmFtZSAgUmVxdWlyZWQgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQk8L2F1dGhvcj4NCgkJCQkJICA8IS0tMTYuMDYgLSBBRE1JU1NJT04gU09VUkNFLCBPcHRpb25hbCwgTm90IFlldCBBdmFpbGFibGUgZnJvbSBWQSBWaXN0QSAtLT4NCgkJCQkJICA8IS0tMTYuMTEgLSBGQUNJTElUWSBMT0NBVElPTiwgT3B0aW9uYWwgLS0+DQoJCQkJCSAgPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJMT0MiPg0KCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NSIgLz4NCgkJCQkJCTwhLS0xNi4yMCAtIElOIEZBQ0lMSVRZIExPQ0FUSU9OIERVUkFUSU9OLCBPcHRpb25hbCAtLT4NCgkJCQkJCTx0aW1lPg0KCQkJCQkJICA8IS0tMTYuMTIgLSBBUlJJVkFMIERBVEUvVElNRSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkgIDxsb3cgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJICA8IS0tIDE2LjEyIC0gREVQQVJUVVJFIERBVEUvVElNRSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkgIDxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCTwvdGltZT4NCgkJCQkJCTxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJTRExPQyI+DQoJCQkJCQkgIDxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iUExDIiAvPg0KCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQkJCSAgPC9wYXJ0aWNpcGFudD4NCgkJCQkJICA8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCSAgPHRlbXBsYXRlSWQgcm9vdD0iMS4zLjYuMS40LjEuMTkzNzYuMS41LjMuMS40LjUiIC8+DQoJCQkJCQkgIDx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiIC8+DQoJCQkJCQkgIDxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkgIDxjb2RlIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPCEtLTE2LjEzIC0gUkVBU09OIEZPUiBWSVNJVCwgT3B0aW9uYWwgLS0+DQoJCQkJCQkgIDx0ZXh0Pg0KCQkJCQkJCSAgPHJlZmVyZW5jZSB2YWx1ZT0iI2VuZFJlYXNvbjYiIC8+DQoJCQkJCQkgIDwvdGV4dD4NCgkJCQkJCSAgPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJICA8ZWZmZWN0aXZlVGltZT4NCgkJCQkJCQk8bG93IG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCSAgPC9lZmZlY3RpdmVUaW1lPg0KCQkJCQkJIDx2YWx1ZSB4c2k6dHlwZT0iQ0QiIC8+DQoJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQkgIDwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCTwvZW5jb3VudGVyPg0KCQkJCSAgPC9lbnRyeT4NCgkJCQk8L3NlY3Rpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkgICAgIDwhLS0gDQoJCQkqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KCQkJTkhJTl9DUjk1LCBDUjk0DQoJCQlWTEVSIFNlZ21lbnQgMUJpaTogIFBST0NFRFVSRSBTRUNUSU9OIA0KCQkJKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCgkJCS0tPg0KCQkJPGNvbXBvbmVudD4gPCEtLSBDb21wb25lbnQgOCAtLT4NCgkJCQk8c2VjdGlvbj4NCgkJCQk8IS0tIFByb2NlZHVyZXMgc2VjdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xMiIgLz4NCgkJCQkJPGNvZGUgY29kZT0iNDc1MTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiAvPg0KCQkJCQk8dGl0bGU+SGlzdG9yeSBvZiBQcm9jZWR1cmVzPC90aXRsZT4NCgkJCQkJPCEtLSBQUk9DRURVUkUgTkFSUkFUSVZFIEJMT0NLIC0tPg0KICAgICAgICAgICAgICAgICAgICA8dGV4dD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gVkxFUiBTRUcgMUJpaTogUHJvY2VkdXJlIEJ1c2luZXNzIFJ1bGVzIGZvciBNZWRpY2FsIENvbnRlbnQgIC0tPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJCQkJCTx0aGVhZD4NCgkJCQkJCQkJPHRyPg0KCQkJCQkJCQkJPHRoPkRlcGFydG1lbnQgb2YgVmV0ZXJhbnMgQWZmYWlyczwvdGg+DQoJCQkJCQkJCQk8dGg+QnVzaW5lc3MgUnVsZXMgZm9yIENvbnN0cnVjdGlvbiBvZiBQcm9jZWR1cmUgSW5mb3JtYXRpb248L3RoPg0KCQkJCQkJCQk8L3RyPg0KCQkJCQkJCTwvdGhlYWQ+DQoJCQkJCQkJPHRib2R5Pg0KCQkJCQkJCQk8dHI+DQoJCQkJCQkJCQk8dGQ+UHJvY2VkdXJlczwvdGQ+DQoJCQkJCQkJCQk8dGQ+VGhpcyBzZWN0aW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGZvciB0aGUgMjUgbW9zdCByZWNlbnQgaGlzdG9yaWNhbCAoY29tcGxldGVkKSBzdXJnaWNhbCBhbmQgcmFkaW9sb2dpY2FsIHByb2NlZHVyZXMgZm9yIHRoZSBwYXRpZW50IGZyb20gYWxsIFZBIHRyZWF0bWVudCBmYWNpbGl0aWVzIGZvciB3aGljaCB0aGUgcHJvY2VkdXJlIGRhdGUgd2FzIHdpdGhpbiB0aGUgbGFzdCAxMiBtb250aHMuPC90ZD4NCgkJCQkJCQkJPC90cj4NCgkJCQkJCQk8L3Rib2R5Pg0KCQkJCQkJPC90YWJsZT4NCgkJCQkJCTx0YWJsZSBJRD0icHJvY2VkdXJlTmFycml0aXZlIiBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCQkJCQk8dGhlYWQ+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0aD5EYXRlIFRpbWU8L3RoPg0KCQkJCQkJCQkJPHRoPlByb2NlZHVyZSBUeXBlPC90aD4NCgkJCQkJCQkJCTx0aD5RdWFsaWZpZXJzPC90aD4NCgkJCQkJCQkJCTx0aD5EZXNjcmlwdGlvbjwvdGg+DQoJCQkJCQkJCQk8dGg+UHJvdmlkZXI8L3RoPg0KCQkJCQkJCQkJPHRoPlNvdXJjZTwvdGg+DQoJCQkJCQkJCTwvdHI+DQoJCQkJCQkJPC90aGVhZD4NCgkJCQkJCQk8dGJvZHk+DQoJCQkJCQkJCTx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZERhdGVUaW1lMSI+MjAxMjEyMTMxMDA1PC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZFByb2NlZHVyZVR5cGUxIiAvPg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8bGlzdD4NCgkJCQkJCQkJCQkJPGl0ZW0+DQoJCQkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZFF1YWxpZmllcnMxIiAvPg0KCQkJCQkJCQkJCQk8L2l0ZW0+DQoJCQkJCQkJCQkJPC9saXN0Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZERlc2NyaXB0aW9uMSI+QXNzb2NpYXRlZCBOb3RlczogT1BFUkFUSVZFIFJFUE9SVCxTVVJHRVJZIE9QRVJBVElWRSBSRVBPUlQ8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kUHJvdmlkZXIxIj5Qcm92aWRlciwgT25lPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZFNvdXJjZTEiPk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZERhdGVUaW1lMiI+MjAxMjEyMDYxODA2PC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZFByb2NlZHVyZVR5cGUyIj5SQURJT0xPR0lDIEVYQU1JTkFUSU9OLCBTSE9VTERFUjsgQ09NUExFVEUsIE1JTklNVU0gT0YgMiBWSUVXUzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmRRdWFsaWZpZXJzMiIgLz4NCgkJCQkJCQkJCQkJPC9pdGVtPg0KCQkJCQkJCQkJCTwvbGlzdD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmREZXNjcmlwdGlvbjIiPlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIFNIT1VMREVSOyBDT01QTEVURSwgTUlOSU1VTSBPRiAyIFZJRVdTIDwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmRQcm92aWRlcjIiPlByb3ZpZGVyLCBPbmU8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kU291cmNlMiI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kRGF0ZVRpbWUzIj4yMDEyMTIwNDE4MjQ8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kUHJvY2VkdXJlVHlwZTMiPlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIEhJUCwgVU5JTEFURVJBTDsgQ09NUExFVEUsIE1JTklNVU0gT0YgMiBWSUVXUzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmRRdWFsaWZpZXJzMyIgLz4NCgkJCQkJCQkJCQkJPC9pdGVtPg0KCQkJCQkJCQkJCTwvbGlzdD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmREZXNjcmlwdGlvbjMiPlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIEhJUCwgVU5JTEFURVJBTDsgQ09NUExFVEUsIE1JTklNVU0gT0YgMiBWSUVXUyA8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kUHJvdmlkZXIzIj5Qcm92aWRlciwgT25lPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZFNvdXJjZTMiPk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPjx0cj4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZERhdGVUaW1lNCI+MjAxMjA4MjMxMjMzPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZFByb2NlZHVyZVR5cGU0Ij5SQURJT0xPR0lDIEVYQU1JTkFUSU9OLCBXUklTVDsgMiBWSUVXUzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmRRdWFsaWZpZXJzNCIgLz4NCgkJCQkJCQkJCQkJPC9pdGVtPg0KCQkJCQkJCQkJCTwvbGlzdD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmREZXNjcmlwdGlvbjQiPlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIFdSSVNUOyAyIFZJRVdTIDwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmRQcm92aWRlcjQiPlVua25vd248L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kU291cmNlNCI+TUFSVElOU0JVUkcgVkFNQzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCTwvdHI+PHRyPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kRGF0ZVRpbWU1Ij4yMDEyMDgyMzEyMjQ8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kUHJvY2VkdXJlVHlwZTUiPlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIEFCRE9NRU47IFNJTkdMRSBBTlRFUk9QT1NURVJJT1IgVklFVzwvY29udGVudD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGxpc3Q+DQoJCQkJCQkJCQkJCTxpdGVtPg0KCQkJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmRRdWFsaWZpZXJzNSIgLz4NCgkJCQkJCQkJCQkJPC9pdGVtPg0KCQkJCQkJCQkJCTwvbGlzdD4NCgkJCQkJCQkJCTwvdGQ+DQoJCQkJCQkJCQk8dGQ+DQoJCQkJCQkJCQkJPGNvbnRlbnQgSUQ9InBybmREZXNjcmlwdGlvbjUiPlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIEFCRE9NRU47IFNJTkdMRSBBTlRFUk9QT1NURVJJT1IgVklFVyA8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQkJPHRkPg0KCQkJCQkJCQkJCTxjb250ZW50IElEPSJwcm5kUHJvdmlkZXI1Ij5Vbmtub3duPC9jb250ZW50Pg0KCQkJCQkJCQkJPC90ZD4NCgkJCQkJCQkJCTx0ZD4NCgkJCQkJCQkJCQk8Y29udGVudCBJRD0icHJuZFNvdXJjZTUiPk1BUlRJTlNCVVJHIFZBTUM8L2NvbnRlbnQ+DQoJCQkJCQkJCQk8L3RkPg0KCQkJCQkJCQk8L3RyPg0KCQkJCQkJCTwvdGJvZHk+DQoJCQkJCQk8L3RhYmxlPg0KCQkJCQk8L3RleHQ+DQoJCQkJCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+IDwhLS0gSElUU1AgQzMyIFYyLjU6ICBFbnRyeSBibG9jayBSZXBlYXRzIGZvciBFYWNoIFByb2NlZHVyZSAtLT4NCgkJCQkJCTxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBQcm9jZWR1cmVzIGVudHJpZXMgdGVtcGxhdGUgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNyIgLz4NCgkJCQkJCQk8IS0tIFByb2NlZHVyZSBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8IS0tIElIRTogUHJvY2VkdXJlcyBlbnRyaWVzIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xOSIgLz4NCgkJCQkJCQk8IS0tIElIRTogUHJvY2VkdXJlcyBlbnRyaWVzIHRlbXBsYXRlIGZvciBFVk4gLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOSIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAxNy4wMS1QUk9DRURVUkUgSUQsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCTwhLS0gMTcuMDEtUHJvdmlkZXIgSUQgbnVsRmxhdm9yPSJVTksiIGIvYyBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDItUFJPQ0VEVVJFIFRZUEUsIFIyLU9wdGlvbmFsLCBWQSBwcm92aWRlcyBDUFQgY29kZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSI3MzAzMCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMiIgY29kZVN5c3RlbU5hbWU9IkNQVC00IiBkaXNwbGF5TmFtZT0iUkFESU9MT0dJQyBFWEFNSU5BVElPTiwgU0hPVUxERVI7IENPTVBMRVRFLCBNSU5JTVVNIE9GIDIgVklFV1MiPg0KCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBSZWZlcmVuY2UgdG8gMTcuMDMtUFJPQ0VEVVJFIEZSRUUgVEVYVCBUWVBFLCBSRVFVSVJFRCAtLT4NCgkJCQkJCQkJPG9yaWdpbmFsVGV4dD4NCgkJCQkJCQkJCTxyZWZlcmVuY2UgdmFsdWU9IiNwcm5kRGVzY3JpcHRpb24yIiAvPg0KCQkJCQkJCQk8L29yaWdpbmFsVGV4dD4NCgkJCQkJCQkJPCEtLSBNT0RJRklFUlMgZm9yIDE3LjAyLVBST0NFRFVSRSBUWVBFLCBTdXJnZXJ5PU90aGVyIFByb2NlZHVyZSBDUFQgQ29kZSwgUmFkaW9sb2d5PUNQVCBNb2RpZmllciAtLT4NCgkJCQkJCQkJDQoJCQkJCQkJPC9jb2RlPg0KCQkJCQkJCTx0ZXh0Pg0KCQkJCQkJCQk8cmVmZXJlbmNlIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8L3RleHQ+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDE3LjA0LVBST0NFRFVSRSBEQVRFL1RJTUUsIFIyLU9wdGlvbmFsIC0tPg0KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDEyMTIwNjE4MDYiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDYtQk9EWSBTSVRFLCBSMi1PcHRpb25hbCwgU05PTUVEIENUIC0tPg0KCQkJCQkJCTwhLS0gMTcuMDYtQk9EWSBTSVRFIG51bGxGbGF2b3I9IlVOSyIgYi9jIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAxNy4wNS1QUk9DRURVUkUgUFJPVklERVIsIFIyLU9wdGlvbmFsLCBTTk9NRUQgQ1QgLS0+DQoJCQkJCQkJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCgkJCQkJCQkJPCEtLSBQcm92aWRlciBUZW1wbGF0ZSBJZCAgLS0+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuNCIgLz4NCgkJCQkJCQkJPHRpbWU+DQoJCQkJCQkJCQk8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTwvdGltZT4NCgkJCQkJCQkJPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQkJPCEtLSBQcm92aWRlciBJRCBudWxGbGF2b3I9IlVOSyIgYi9jIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJPG5hbWU+UHJvdmlkZXIsIE9uZTwvbmFtZT4NCgkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJPC9wZXJmb3JtZXI+DQoJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIFBST0NFRFVSRSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBDODMgYXV0aG9yL2Fzc2lnbmVkUGVyc29uL05hbWUgIFJlcXVpcmVkIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQk8L3Byb2NlZHVyZT4NCgkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPiA8IS0tIEhJVFNQIEMzMiBWMi41OiAgRW50cnkgYmxvY2sgUmVwZWF0cyBmb3IgRWFjaCBQcm9jZWR1cmUgLS0+DQoJCQkJCQk8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogUHJvY2VkdXJlcyBlbnRyaWVzIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTciIC8+DQoJCQkJCQkJPCEtLSBQcm9jZWR1cmUgYWN0aXZpdHkgdGVtcGxhdGUgLS0+DQoJCQkJCQkJPCEtLSBJSEU6IFByb2NlZHVyZXMgZW50cmllcyB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMTkiIC8+DQoJCQkJCQkJPCEtLSBJSEU6IFByb2NlZHVyZXMgZW50cmllcyB0ZW1wbGF0ZSBmb3IgRVZOIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjkiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDEtUFJPQ0VEVVJFIElELCBSRVFVSVJFRCAtLT4NCgkJCQkJCQk8IS0tIDE3LjAxLVByb3ZpZGVyIElEIG51bEZsYXZvcj0iVU5LIiBiL2MgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDE3LjAyLVBST0NFRFVSRSBUWVBFLCBSMi1PcHRpb25hbCwgVkEgcHJvdmlkZXMgQ1BUIGNvZGUgLS0+DQoJCQkJCQkJPGNvZGUgY29kZT0iNzM1MTAiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTIiIGNvZGVTeXN0ZW1OYW1lPSJDUFQtNCIgZGlzcGxheU5hbWU9IlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIEhJUCwgVU5JTEFURVJBTDsgQ09NUExFVEUsIE1JTklNVU0gT0YgMiBWSUVXUyI+DQoJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IFJlZmVyZW5jZSB0byAxNy4wMy1QUk9DRURVUkUgRlJFRSBURVhUIFRZUEUsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCQk8b3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQkJPHJlZmVyZW5jZSB2YWx1ZT0iI3BybmREZXNjcmlwdGlvbjMiIC8+DQoJCQkJCQkJCTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJCQk8IS0tIE1PRElGSUVSUyBmb3IgMTcuMDItUFJPQ0VEVVJFIFRZUEUsIFN1cmdlcnk9T3RoZXIgUHJvY2VkdXJlIENQVCBDb2RlLCBSYWRpb2xvZ3k9Q1BUIE1vZGlmaWVyIC0tPg0KCQkJCQkJCQkNCgkJCQkJCQk8L2NvZGU+DQoJCQkJCQkJPHRleHQ+DQoJCQkJCQkJCTxyZWZlcmVuY2UgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwvdGV4dD4JCQkJCQkJDQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDE3LjA0LVBST0NFRFVSRSBEQVRFL1RJTUUsIFIyLU9wdGlvbmFsIC0tPg0KCQkJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDEyMTIwNDE4MjQiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDYtQk9EWSBTSVRFLCBSMi1PcHRpb25hbCwgU05PTUVEIENUIC0tPg0KCQkJCQkJCTwhLS0gMTcuMDYtQk9EWSBTSVRFIG51bGxGbGF2b3I9IlVOSyIgYi9jIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJPHRhcmdldFNpdGVDb2RlIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAxNy4wNS1QUk9DRURVUkUgUFJPVklERVIsIFIyLU9wdGlvbmFsLCBTTk9NRUQgQ1QgLS0+DQoJCQkJCQkJPHBlcmZvcm1lciB0eXBlQ29kZT0iUFJGIj4NCgkJCQkJCQkJPCEtLSBQcm92aWRlciBUZW1wbGF0ZSBJZCAgLS0+DQoJCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuMzIuNCIgLz4NCgkJCQkJCQkJPHRpbWU+DQoJCQkJCQkJCQk8aGlnaCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTwvdGltZT4NCgkJCQkJCQkJPGFzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCQkJPCEtLSBQcm92aWRlciBJRCBudWxGbGF2b3I9IlVOSyIgYi9jIFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgaWFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJPG5hbWU+UHJvdmlkZXIsIE9uZTwvbmFtZT4NCgkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCTwvYXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJPC9wZXJmb3JtZXI+DQoJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIFBST0NFRFVSRSwgT3B0aW9uYWwgLS0+DQoJCQkJCQkJPGF1dGhvcj4NCgkJCQkJCQkJPHRpbWUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8YXNzaWduZWRBdXRob3I+DQoJCQkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iTkkiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBDODMgYXV0aG9yL2Fzc2lnbmVkUGVyc29uL05hbWUgIFJlcXVpcmVkIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCTxuYW1lIC8+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBGQUNJTElUWSBJRD1WQSBPSUQsIEVYVD0gVkFNQyBUUkVBVElORyBGQUNJTElUWSBOQlIgLS0+DQoJCQkJCQkJCQkJPGlkIGV4dGVuc2lvbj0iNjEzIiByb290PSIyLjE2Ljg0MC4xLjExMzg4My40LjM0OSIgLz4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGQUNJTElUWSBOQU1FIChmYWNpbGl0eU5hbWUpIC0tPg0KCQkJCQkJCQkJCTxuYW1lPk1BUlRJTlNCVVJHIFZBTUM8L25hbWU+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCTwvYXNzaWduZWRBdXRob3I+DQoJCQkJCQkJPC9hdXRob3I+DQoJCQkJCQk8L3Byb2NlZHVyZT4NCgkJCQkJPC9lbnRyeT48ZW50cnkgdHlwZUNvZGU9IkRSSVYiPiA8IS0tIEhJVFNQIEMzMiBWMi41OiAgRW50cnkgYmxvY2sgUmVwZWF0cyBmb3IgRWFjaCBQcm9jZWR1cmUgLS0+DQoJCQkJCQk8cHJvY2VkdXJlIGNsYXNzQ29kZT0iUFJPQyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogUHJvY2VkdXJlcyBlbnRyaWVzIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjMuODguMTEuODMuMTciIC8+DQoJCQkJCQkJPCEtLSBQcm9jZWR1cmUgYWN0aXZpdHkgdGVtcGxhdGUgLS0+DQoJCQkJCQkJPCEtLSBJSEU6IFByb2NlZHVyZXMgZW50cmllcyB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIxLjMuNi4xLjQuMS4xOTM3Ni4xLjUuMy4xLjQuMTkiIC8+DQoJCQkJCQkJPCEtLSBJSEU6IFByb2NlZHVyZXMgZW50cmllcyB0ZW1wbGF0ZSBmb3IgRVZOIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjkiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDEtUFJPQ0VEVVJFIElELCBSRVFVSVJFRCAtLT4NCgkJCQkJCQk8IS0tIDE3LjAxLVByb3ZpZGVyIElEIG51bEZsYXZvcj0iVU5LIiBiL2MgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQk8aWQgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDE3LjAyLVBST0NFRFVSRSBUWVBFLCBSMi1PcHRpb25hbCwgVkEgcHJvdmlkZXMgQ1BUIGNvZGUgLS0+DQoJCQkJCQkJPGNvZGUgY29kZT0iNzMxMDAiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMTIiIGNvZGVTeXN0ZW1OYW1lPSJDUFQtNCIgZGlzcGxheU5hbWU9IlJBRElPTE9HSUMgRVhBTUlOQVRJT04sIFdSSVNUOyAyIFZJRVdTIj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogUmVmZXJlbmNlIHRvIDE3LjAzLVBST0NFRFVSRSBGUkVFIFRFWFQgVFlQRSwgUkVRVUlSRUQgLS0+DQoJCQkJCQkJCTxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcHJuZERlc2NyaXB0aW9uNCIgLz4NCgkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCTwhLS0gTU9ESUZJRVJTIGZvciAxNy4wMi1QUk9DRURVUkUgVFlQRSwgU3VyZ2VyeT1PdGhlciBQcm9jZWR1cmUgQ1BUIENvZGUsIFJhZGlvbG9neT1DUFQgTW9kaWZpZXIgLS0+DQoJCQkJCQkJCQ0KCQkJCQkJCTwvY29kZT4NCgkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJPHJlZmVyZW5jZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPC90ZXh0PgkJCQkJCQkNCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDQtUFJPQ0VEVVJFIERBVEUvVElNRSwgUjItT3B0aW9uYWwgLS0+DQoJCQkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMTIwODIzMTIzMyIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAxNy4wNi1CT0RZIFNJVEUsIFIyLU9wdGlvbmFsLCBTTk9NRUQgQ1QgLS0+DQoJCQkJCQkJPCEtLSAxNy4wNi1CT0RZIFNJVEUgbnVsbEZsYXZvcj0iVU5LIiBiL2MgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQk8dGFyZ2V0U2l0ZUNvZGUgbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDE3LjA1LVBST0NFRFVSRSBQUk9WSURFUiwgUjItT3B0aW9uYWwsIFNOT01FRCBDVCAtLT4NCgkJCQkJCQk8cGVyZm9ybWVyIHR5cGVDb2RlPSJQUkYiPg0KCQkJCQkJCQk8IS0tIFByb3ZpZGVyIFRlbXBsYXRlIElkICAtLT4NCgkJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS4zMi40IiAvPg0KCQkJCQkJCQk8dGltZT4NCgkJCQkJCQkJCTxoaWdoIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPC90aW1lPg0KCQkJCQkJCQk8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJCQk8IS0tIFByb3ZpZGVyIElEIG51bEZsYXZvcj0iVU5LIiBiL2MgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciBpYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQk8bmFtZT5Vbmtub3duPC9uYW1lPg0KCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJPC9hc3NpZ25lZEVudGl0eT4NCgkJCQkJCQk8L3BlcmZvcm1lcj4NCgkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgUFJPQ0VEVVJFLCBPcHRpb25hbCAtLT4NCgkJCQkJCQk8YXV0aG9yPg0KCQkJCQkJCQk8dGltZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJOSSIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGFzc2lnbmVkRW50aXR5LCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTx0ZWxlY29tIC8+DQoJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEM4MyBhdXRob3IvYXNzaWduZWRQZXJzb24vTmFtZSAgUmVxdWlyZWQgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQkJPG5hbWUgLz4NCgkJCQkJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCQkJCQk8cmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRk9SIEZBQ0lMSVRZIElEPVZBIE9JRCwgRVhUPSBWQU1DIFRSRUFUSU5HIEZBQ0lMSVRZIE5CUiAtLT4NCgkJCQkJCQkJCQk8aWQgZXh0ZW5zaW9uPSI2MTMiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjQuMzQ5IiAvPg0KCQkJCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZBQ0lMSVRZIE5BTUUgKGZhY2lsaXR5TmFtZSkgLS0+DQoJCQkJCQkJCQkJPG5hbWU+TUFSVElOU0JVUkcgVkFNQzwvbmFtZT4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgICBUZWxlY29tIFJlcXVpcmVkIGZvciByZXByZXNlbnRlZE9yZ2FuaXphdGlvbiwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAgIEFkZHJlc3MgUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJPC9hc3NpZ25lZEF1dGhvcj4NCgkJCQkJCQk8L2F1dGhvcj4NCgkJCQkJCTwvcHJvY2VkdXJlPg0KCQkJCQk8L2VudHJ5PjxlbnRyeSB0eXBlQ29kZT0iRFJJViI+IDwhLS0gSElUU1AgQzMyIFYyLjU6ICBFbnRyeSBibG9jayBSZXBlYXRzIGZvciBFYWNoIFByb2NlZHVyZSAtLT4NCgkJCQkJCTxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiBQcm9jZWR1cmVzIGVudHJpZXMgdGVtcGxhdGUgLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMS44My4xNyIgLz4NCgkJCQkJCQk8IS0tIFByb2NlZHVyZSBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8IS0tIElIRTogUHJvY2VkdXJlcyBlbnRyaWVzIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjEuMy42LjEuNC4xLjE5Mzc2LjEuNS4zLjEuNC4xOSIgLz4NCgkJCQkJCQk8IS0tIElIRTogUHJvY2VkdXJlcyBlbnRyaWVzIHRlbXBsYXRlIGZvciBFVk4gLS0+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOSIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAxNy4wMS1QUk9DRURVUkUgSUQsIFJFUVVJUkVEIC0tPg0KCQkJCQkJCTwhLS0gMTcuMDEtUHJvdmlkZXIgSUQgbnVsRmxhdm9yPSJVTksiIGIvYyBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCTxpZCBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDItUFJPQ0VEVVJFIFRZUEUsIFIyLU9wdGlvbmFsLCBWQSBwcm92aWRlcyBDUFQgY29kZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSI3NDAwMCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xMiIgY29kZVN5c3RlbU5hbWU9IkNQVC00IiBkaXNwbGF5TmFtZT0iUkFESU9MT0dJQyBFWEFNSU5BVElPTiwgQUJET01FTjsgU0lOR0xFIEFOVEVST1BPU1RFUklPUiBWSUVXIj4NCgkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogUmVmZXJlbmNlIHRvIDE3LjAzLVBST0NFRFVSRSBGUkVFIFRFWFQgVFlQRSwgUkVRVUlSRUQgLS0+DQoJCQkJCQkJCTxvcmlnaW5hbFRleHQ+DQoJCQkJCQkJCQk8cmVmZXJlbmNlIHZhbHVlPSIjcHJuZERlc2NyaXB0aW9uNSIgLz4NCgkJCQkJCQkJPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQkJCTwhLS0gTU9ESUZJRVJTIGZvciAxNy4wMi1QUk9DRURVUkUgVFlQRSwgU3VyZ2VyeT1PdGhlciBQcm9jZWR1cmUgQ1BUIENvZGUsIFJhZGlvbG9neT1DUFQgTW9kaWZpZXIgLS0+DQoJCQkJCQkJCQ0KCQkJCQkJCTwvY29kZT4NCgkJCQkJCQk8dGV4dD4NCgkJCQkJCQkJPHJlZmVyZW5jZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPC90ZXh0Pg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIgLz4NCgkJCQkJCQk8IS0tIEhJVFNQIEMzMiBWMi41OiAxNy4wNC1QUk9DRURVUkUgREFURS9USU1FLCBSMi1PcHRpb25hbCAtLT4NCgkJCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAxMjA4MjMxMjI0IiAvPg0KCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6IDE3LjA2LUJPRFkgU0lURSwgUjItT3B0aW9uYWwsIFNOT01FRCBDVCAtLT4NCgkJCQkJCQk8IS0tIDE3LjA2LUJPRFkgU0lURSBudWxsRmxhdm9yPSJVTksiIGIvYyBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCTx0YXJnZXRTaXRlQ29kZSBudWxsRmxhdm9yPSJVTksiIC8+DQoJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogMTcuMDUtUFJPQ0VEVVJFIFBST1ZJREVSLCBSMi1PcHRpb25hbCwgU05PTUVEIENUIC0tPg0KCQkJCQkJCTxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQoJCQkJCQkJCTwhLS0gUHJvdmlkZXIgVGVtcGxhdGUgSWQgIC0tPg0KCQkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4zLjg4LjExLjMyLjQiIC8+DQoJCQkJCQkJCTx0aW1lPg0KCQkJCQkJCQkJPGhpZ2ggbnVsbEZsYXZvcj0iVU5LIiAvPg0KCQkJCQkJCQk8L3RpbWU+DQoJCQkJCQkJCTxhc3NpZ25lZEVudGl0eT4NCgkJCQkJCQkJCTwhLS0gUHJvdmlkZXIgSUQgbnVsRmxhdm9yPSJVTksiIGIvYyBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPGFkZHIgLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIGlhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJPGFzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQkJCTxuYW1lPlVua25vd248L25hbWU+DQoJCQkJCQkJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJCQkJCQk8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJCQkJCTwvcGVyZm9ybWVyPg0KCQkJCQkJCTwhLS0gSU5GT1JNQVRJT04gU09VUkNFIEZPUiBQUk9DRURVUkUsIE9wdGlvbmFsIC0tPg0KCQkJCQkJCTxhdXRob3I+DQoJCQkJCQkJCTx0aW1lIG51bGxGbGF2b3I9IlVOSyIgLz4NCgkJCQkJCQkJPGFzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCQkJPGlkIG51bGxGbGF2b3I9Ik5JIiAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICBBZGRyZXNzIFJlcXVpcmVkIGZvciBhc3NpZ25lZEVudGl0eSwgYnV0IFZBIFZpc3RBIGRhdGEgbm90IHlldCBhdmFpbGFibGUgLS0+DQoJCQkJCQkJCQk8YWRkciAvPg0KCQkJCQkJCQkJPCEtLSBISVRTUCBDMzIgVjIuNTogICAgVGVsZWNvbSBSZXF1aXJlZCBmb3IgYXNzaWduZWRFbnRpdHksIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJPHRlbGVjb20gLz4NCgkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQzgzIGF1dGhvci9hc3NpZ25lZFBlcnNvbi9OYW1lICBSZXF1aXJlZCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCQk8bmFtZSAvPg0KCQkJCQkJCQkJPC9hc3NpZ25lZFBlcnNvbj4NCgkJCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJCQk8IS0tIElORk9STUFUSU9OIFNPVVJDRSBGT1IgRkFDSUxJVFkgSUQ9VkEgT0lELCBFWFQ9IFZBTUMgVFJFQVRJTkcgRkFDSUxJVFkgTkJSIC0tPg0KCQkJCQkJCQkJCTxpZCBleHRlbnNpb249IjYxMyIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuNC4zNDkiIC8+DQoJCQkJCQkJCQkJPCEtLSBJTkZPUk1BVElPTiBTT1VSQ0UgRkFDSUxJVFkgTkFNRSAoZmFjaWxpdHlOYW1lKSAtLT4NCgkJCQkJCQkJCQk8bmFtZT5NQVJUSU5TQlVSRyBWQU1DPC9uYW1lPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgIFRlbGVjb20gUmVxdWlyZWQgZm9yIHJlcHJlc2VudGVkT3JnYW5pemF0aW9uLCBidXQgVkEgVmlzdEEgZGF0YSBub3QgeWV0IGF2YWlsYWJsZSAtLT4NCgkJCQkJCQkJCQk8dGVsZWNvbSAvPg0KCQkJCQkJCQkJCTwhLS0gSElUU1AgQzMyIFYyLjU6ICAgQWRkcmVzcyBSZXF1aXJlZCBmb3IgcmVwcmVzZW50ZWRPcmdhbml6YXRpb24sIGJ1dCBWQSBWaXN0QSBkYXRhIG5vdCB5ZXQgYXZhaWxhYmxlIC0tPg0KCQkJCQkJCQkJCTxhZGRyIC8+DQoJCQkJCQkJCQk8L3JlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCQkJCQk8L2Fzc2lnbmVkQXV0aG9yPg0KCQkJCQkJCTwvYXV0aG9yPg0KCQkJCQkJPC9wcm9jZWR1cmU+DQoJCQkJCTwvZW50cnk+DQoJCQkJPC9zZWN0aW9uPg0KCQkJPC9jb21wb25lbnQ+DQogICAgCTwvc3RydWN0dXJlZEJvZHk+DQoJPC9jb21wb25lbnQ+DQo8L0NsaW5pY2FsRG9jdW1lbnQ+DQo=","base64").toString();
        var result = bb.parseString(data);
        result.meta.sections.sort();

        // check validation
        var val = bb.validator.validateDocumentModel(result);

        // generate ccda
        var xml = bbg.generateCCD(result);

        // parse generated ccda
        var result2 = bb.parseString(xml);
        result2.meta.sections.sort();

        // re-generate
        var xml2 = bbg.generateCCD(result2);

        delete result.errors;
        delete result2.errors;

        assert.deepEqual(result2, result);
    });

    it('SampleCCDDocument.xml should still be same', function () {
        var data = Buffer("PD94bWwgdmVyc2lvbj0iMS4wIj8+DQo8P3htbC1zdHlsZXNoZWV0IHR5cGU9InRleHQveHNsIiBocmVmPSJDREFTY2hlbWFzXGNkYVxTY2hlbWFzXENDRC54c2wiPz4NCjwhLS0gVGhlIGZvbGxvd2luZyBzYW1wbGUgZG9jdW1lbnQgZGVwaWN0cyBhIGZpY3Rpb25hbCBjaGFyYWN0ZXLigJlzIGhlYWx0aCBzdW1tYXJ5LiBBbnkgcmVzZW1ibGFuY2UgdG8gYSByZWFsIHBlcnNvbiBpcyBjb2luY2lkZW50YWwuIC0tPg0KPENsaW5pY2FsRG9jdW1lbnQgeG1sbnM9InVybjpobDctb3JnOnYzIiB4bWxuczp2b2M9InVybjpobDctb3JnOnYzL3ZvYyIgeG1sbnM6eHNpPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSIgeHNpOnNjaGVtYUxvY2F0aW9uPSJ1cm46aGw3LW9yZzp2MyBDREEueHNkIj4NCgk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCkNEQSBIZWFkZXINCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQotLT4NCgk8dHlwZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEuMyIgZXh0ZW5zaW9uPSJQT0NEX0hEMDAwMDQwIi8+DQoJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMSIvPiA8IS0tIENDRCB2MS4wIFRlbXBsYXRlcyBSb290IC0tPg0KCTxpZCByb290PSJkYjczNDY0Ny1mYzk5LTQyNGMtYTg2NC03ZTNjZGE4MmU3MDMiLz4NCgk8Y29kZSBjb2RlPSIzNDEzMy05IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdW1tYXJpemF0aW9uIG9mIGVwaXNvZGUgbm90ZSIvPg0KCTx0aXRsZT5Hb29kIEhlYWx0aCBDbGluaWMgQ29udGludWl0eSBvZiBDYXJlIERvY3VtZW50PC90aXRsZT4NCgk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDA0MDcxMzAwMDArMDUwMCIvPg0KCTxjb25maWRlbnRpYWxpdHlDb2RlIGNvZGU9Ik4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMjUiLz4NCgk8bGFuZ3VhZ2VDb2RlIGNvZGU9ImVuLVVTIi8+DQoJPHJlY29yZFRhcmdldD4NCgkJPHBhdGllbnRSb2xlPg0KCQkJPGlkIGV4dGVuc2lvbj0iOTk2LTc1Ni00OTUiIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUiLz4NCgkJCTxwYXRpZW50Pg0KCQkJCTxuYW1lPg0KCQkJCQk8Z2l2ZW4+SGVucnk8L2dpdmVuPg0KCQkJCQk8ZmFtaWx5PkxldmluPC9mYW1pbHk+DQoJCQkJCTxzdWZmaXg+dGhlIDd0aDwvc3VmZml4Pg0KCQkJCTwvbmFtZT4NCgkJCQk8YWRtaW5pc3RyYXRpdmVHZW5kZXJDb2RlIGNvZGU9Ik0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMSIvPg0KCQkJCTxiaXJ0aFRpbWUgdmFsdWU9IjE5MzIwOTI0Ii8+DQoJCQk8L3BhdGllbnQ+DQoJCQk8cHJvdmlkZXJPcmdhbml6YXRpb24+DQoJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUiLz4NCgkJCQk8bmFtZT5Hb29kIEhlYWx0aCBDbGluaWM8L25hbWU+DQoJCQk8L3Byb3ZpZGVyT3JnYW5pemF0aW9uPg0KCQk8L3BhdGllbnRSb2xlPg0KCTwvcmVjb3JkVGFyZ2V0Pg0KCTxhdXRob3I+DQoJCTx0aW1lIHZhbHVlPSIyMDAwMDQwNzEzMDAwMCswNTAwIi8+DQoJCTxhc3NpZ25lZEF1dGhvcj4NCgkJCTxpZCByb290PSIyMGNmMTRmYi1iNjVjLTRjOGMtYTU0ZC1iMGNjYTgzNGMxOGMiLz4NCgkJCTxhc3NpZ25lZFBlcnNvbj4NCgkJCQk8bmFtZT48cHJlZml4PkRyLjwvcHJlZml4PjxnaXZlbj5Sb2JlcnQ8L2dpdmVuPjxmYW1pbHk+RG9saW48L2ZhbWlseT48L25hbWU+DQoJCQk8L2Fzc2lnbmVkUGVyc29uPg0KCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ii8+DQoJCQkJPG5hbWU+R29vZCBIZWFsdGggQ2xpbmljPC9uYW1lPg0KCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJPC9hc3NpZ25lZEF1dGhvcj4NCgk8L2F1dGhvcj4NCgk8aW5mb3JtYW50Pg0KCQk8YXNzaWduZWRFbnRpdHk+DQoJCQk8aWQgbnVsbEZsYXZvcj0iTkkiLz4NCgkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQk8aWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNSIvPg0KCQkJCTxuYW1lPkdvb2QgSGVhbHRoIENsaW5pYzwvbmFtZT4NCgkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCTwvYXNzaWduZWRFbnRpdHk+DQoJPC9pbmZvcm1hbnQ+DQoJPGN1c3RvZGlhbj4NCgkJPGFzc2lnbmVkQ3VzdG9kaWFuPg0KCQkJPHJlcHJlc2VudGVkQ3VzdG9kaWFuT3JnYW5pemF0aW9uPg0KCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ii8+DQoJCQkJPG5hbWU+R29vZCBIZWFsdGggQ2xpbmljPC9uYW1lPg0KCQkJPC9yZXByZXNlbnRlZEN1c3RvZGlhbk9yZ2FuaXphdGlvbj4NCgkJPC9hc3NpZ25lZEN1c3RvZGlhbj4NCgk8L2N1c3RvZGlhbj4NCgk8bGVnYWxBdXRoZW50aWNhdG9yPg0KCQk8dGltZSB2YWx1ZT0iMjAwMDA0MDcxMzAwMDArMDUwMCIvPg0KCQk8c2lnbmF0dXJlQ29kZSBjb2RlPSJTIi8+DQoJCTxhc3NpZ25lZEVudGl0eT4NCgkJCTxpZCBudWxsRmxhdm9yPSJOSSIvPg0KCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ii8+DQoJCQkJPG5hbWU+R29vZCBIZWFsdGggQ2xpbmljPC9uYW1lPg0KCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJPC9hc3NpZ25lZEVudGl0eT4NCgk8L2xlZ2FsQXV0aGVudGljYXRvcj4NCgk8cGFydGljaXBhbnQgdHlwZUNvZGU9IklORCI+DQoJCTxhc3NvY2lhdGVkRW50aXR5IGNsYXNzQ29kZT0iR1VBUiI+DQoJCQk8aWQgcm9vdD0iNGZmNTE1NzAtODNhOS00N2I3LTkxZjItOTNiYTMwMzczMTQxIi8+DQoJCQk8YWRkcj4NCgkJCQk8c3RyZWV0QWRkcmVzc0xpbmU+MTcgRGF3cyBSZC48L3N0cmVldEFkZHJlc3NMaW5lPg0KCQkJCTxjaXR5PkJsdWUgQmVsbDwvY2l0eT4NCgkJCQk8c3RhdGU+TUE8L3N0YXRlPg0KCQkJCTxwb3N0YWxDb2RlPjAyMzY4PC9wb3N0YWxDb2RlPg0KCQkJPC9hZGRyPg0KCQkJPHRlbGVjb20gdmFsdWU9InRlbDooODg4KTU1NS0xMjEyIi8+DQoJCQk8YXNzb2NpYXRlZFBlcnNvbj4NCgkJCQk8bmFtZT4NCgkJCQkJPGdpdmVuPktlbm5ldGg8L2dpdmVuPg0KCQkJCQk8ZmFtaWx5PlJvc3M8L2ZhbWlseT4NCgkJCQk8L25hbWU+DQoJCQk8L2Fzc29jaWF0ZWRQZXJzb24+DQoJCTwvYXNzb2NpYXRlZEVudGl0eT4NCgk8L3BhcnRpY2lwYW50Pg0KCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iSU5EIj4NCgkJPGFzc29jaWF0ZWRFbnRpdHkgY2xhc3NDb2RlPSJOT0siPg0KCQkJPGlkIHJvb3Q9IjRhYzcxNTE0LTZhMTAtNDE2NC05NzE1LWY4ZDk2YWY0OGU2ZCIvPg0KCQkJPGNvZGUgY29kZT0iNjU2NTYwMDUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJCaWlvbG9naWNhbCBtb3RoZXIiLz4NCgkJCTx0ZWxlY29tIHZhbHVlPSJ0ZWw6KDk5OSk1NTUtMTIxMiIvPg0KCQkJPGFzc29jaWF0ZWRQZXJzb24+DQoJCQkJPG5hbWU+DQoJCQkJCTxnaXZlbj5IZW5yaWV0dGE8L2dpdmVuPg0KCQkJCQk8ZmFtaWx5PkxldmluPC9mYW1pbHk+DQoJCQkJPC9uYW1lPg0KCQkJPC9hc3NvY2lhdGVkUGVyc29uPg0KCQk8L2Fzc29jaWF0ZWRFbnRpdHk+DQoJPC9wYXJ0aWNpcGFudD4NCgk8ZG9jdW1lbnRhdGlvbk9mPg0KCQk8c2VydmljZUV2ZW50IGNsYXNzQ29kZT0iUENQUiI+DQoJCQk8ZWZmZWN0aXZlVGltZT48bG93IHZhbHVlPSIxOTMyMDkyNCIvPjxoaWdoIHZhbHVlPSIyMDAwMDQwNyIvPjwvZWZmZWN0aXZlVGltZT4NCgkJCTxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQoJCQkJPGZ1bmN0aW9uQ29kZSBjb2RlPSJQQ1AiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODgiLz4NCgkJCQk8dGltZT48bG93IHZhbHVlPSIxOTkwIi8+PGhpZ2ggdmFsdWU9JzIwMDAwNDA3Jy8+PC90aW1lPg0KCQkJCTxhc3NpZ25lZEVudGl0eT4NCgkJCQkJPGlkIHJvb3Q9IjIwY2YxNGZiLWI2NWMtNGM4Yy1hNTRkLWIwY2NhODM0YzE4YyIvPg0KCQkJCQk8YXNzaWduZWRQZXJzb24+DQoJCQkJCQk8bmFtZT48cHJlZml4PkRyLjwvcHJlZml4PjxnaXZlbj5Sb2JlcnQ8L2dpdmVuPjxmYW1pbHk+RG9saW48L2ZhbWlseT48L25hbWU+DQoJCQkJCTwvYXNzaWduZWRQZXJzb24+DQoJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ii8+DQoJCQkJCQk8bmFtZT5Hb29kIEhlYWx0aCBDbGluaWM8L25hbWU+DQoJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJPC9hc3NpZ25lZEVudGl0eT4NCgkJCTwvcGVyZm9ybWVyPg0KCQk8L3NlcnZpY2VFdmVudD4NCgk8L2RvY3VtZW50YXRpb25PZj4NCgk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCkNEQSBCb2R5DQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLS0+DQoJPGNvbXBvbmVudD4NCgkJPHN0cnVjdHVyZWRCb2R5Pg0KCQkJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNClB1cnBvc2Ugc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTMnLz4gPCEtLSBQdXJwb3NlIHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJPGNvZGUgY29kZT0iNDg3NjQtNSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+DQoJPHRpdGxlPlN1bW1hcnkgUHVycG9zZTwvdGl0bGU+DQoJPHRleHQ+VHJhbnNmZXIgb2YgY2FyZTwvdGV4dD4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzAnLz4gPCEtLSBQdXJwb3NlIGFjdGl2aXR5IHRlbXBsYXRlIC0tPg0KCQkJPGNvZGUgY29kZT0iMjM3NDUwMDEiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJEb2N1bWVudGF0aW9uIHByb2NlZHVyZSIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJTT04iPg0KCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8Y29kZSBjb2RlPSIzMDgyOTIwMDciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJUcmFuc2ZlciBvZiBjYXJlIi8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCTwvYWN0Pg0KCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJPC9hY3Q+DQoJPC9lbnRyeT4NCjwvc2VjdGlvbj4NCjwvY29tcG9uZW50Pg0KCQkJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNClBheWVycyBzZWN0aW9uDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLS0+DQo8Y29tcG9uZW50Pg0KPHNlY3Rpb24+DQoJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS45Jy8+IDwhLS0gUGF5ZXJzIHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJPGNvZGUgY29kZT0iNDg3NjgtNiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+DQoJPHRpdGxlPlBheWVyczwvdGl0bGU+DQoJPHRleHQ+DQoJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCTx0aGVhZD4NCgkJCTx0cj48dGg+UGF5ZXIgbmFtZTwvdGg+PHRoPlBvbGljeSB0eXBlIC8gQ292ZXJhZ2UgdHlwZTwvdGg+PHRoPkNvdmVyZWQgcGFydHkgSUQ8L3RoPiA8dGg+QXV0aG9yaXphdGlvbihzKTwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQkJPHRyPg0KCQkJCQk8dGQ+R29vZCBIZWFsdGggSW5zdXJhbmNlPC90ZD4gDQoJCQkJCTx0ZD5FeHRlbmRlZCBoZWFsdGhjYXJlIC8gU2VsZjwvdGQ+IA0KCQkJCQk8dGQ+MTRkNGE1MjAtN2FhZS0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2PC90ZD4NCgkJCQkJPHRkPkNvbG9ub3Njb3B5PC90ZD4NCgkJCQk8L3RyPg0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkRFRiI+DQoJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjIwJy8+IDwhLS0gQ292ZXJhZ2UgYWN0aXZpdHkgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iMWZlMmNkZDAtN2FhZC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+DQoJCQk8Y29kZSBjb2RlPSI0ODc2OC02IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJQYXltZW50IHNvdXJjZXMiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJDT01QIj4NCgkJCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNicvPiA8IS0tIFBvbGljeSBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9IjNlNjc2YTUwLTdhYWMtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSJFSENQT0wiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgZGlzcGxheU5hbWU9IkV4dGVuZGVkIGhlYWx0aGNhcmUiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTxwZXJmb3JtZXIgdHlwZUNvZGU9IlBSRiI+DQoJCQkJCQk8YXNzaWduZWRFbnRpdHk+DQoJCQkJCQkJPGlkIHJvb3Q9IjMyOWZjZGYwLTdhYjMtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQkJCTxyZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJCQkJCQkJPG5hbWU+R29vZCBIZWFsdGggSW5zdXJhbmNlPC9uYW1lPg0KCQkJCQkJCTwvcmVwcmVzZW50ZWRPcmdhbml6YXRpb24+DQoJCQkJCQk8L2Fzc2lnbmVkRW50aXR5Pg0KCQkJCQk8L3BlcmZvcm1lcj4NCgkJCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDT1YiPg0KCQkJCQkJPHBhcnRpY2lwYW50Um9sZT4NCgkJCQkJCQk8aWQgcm9vdD0iMTRkNGE1MjAtN2FhZS0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCQkJPGNvZGUgY29kZT0iU0VMRiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTEiIGRpc3BsYXlOYW1lPSJTZWxmIi8+DQoJCQkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCQkJPC9wYXJ0aWNpcGFudD4NCgkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCgkJCQkJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTknLz4gPCEtLSBBdXRob3JpemF0aW9uIGFjdGl2aXR5IHRlbXBsYXRlIC0tPg0KCQkJCQkJCTxpZCByb290PSJmNGRjZTc5MC04MzI4LTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4NCgkJCQkJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIvPg0KCQkJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJCQkJCTxwcm9jZWR1cmUgY2xhc3NDb2RlPSJQUk9DIiBtb29kQ29kZT0iUFJNUyI+DQoJCQkJCQkJCQk8Y29kZSBjb2RlPSI3Mzc2MTAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkNvbG9ub3Njb3B5Ii8+DQoJCQkJCQkJCTwvcHJvY2VkdXJlPg0KCQkJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCQk8L2FjdD4NCgkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQk8L2FjdD4NCgkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCTwvYWN0Pg0KCTwvZW50cnk+DQo8L3NlY3Rpb24+DQo8L2NvbXBvbmVudD4NCgkJCQkJPCEtLSANCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQpBZHZhbmNlIERpcmVjdGl2ZXMgc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMScvPiA8IS0tIEFkdmFuY2UgZGlyZWN0aXZlcyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjQyMzQ4LTMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPg0KCTx0aXRsZT5BZHZhbmNlIERpcmVjdGl2ZXM8L3RpdGxlPg0KCTx0ZXh0Pg0KCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+DQoJCQk8dGhlYWQ+DQoJCQk8dHI+PHRoPkRpcmVjdGl2ZTwvdGg+PHRoPkRlc2NyaXB0aW9uPC90aD48dGg+VmVyaWZpY2F0aW9uPC90aD48dGg+U3VwcG9ydGluZyBEb2N1bWVudChzKTwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQkJPHRyPg0KCQkJCQk8dGQ+UmVzdXNjaXRhdGlvbiBzdGF0dXM8L3RkPiANCgkJCQkJPHRkPjxjb250ZW50IElEPSJBRDEiPkRvIG5vdCByZXN1c2NpdGF0ZTwvY29udGVudD48L3RkPiANCgkJCQkJPHRkPkRyLiBSb2JlcnQgRG9saW4sIE5vdiAwNywgMTk5OTwvdGQ+DQoJCQkJCTx0ZD48bGlua0h0bWwgaHJlZj0iQWR2YW5jZURpcmVjdGl2ZS5iNTBiNzkxMC03ZmZiLTRmNGMtYmJlNC0xNzdlZDY4Y2JiZjMucGRmIj5BZHZhbmNlIGRpcmVjdGl2ZTwvbGlua0h0bWw+PC90ZD4NCgkJCQk8L3RyPg0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTcnLz4gPCEtLSBBZHZhbmNlIGRpcmVjdGl2ZSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSI5YjU0YzNjOS0xNjczLTQ5YzctYWVmOS1iMDM3ZWQ3MmVkMjciLz4NCgkJCTxjb2RlIGNvZGU9IjMwNDI1MTAwOCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IlJlc3VzY2l0YXRpb24iLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMzA0MjUzMDA2IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iRG8gbm90IHJlc3VzY2l0YXRlIj4NCgkJCQk8b3JpZ2luYWxUZXh0PjxyZWZlcmVuY2UgdmFsdWU9IiNBRDEiLz48L29yaWdpbmFsVGV4dD4NCgkJCTwvdmFsdWU+DQoJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IlZSRiI+DQoJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41OCcvPiA8IS0tIFZlcmlmaWNhdGlvbiBvZiBhbiBhZHZhbmNlIGRpcmVjdGl2ZSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQk8dGltZSB2YWx1ZT0iMTk5OTExMDciLz4NCgkJCQk8cGFydGljaXBhbnRSb2xlPg0KCQkJCQk8aWQgcm9vdD0iMjBjZjE0ZmItYjY1Yy00YzhjLWE1NGQtYjBjY2E4MzRjMThjIi8+DQoJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQk8L3BhcnRpY2lwYW50Pg0KCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjM3Jy8+IDwhLS0gQWR2YW5jZSBkaXJlY3RpdmUgc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0UiIGNvZGU9IjE1MjQwMDA3IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQ3VycmVudCBhbmQgdmVyaWZpZWQiLz4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCTxyZWZlcmVuY2UgdHlwZUNvZGU9IlJFRlIiPg0KCQkJCTxleHRlcm5hbERvY3VtZW50Pg0KCQkJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjM2Jy8+IDwhLS0gQWR2YW5jZSBkaXJlY3RpdmUgcmVmZXJlbmNlIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYjUwYjc5MTAtN2ZmYi00ZjRjLWJiZTQtMTc3ZWQ2OGNiYmYzIi8+DQoJCQkJCTxjb2RlIGNvZGU9IjM3MTUzODAwNiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFkdmFuY2UgZGlyZWN0aXZlIi8+DQoJCQkJCTx0ZXh0IG1lZGlhVHlwZT0iYXBwbGljYXRpb24vcGRmIj48cmVmZXJlbmNlIHZhbHVlPSJBZHZhbmNlRGlyZWN0aXZlLmI1MGI3OTEwLTdmZmItNGY0Yy1iYmU0LTE3N2VkNjhjYmJmMy5wZGYiLz48L3RleHQ+DQoJCQkJPC9leHRlcm5hbERvY3VtZW50Pg0KCQkJPC9yZWZlcmVuY2U+DQoJCTwvb2JzZXJ2YXRpb24+DQoJPC9lbnRyeT4NCjwvc2VjdGlvbj4NCjwvY29tcG9uZW50Pg0KCQkJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCkZ1bmN0aW9uYWwgU3RhdHVzIHNlY3Rpb24NCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQotLT4NCjxjb21wb25lbnQ+DQo8c2VjdGlvbj4NCgk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUnLz4gPCEtLSBGdW5jdGlvbmFsIHN0YXR1cyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjQ3NDIwLTUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPiANCgk8dGl0bGU+RnVuY3Rpb25hbCBTdGF0dXM8L3RpdGxlPiANCgk8dGV4dD4NCgkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJPHRyPjx0aD5GdW5jdGlvbmFsIENvbmRpdGlvbjwvdGg+IDx0aD5FZmZlY3RpdmUgRGF0ZXM8L3RoPiA8dGg+Q29uZGl0aW9uIFN0YXR1czwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQk8dHI+PHRkPkRlcGVuZGVuY2Ugb24gY2FuZTwvdGQ+PHRkPjE5OTg8L3RkPjx0ZD5BY3RpdmU8L3RkPjwvdHI+DQoJCQk8dHI+PHRkPk1lbW9yeSBpbXBhaXJtZW50PC90ZD48dGQ+MTk5OTwvdGQ+PHRkPkFjdGl2ZTwvdGQ+PC90cj4NCgkJCTwvdGJvZHk+DQoJCTwvdGFibGU+DQoJPC90ZXh0Pg0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNycvPiA8IS0tIFByb2JsZW0gYWN0IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9IjZ6MmZhODhkLTQxNzQtNDkwOS1hZWNlLWRiNDRiNjBhM2FiYiIvPg0KCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiLz4NCgkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCcvPiA8IS0tIFByb2JsZW0gb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSJmZDA3MTExYS1iMTViLTRkY2UtODUxOC0xMjc0ZDA3ZjE0MmEiLz4NCgkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+IA0KCQkJCQk8ZWZmZWN0aXZlVGltZT48bG93IHZhbHVlPSIxOTk4Ii8+PC9lZmZlY3RpdmVUaW1lPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIxMDU1MDQwMDIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJEZXBlbmRlbmNlIG9uIGNhbmUiLz4NCgkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCgkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NCcvPiA8IS0tIFN0YXR1cyBvZiBmdW5jdGlvbmFsIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiLz4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4gDQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRSIgY29kZT0iNTU1NjEwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBY3RpdmUiLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCTwvYWN0PgkNCgk8L2VudHJ5Pg0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNycvPiA8IS0tIFByb2JsZW0gYWN0IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9IjY0NjA2ZTg2LWMwODAtMTFkYi04MzE0LTA4MDAyMDBjOWE2NiIvPg0KCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiLz4NCgkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOCcvPiA8IS0tIFByb2JsZW0gb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSI2YmUyOTMwYS1jMDgwLTExZGItODMxNC0wODAwMjAwYzlhNjYiLz4NCgkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+IA0KCQkJCQk8ZWZmZWN0aXZlVGltZT48bG93IHZhbHVlPSIxOTk5Ii8+PC9lZmZlY3RpdmVUaW1lPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIzODY4MDcwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJNZW1vcnkgaW1wYWlybWVudCIvPg0KCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQ0Jy8+IDwhLS0gU3RhdHVzIG9mIGZ1bmN0aW9uYWwgc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IlN0YXR1cyIvPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPiANCgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNFIiBjb2RlPSI1NTU2MTAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFjdGl2ZSIvPg0KCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJPC9hY3Q+CQ0KCTwvZW50cnk+DQo8L3NlY3Rpb24+DQo8L2NvbXBvbmVudD4NCgkJCTwhLS0gDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KUHJvYmxlbXMgc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTEnLz4gPCEtLSBQcm9ibGVtIHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJPGNvZGUgY29kZT0iMTE0NTAtNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+IA0KCTx0aXRsZT5Qcm9ibGVtczwvdGl0bGU+IA0KCTx0ZXh0Pg0KCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+DQoJCQk8dGhlYWQ+DQoJCQkJPHRyPjx0aD5Db25kaXRpb248L3RoPjx0aD5FZmZlY3RpdmUgRGF0ZXM8L3RoPjx0aD5Db25kaXRpb24gU3RhdHVzPC90aD48L3RyPg0KCQkJPC90aGVhZD4NCgkJCTx0Ym9keT4NCgkJCQk8dHI+PHRkPkFzdGhtYTwvdGQ+PHRkPjE5NTA8L3RkPjx0ZD5BY3RpdmU8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5QbmV1bW9uaWE8L3RkPjx0ZD5KYW4gMTk5NzwvdGQ+PHRkPlJlc29sdmVkPC90ZD48L3RyPg0KCQkJCTx0cj48dGQ+IjwvdGQ+PHRkPk1hciAxOTk5PC90ZD48dGQ+UmVzb2x2ZWQ8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5NeW9jYXJkaWFsIEluZmFyY3Rpb248L3RkPjx0ZD5KYW4gMTk5NzwvdGQ+PHRkPlJlc29sdmVkPC90ZD48L3RyPgkJCQ0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3Jy8+IDwhLS0gUHJvYmxlbSBhY3QgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iNmEyZmE4OGQtNDE3NC00OTA5LWFlY2UtZGI0NGI2MGEzYWJiIi8+DQoJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIvPg0KCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4Jy8+IDwhLS0gUHJvYmxlbSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9ImQxMTI3NWU3LTY3YWUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPgkJCQkJDQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPiANCgkJCQkJPGVmZmVjdGl2ZVRpbWU+PGxvdyB2YWx1ZT0iMTk1MCIvPjwvZWZmZWN0aXZlVGltZT4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMTk1OTY3MDAxIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQXN0aG1hIi8+DQoJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTAnLz4gPCEtLSBQcm9ibGVtIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiLz4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNFIiBjb2RlPSI1NTU2MTAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFjdGl2ZSIvPg0KCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJPC9hY3Q+CQ0KCTwvZW50cnk+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3Jy8+IDwhLS0gUHJvYmxlbSBhY3QgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iZWM4YTZmZjgtZWQ0Yi00ZjdlLTgyYzMtZTk4ZTU4YjQ1ZGU3Ii8+DQoJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIvPg0KCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4Jy8+IDwhLS0gUHJvYmxlbSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9ImFiMTc5MWIwLTVjNzEtMTFkYi1iMGRlLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4gDQoJCQkJCTxlZmZlY3RpdmVUaW1lPjxsb3cgdmFsdWU9IjE5OTcwMSIvPjwvZWZmZWN0aXZlVGltZT4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMjMzNjA0MDA3IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iUG5ldW1vbmlhIi8+DQoJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTAnLz4gPCEtLSBQcm9ibGVtIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiLz4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNFIiBjb2RlPSI0MTMzMjIwMDkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJSZXNvbHZlZCIvPg0KCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJPC9hY3Q+DQoJPC9lbnRyeT4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjcnLz4gPCEtLSBQcm9ibGVtIGFjdCB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJkMTEyNzVlOS02N2FlLTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIi8+DQoJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgnLz4gPCEtLSBQcm9ibGVtIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iOWQzZDQxNmQtNDVhYi00ZGExLTkxMmYtNDU4M2UwNjMyMDAwIi8+DQoJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPiANCgkJCQkJPGVmZmVjdGl2ZVRpbWU+PGxvdyB2YWx1ZT0iMTk5OTAzIi8+PC9lZmZlY3RpdmVUaW1lPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIyMzM2MDQwMDciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJQbmV1bW9uaWEiLz4NCgkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJSRUZSIj4NCgkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MCcvPiA8IS0tIFByb2JsZW0gc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IlN0YXR1cyIvPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0UiIGNvZGU9IjQxMzMyMjAwOSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IlJlc29sdmVkIi8+DQoJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDEiLz4gPCEtLSBFcGlzb2RlIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNDA0Njg0MDAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQ2xpbmljYWwgZmluZGluZyI+DQoJCQkJCQk8cXVhbGlmaWVyPg0KCQkJCQkJCTxuYW1lIGNvZGU9IjI0NjQ1NjAwMCIgZGlzcGxheU5hbWU9IkVwaXNvZGljaXR5Ii8+DQoJCQkJCQkJPHZhbHVlIGNvZGU9IjI4ODUyNzAwOCIgZGlzcGxheU5hbWU9Ik5ldyBlcGlzb2RlIi8+DQoJCQkJCQk8L3F1YWxpZmllcj4NCgkJCQkJPC92YWx1ZT4NCgkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTQVMiPg0KCQkJCQkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPGlkIHJvb3Q9ImVjOGE2ZmY4LWVkNGItNGY3ZS04MmMzLWU5OGU1OGI0NWRlNyIvPg0KCQkJCQkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIi8+DQoJCQkJCQk8L2FjdD4NCgkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJPC9hY3Q+CQ0KCTwvZW50cnk+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPGFjdCBjbGFzc0NvZGU9IkFDVCIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI3Jy8+IDwhLS0gUHJvYmxlbSBhY3QgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iNWEyYzkwM2MtYmQ3Ny00YmQxLWFkOWQtNDUyMzgzZmJmZWZhIi8+DQoJCQk8Y29kZSBudWxsRmxhdm9yPSJOQSIvPg0KCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIj4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI4Jy8+IDwhLS0gUHJvYmxlbSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+IA0KCQkJCQk8ZWZmZWN0aXZlVGltZT48bG93IHZhbHVlPSIxOTk3MDEiLz48L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjIyMjk4MDA2IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iTXlvY2FyZGlhbCBpbmZhcmN0aW9uIi8+DQoJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTAnLz4gPCEtLSBQcm9ibGVtIHN0YXR1cyBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSIzMzk5OS00IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJTdGF0dXMiLz4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNFIiBjb2RlPSI0MTMzMjIwMDkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJSZXNvbHZlZCIvPg0KCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJPC9hY3Q+CQ0KCTwvZW50cnk+CQ0KPC9zZWN0aW9uPg0KPC9jb21wb25lbnQ+DQoJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCkZhbWlseSBIaXN0b3J5IHNlY3Rpb24NCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQotLT4NCjxjb21wb25lbnQ+DQo8c2VjdGlvbj4NCgk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQiLz4gPCEtLSBGYW1pbHkgaGlzdG9yeSBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjEwMTU3LTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPg0KCTx0aXRsZT5GYW1pbHkgaGlzdG9yeTwvdGl0bGU+DQoJPHRleHQ+DQoJCTxwYXJhZ3JhcGg+RmF0aGVyIChkZWNlYXNlZCk8L3BhcmFncmFwaD4NCgkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJCTx0cj48dGg+RGlhZ25vc2lzPC90aD48dGg+QWdlIEF0IE9uc2V0PC90aD48L3RyPg0KCQkJPC90aGVhZD4NCgkJCTx0Ym9keT4NCgkJCQk8dHI+PHRkPk15b2NhcmRpYWwgSW5mYXJjdGlvbiAoY2F1c2Ugb2YgZGVhdGgpPC90ZD48dGQ+NTc8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5IeXBlcnRlbnNpb248L3RkPjx0ZD40MDwvdGQ+PC90cj4NCgkJCTwvdGJvZHk+DQoJCTwvdGFibGU+DQoJCTxwYXJhZ3JhcGg+TW90aGVyIChhbGl2ZSk8L3BhcmFncmFwaD4NCgkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJCTx0cj48dGg+RGlhZ25vc2lzPC90aD48dGg+QWdlIEF0IE9uc2V0PC90aD48L3RyPg0KCQkJPC90aGVhZD4NCgkJCTx0Ym9keT4NCgkJCQk8dHI+PHRkPkFzdGhtYTwvdGQ+PHRkPjMwPC90ZD48L3RyPg0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPG9yZ2FuaXplciBtb29kQ29kZT0iRVZOIiBjbGFzc0NvZGU9IkNMVVNURVIiPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yMyIvPiA8IS0tIEZhbWlseSBoaXN0b3J5IG9yZ2FuaXplciB0ZW1wbGF0ZSAtLT4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPHN1YmplY3Q+DQoJCQkJPHJlbGF0ZWRTdWJqZWN0IGNsYXNzQ29kZT0iUFJTIj4NCgkJCQkJPGNvZGUgY29kZT0iOTk0NzAwOCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkJpb2xvZ2ljYWwgZmF0aGVyIi8+DQoJCQkJCTxzdWJqZWN0Pg0KCQkJCQkJPGFkbWluaXN0cmF0aXZlR2VuZGVyQ29kZSBjb2RlPSJNIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjEiIGRpc3BsYXlOYW1lPSJNYWxlIi8+DQoJCQkJCQk8YmlydGhUaW1lIHZhbHVlPSIxOTEyIi8+DQoJCQkJCTwvc3ViamVjdD4NCgkJCQk8L3JlbGF0ZWRTdWJqZWN0Pg0KCQkJPC9zdWJqZWN0Pg0KCQkJPGNvbXBvbmVudD4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjQyIi8+IDwhLS0gRmFtaWx5IGhpc3RvcnkgY2F1c2Ugb2YgZGVhdGggb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSJkNDJlYmY3MC01Yzg5LTExZGItYjBkZS0wODAwMjAwYzlhNjYiLz4NCgkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiLz4JCQ0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4JCQkJCQkNCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMjIyOTgwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJNSSIvPg0KCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IkNBVVMiPg0KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8aWQgcm9vdD0iNjg5OGZhZTAtNWM4YS0xMWRiLWIwZGUtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCQkJPGNvZGUgY29kZT0iQVNTRVJUSU9OIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjQiLz4NCgkJCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSI0MTkwOTkwMDkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJEZWFkIi8+DQoJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiIGludmVyc2lvbkluZD0idHJ1ZSI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzgiLz4gPCEtLSBBZ2Ugb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJPGNvZGUgY29kZT0iMzk3NjU5MDA4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQWdlIi8+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJJTlQiIHZhbHVlPSI1NyIvPg0KCQkJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCQkJPC9lbnRyeVJlbGF0aW9uc2hpcD4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9jb21wb25lbnQ+DQoJCQk8Y29tcG9uZW50Pg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjIiLz4gPCEtLSBGYW1pbHkgaGlzdG9yeSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9IjViZmUzZWMwLTVjOGItMTFkYi1iMGRlLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNTk2MjEwMDAiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJIVE4iLz4NCgkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjM4Ii8+IDwhLS0gQWdlIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTxjb2RlIGNvZGU9IjM5NzY1OTAwOCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFnZSIvPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSU5UIiB2YWx1ZT0iNDAiLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvY29tcG9uZW50Pg0KCQk8L29yZ2FuaXplcj4NCgk8L2VudHJ5Pg0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxvcmdhbml6ZXIgbW9vZENvZGU9IkVWTiIgY2xhc3NDb2RlPSJDTFVTVEVSIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjMiLz4gPCEtLSBGYW1pbHkgaGlzdG9yeSBvcmdhbml6ZXIgdGVtcGxhdGUgLS0+DQoJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCTxzdWJqZWN0Pg0KCQkJCTxyZWxhdGVkU3ViamVjdCBjbGFzc0NvZGU9IlBSUyI+DQoJCQkJCTxjb2RlIGNvZGU9IjY1NjU2MDA1IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQmlvbG9naWNhbCBtb3RoZXIiLz4NCgkJCQkJPHN1YmplY3Q+DQoJCQkJCQk8YWRtaW5pc3RyYXRpdmVHZW5kZXJDb2RlIGNvZGU9IkYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMSIgZGlzcGxheU5hbWU9IkZlbWFsZSIvPg0KCQkJCQkJPGJpcnRoVGltZSB2YWx1ZT0iMTkxMiIvPg0KCQkJCQk8L3N1YmplY3Q+DQoJCQkJPC9yZWxhdGVkU3ViamVjdD4NCgkJCTwvc3ViamVjdD4NCgkJCTxjb21wb25lbnQ+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yMiIvPiA8IS0tIEZhbWlseSBoaXN0b3J5IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYTEzYzYxNjAtNWM4Yi0xMWRiLWIwZGUtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+CQkJCQkJCQkNCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTxlZmZlY3RpdmVUaW1lPg0KCQkJCQkJPGxvdyB2YWx1ZT0iMTk0MiIvPg0KCQkJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjE5NTk2NzAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFzdGhtYSIvPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkJPC9vcmdhbml6ZXI+DQoJPC9lbnRyeT4NCjwvc2VjdGlvbj4NCjwvY29tcG9uZW50Pg0KCQkJPCEtLSANCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQpTb2NpYWwgSGlzdG9yeSBzZWN0aW9uDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLS0+DQo8Y29tcG9uZW50Pg0KPHNlY3Rpb24+DQoJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xNSIvPiA8IS0tIFNvY2lhbCBoaXN0b3J5IHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJPGNvZGUgY29kZT0iMjk3NjItMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+IA0KCTx0aXRsZT5Tb2NpYWwgSGlzdG9yeTwvdGl0bGU+IA0KCTx0ZXh0Pg0KCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+DQoJCQk8dGhlYWQ+DQoJCQkJPHRyPjx0aD5Tb2NpYWwgSGlzdG9yeSBFbGVtZW50PC90aD48dGg+RGVzY3JpcHRpb248L3RoPjx0aD5FZmZlY3RpdmUgRGF0ZXM8L3RoPjwvdHI+DQoJCQk8L3RoZWFkPg0KCQkJPHRib2R5Pg0KCQkJCTx0cj48dGQ+Q2lnYXJldHRlIHNtb2tpbmc8L3RkPjx0ZD4xIHBhY2sgcGVyIGRheTwvdGQ+PHRkPjE5NDcgLSAxOTcyPC90ZD48L3RyPg0KCQkJCTx0cj48dGQ+IjwvdGQ+PHRkPk5vbmU8L3RkPjx0ZD4xOTczIC0gPC90ZD48L3RyPg0KCQkJCTx0cj48dGQ+QWxjb2hvbCBjb25zdW1wdGlvbjwvdGQ+PHRkPk5vbmU8L3RkPjx0ZD4xOTczIC0gPC90ZD48L3RyPgkJCQ0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+CQ0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMzIi8+IDwhLS0gU29jaWFsIGhpc3Rvcnkgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iOWI1NmMyNWQtOTEwNC00NWVlLTlmYTQtZTBmM2FmYWEwMWMxIi8+DQoJCQk8Y29kZSBjb2RlPSIyMzAwNTYwMDQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJDaWdhcmV0dGUgc21va2luZyIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+IA0KCQkJPGVmZmVjdGl2ZVRpbWU+PGxvdyB2YWx1ZT0iMTk0NyIvPjxoaWdoIHZhbHVlPSIxOTcyIi8+PC9lZmZlY3RpdmVUaW1lPg0KCQkJPHZhbHVlIHhzaTp0eXBlPSJTVCI+MSBwYWNrIHBlciBkYXk8L3ZhbHVlPg0KCQk8L29ic2VydmF0aW9uPg0KCTwvZW50cnk+CQ0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMzIi8+IDwhLS0gU29jaWFsIGhpc3Rvcnkgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iNDVlZmI2MDQtNzA0OS00YTJlLWFkMzMtZDM4NTU2Yzk2MzZjIi8+DQoJCQk8Y29kZSBjb2RlPSIyMzAwNTYwMDQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJDaWdhcmV0dGUgc21va2luZyIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+IA0KCQkJPGVmZmVjdGl2ZVRpbWU+PGxvdyB2YWx1ZT0iMTk3MyIvPjwvZWZmZWN0aXZlVGltZT4NCgkJCTx2YWx1ZSB4c2k6dHlwZT0iU1QiPk5vbmU8L3ZhbHVlPg0KCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTVUJKIiBpbnZlcnNpb25JbmQ9InRydWUiPg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNDEiLz4gPCEtLSBFcGlzb2RlIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNDA0Njg0MDAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQ2xpbmljYWwgZmluZGluZyI+DQoJCQkJCQk8cXVhbGlmaWVyPg0KCQkJCQkJCTxuYW1lIGNvZGU9IjI0NjQ1NjAwMCIgZGlzcGxheU5hbWU9IkVwaXNvZGljaXR5Ii8+DQoJCQkJCQkJPHZhbHVlIGNvZGU9IjI4ODUyNzAwOCIgZGlzcGxheU5hbWU9Ik5ldyBlcGlzb2RlIi8+DQoJCQkJCQk8L3F1YWxpZmllcj4NCgkJCQkJPC92YWx1ZT4NCgkJCQkJPGVudHJ5UmVsYXRpb25zaGlwIHR5cGVDb2RlPSJTQVMiPg0KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8aWQgcm9vdD0iOWI1NmMyNWQtOTEwNC00NWVlLTlmYTQtZTBmM2FmYWEwMWMxIi8+DQoJCQkJCQkJPGNvZGUgY29kZT0iMjMwMDU2MDA0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQ2lnYXJldHRlIHNtb2tpbmciLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCTwvb2JzZXJ2YXRpb24+DQoJPC9lbnRyeT4JDQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzMiLz4gPCEtLSBTb2NpYWwgaGlzdG9yeSBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSIzN2Y3NmM1MS02NDExLTRlMWQtOGEzNy05NTdmZDQ5ZDJjZWYiLz4NCgkJCTxjb2RlIGNvZGU9IjE2MDU3MzAwMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkFsY29ob2wgY29uc3VtcHRpb24iLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPiANCgkJCTxlZmZlY3RpdmVUaW1lPjxsb3cgdmFsdWU9IjE5NzMiLz48L2VmZmVjdGl2ZVRpbWU+DQoJCQk8dmFsdWUgeHNpOnR5cGU9IlNUIj5Ob25lPC92YWx1ZT4NCgkJPC9vYnNlcnZhdGlvbj4NCgk8L2VudHJ5PgkNCjwvc2VjdGlvbj4NCjwvY29tcG9uZW50Pg0KCQkJPCEtLSANCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQpBbGVydHMgc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMiIvPiA8IS0tIEFsZXJ0cyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjQ4NzY1LTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPg0KCTx0aXRsZT5BbGxlcmdpZXMsIEFkdmVyc2UgUmVhY3Rpb25zLCBBbGVydHM8L3RpdGxlPg0KCTx0ZXh0Pg0KCQk8dGFibGUgYm9yZGVyPSIxIiB3aWR0aD0iMTAwJSI+DQoJCQk8dGhlYWQ+DQoJCQkJPHRyPjx0aD5TdWJzdGFuY2U8L3RoPjx0aD5SZWFjdGlvbjwvdGg+PHRoPlN0YXR1czwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQkJPHRyPjx0ZD5QZW5pY2lsbGluPC90ZD48dGQ+SGl2ZXM8L3RkPjx0ZD5BY3RpdmU8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5Bc3BpcmluPC90ZD48dGQ+V2hlZXppbmc8L3RkPjx0ZD5BY3RpdmU8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5Db2RlaW5lPC90ZD48dGQ+TmF1c2VhPC90ZD48dGQ+QWN0aXZlPC90ZD48L3RyPg0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+CQ0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNycvPiA8IS0tIFByb2JsZW0gYWN0IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9IjM2ZTNlOTMwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiLz4NCgkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xOCcvPiA8IS0tIEFsZXJ0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iNGFkYzEwMjAtN2IxNC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+CQkJCQkNCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+IA0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIyODIxMDAwMDkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBZHZlcnNlIHJlYWN0aW9uIHRvIHN1YnN0YW5jZSIvPg0KCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQoJCQkJCQkJPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJNTUFUIj4NCgkJCQkJCQkJPGNvZGUgY29kZT0iNzA2MTgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiICBkaXNwbGF5TmFtZT0iUGVuaWNpbGxpbiIvPg0KCQkJCQkJCTwvcGxheWluZ0VudGl0eT4NCgkJCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJCQk8L3BhcnRpY2lwYW50Pg0KCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9Ik1GU1QiIGludmVyc2lvbkluZD0idHJ1ZSI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTQnLz4gPCEtLSBSZWFjdGlvbiBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjI0NzQ3MjAwNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkhpdmVzIi8+DQoJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlJFRlIiPg0KCQkJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJCQk8dGVtcGxhdGVJZCByb290PScyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjM5Jy8+IDwhLS0gQWxlcnQgc3RhdHVzIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTxjb2RlIGNvZGU9IjMzOTk5LTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IlN0YXR1cyIvPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0UiIGNvZGU9IjU1NTYxMDAzIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQWN0aXZlIi8+DQoJCQkJCQk8L29ic2VydmF0aW9uPg0KCQkJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQk8L2FjdD4JDQoJPC9lbnRyeT4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8YWN0IGNsYXNzQ29kZT0iQUNUIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjcnLz4gPCEtLSBQcm9ibGVtIGFjdCB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJlYjkzNjAxMC03YjE3LTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4NCgkJCTxjb2RlIG51bGxGbGF2b3I9Ik5BIi8+DQoJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9IlNVQkoiPg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTgnLz4gPCEtLSBBbGVydCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9ImViOTM2MDExLTdiMTctMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPgkJCQkJDQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPiANCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iMjgyMTAwMDA5IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQWR2ZXJzZSByZWFjdGlvbiB0byBzdWJzdGFuY2UiLz4NCgkJCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJDU00iPg0KCQkJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQkJCTxwbGF5aW5nRW50aXR5IGNsYXNzQ29kZT0iTU1BVCI+DQoJCQkJCQkJCTxjb2RlIGNvZGU9IjExOTEiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiICBkaXNwbGF5TmFtZT0iQXNwaXJpbiIvPg0KCQkJCQkJCTwvcGxheWluZ0VudGl0eT4NCgkJCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJCQk8L3BhcnRpY2lwYW50Pg0KCQkJCQk8ZW50cnlSZWxhdGlvbnNoaXAgdHlwZUNvZGU9Ik1GU1QiIGludmVyc2lvbkluZD0idHJ1ZSI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTQnLz4gPCEtLSBSZWFjdGlvbiBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPg0KCQkJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iQ0QiIGNvZGU9IjU2MDE4MDA0IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iV2hlZXppbmciLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzknLz4gPCEtLSBBbGVydCBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iU3RhdHVzIi8+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRSIgY29kZT0iNTU1NjEwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBY3RpdmUiLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCTwvYWN0PgkNCgk8L2VudHJ5Pg0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxhY3QgY2xhc3NDb2RlPSJBQ1QiIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNycvPiA8IS0tIFByb2JsZW0gYWN0IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9ImMzZGYzYjYxLTdiMTgtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJPGNvZGUgbnVsbEZsYXZvcj0iTkEiLz4NCgkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iU1VCSiI+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xOCcvPiA8IS0tIEFsZXJ0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYzNkZjNiNjAtN2IxOC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+CQkJCQkNCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+IA0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNEIiBjb2RlPSIyODIxMDAwMDkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBZHZlcnNlIHJlYWN0aW9uIHRvIHN1YnN0YW5jZSIvPg0KCQkJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkNTTSI+DQoJCQkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQoJCQkJCQkJPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJNTUFUIj4NCgkJCQkJCQkJPGNvZGUgY29kZT0iMjY3MCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi44OCIgIGRpc3BsYXlOYW1lPSJDb2RlaW5lIi8+DQoJCQkJCQkJPC9wbGF5aW5nRW50aXR5Pg0KCQkJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQkJCTwvcGFydGljaXBhbnQ+DQoJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iTUZTVCIgaW52ZXJzaW9uSW5kPSJ0cnVlIj4NCgkJCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCQkJPHRlbXBsYXRlSWQgcm9vdD0nMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41NCcvPiA8IS0tIFJlYWN0aW9uIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRCIgY29kZT0iNzM4NzkwMDciIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJOYXVzZWEiLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUkVGUiI+DQoJCQkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9JzIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzknLz4gPCEtLSBBbGVydCBzdGF0dXMgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCQkJPGNvZGUgY29kZT0iMzM5OTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iU3RhdHVzIi8+DQoJCQkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRSIgY29kZT0iNTU1NjEwMDMiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJBY3RpdmUiLz4NCgkJCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvZW50cnlSZWxhdGlvbnNoaXA+DQoJCTwvYWN0PgkNCgk8L2VudHJ5Pg0KPC9zZWN0aW9uPg0KPC9jb21wb25lbnQ+DQoJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCk1lZGljYXRpb25zIHNlY3Rpb24NCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQotLT4NCjxjb21wb25lbnQ+DQo8c2VjdGlvbj4NCgk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjgiLz4gPCEtLSBNZWRpY2F0aW9ucyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjEwMTYwLTAiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPg0KCTx0aXRsZT5NZWRpY2F0aW9uczwvdGl0bGU+DQoJPHRleHQ+DQoJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCTx0aGVhZD4NCgkJCQk8dHI+PHRoPk1lZGljYXRpb248L3RoPjx0aD5JbnN0cnVjdGlvbnM8L3RoPjx0aD5TdGFydCBEYXRlPC90aD48dGg+U3RhdHVzPC90aD48L3RyPg0KCQkJPC90aGVhZD4NCgkJCTx0Ym9keT4NCgkJCQk8dHI+PHRkPkFsYnV0ZXJvbCBpbmhhbGFudDwvdGQ+PHRkPjIgcHVmZnMgUUlEIFBSTiB3aGVlemluZzwvdGQ+PHRkPiYjMTYwOzwvdGQ+PHRkPkFjdGl2ZTwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkPkNsb3BpZG9ncmVsIChQbGF2aXgpPC90ZD48dGQ+NzVtZyBQTyBkYWlseTwvdGQ+PHRkPiYjMTYwOzwvdGQ+PHRkPkFjdGl2ZTwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkPk1ldG9wcm9sb2w8L3RkPjx0ZD4yNW1nIFBPIEJJRDwvdGQ+PHRkPiYjMTYwOzwvdGQ+PHRkPkFjdGl2ZTwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkPlByZWRuaXNvbmU8L3RkPjx0ZD4yMG1nIFBPIGRhaWx5PC90ZD48dGQ+TWFyIDI4LCAyMDAwPC90ZD48dGQ+QWN0aXZlPC90ZD48L3RyPg0KCQkJCTx0cj48dGQ+Q2VwaGFsZXhpbiAoS2VmbGV4KTwvdGQ+PHRkPjUwMG1nIFBPIFFJRCB4IDcgZGF5cyAoZm9yIGJyb25jaGl0aXMpPC90ZD48dGQ+TWFyIDI4LCAyMDAwPC90ZD48dGQ+Tm8gbG9uZ2VyIGFjdGl2ZTwvdGQ+PC90cj4NCgkJCTwvdGJvZHk+DQoJCTwvdGFibGU+DQoJPC90ZXh0Pg0KCQk8aW5mb3JtYW50Pg0KCQk8YXNzaWduZWRFbnRpdHk+DQoJCQk8aWQgZXh0ZW5zaW9uPSI5OTYtNzU2LTQ5NSIgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTkuNSIvPg0KCQkJPHJlcHJlc2VudGVkT3JnYW5pemF0aW9uPg0KCQkJCTxpZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ii8+DQoJCQkJPG5hbWU+R29vZCBIZWFsdGggQ2xpbmljPC9uYW1lPg0KCQkJPC9yZXByZXNlbnRlZE9yZ2FuaXphdGlvbj4NCgkJPC9hc3NpZ25lZEVudGl0eT4NCgk8L2luZm9ybWFudD4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI0Ii8+IDwhLS0gTWVkaWNhdGlvbiBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJjZGJkMzNmMC02Y2RlLTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IlBJVkxfVFMiPg0KCQkJCTxwZXJpb2QgdmFsdWU9IjYiIHVuaXQ9ImgiLz4NCgkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCTxyb3V0ZUNvZGUgY29kZT0iSVBJTkhMIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMiIgY29kZVN5c3RlbU5hbWU9IlJvdXRlT2ZBZG1pbmlzdHJhdGlvbiIgZGlzcGxheU5hbWU9IkluaGFsYXRpb24sIG9yYWwiLz4NCgkJCTxkb3NlUXVhbnRpdHkgdmFsdWU9IjIiLz4NCgkJCTxhZG1pbmlzdHJhdGlvblVuaXRDb2RlIGNvZGU9IjQxNTIxNTAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IlB1ZmYiLz4NCgkJCTxjb25zdW1hYmxlPg0KCQkJCTxtYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUzIi8+IDwhLS0gUHJvZHVjdCB0ZW1wbGF0ZSAtLT4NCgkJCQkJPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCQkJPGNvZGUgY29kZT0iMzA3NzgyIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiAgZGlzcGxheU5hbWU9IkFsYnV0ZXJvbCAwLjA5IE1HL0FDVFVBVCBpbmhhbGFudCBzb2x1dGlvbiI+DQoJCQkJCQkJPG9yaWdpbmFsVGV4dD5BbGJ1dGVyb2wgaW5oYWxhbnQ8L29yaWdpbmFsVGV4dD4NCgkJCQkJCTwvY29kZT4NCgkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQk8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQk8L2NvbnN1bWFibGU+DQoJCQk8cHJlY29uZGl0aW9uIHR5cGVDb2RlPSJQUkNOIj4NCgkJCQk8Y3JpdGVyaW9uPg0KCQkJCQk8Y29kZSBjb2RlPSJBU1NFUlRJT04iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIvPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IkNFIiBjb2RlPSI1NjAxODAwNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgIGRpc3BsYXlOYW1lPSJXaGVlemluZyIvPg0KCQkJCTwvY3JpdGVyaW9uPg0KCQkJPC9wcmVjb25kaXRpb24+DQoJCTwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQoJPC9lbnRyeT4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI0Ii8+IDwhLS0gTWVkaWNhdGlvbiBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJjZGJkNWIwNS02Y2RlLTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IlBJVkxfVFMiPg0KCQkJCTxwZXJpb2QgdmFsdWU9IjI0IiB1bml0PSJoIi8+DQoJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQk8cm91dGVDb2RlIGNvZGU9IlBPIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMiIgY29kZVN5c3RlbU5hbWU9IlJvdXRlT2ZBZG1pbmlzdHJhdGlvbiIvPg0KCQkJPGRvc2VRdWFudGl0eSB2YWx1ZT0iMSIvPg0KCQkJPGNvbnN1bWFibGU+DQoJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTMiLz4gPCEtLSBQcm9kdWN0IHRlbXBsYXRlIC0tPg0KCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQk8Y29kZSBjb2RlPSIzMDkzNjIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiICBkaXNwbGF5TmFtZT0iQ2xvcGlkb2dyZWwgNzUgTUcgb3JhbCB0YWJsZXQiPg0KCQkJCQkJCTxvcmlnaW5hbFRleHQ+Q2xvcGlkb2dyZWw8L29yaWdpbmFsVGV4dD4NCgkJCQkJCTwvY29kZT4NCgkJCQkJCTxuYW1lPlBsYXZpeDwvbmFtZT4NCgkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQk8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQk8L2NvbnN1bWFibGU+DQoJCTwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQoJPC9lbnRyeT4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI0Ii8+IDwhLS0gTWVkaWNhdGlvbiBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJjZGJkNWIwMS02Y2RlLTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImFjdGl2ZSIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IlBJVkxfVFMiPg0KCQkJCTxwZXJpb2QgdmFsdWU9IjEyIiB1bml0PSJoIi8+DQoJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQk8cm91dGVDb2RlIGNvZGU9IlBPIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMiIgY29kZVN5c3RlbU5hbWU9IlJvdXRlT2ZBZG1pbmlzdHJhdGlvbiIvPg0KCQkJPGRvc2VRdWFudGl0eSB2YWx1ZT0iMSIvPg0KCQkJPGNvbnN1bWFibGU+DQoJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTMiLz4gPCEtLSBQcm9kdWN0IHRlbXBsYXRlIC0tPg0KCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQk8Y29kZSBjb2RlPSI0MzA2MTgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiICBkaXNwbGF5TmFtZT0iTWV0b3Byb2xvbCAyNSBNRyBvcmFsIHRhYmxldCI+DQoJCQkJCQkJPG9yaWdpbmFsVGV4dD5NZXRvcHJvbG9sPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQk8L2NvZGU+DQoJCQkJCTwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJPC9jb25zdW1hYmxlPg0KCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KCTwvZW50cnk+CQkJCQ0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjQiLz4gPCEtLSBNZWRpY2F0aW9uIGFjdGl2aXR5IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9ImNkYmQ1YjAzLTZjZGUtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0iYWN0aXZlIi8+DQoJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCgkJCQk8bG93IHZhbHVlPSIyMDAwMDMyOCIvPg0KCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IlBJVkxfVFMiIG9wZXJhdG9yPSJBIj4NCgkJCQk8cGVyaW9kIHZhbHVlPSIyNCIgdW5pdD0iaCIvPg0KCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJPHJvdXRlQ29kZSBjb2RlPSJQTyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTIiIGNvZGVTeXN0ZW1OYW1lPSJSb3V0ZU9mQWRtaW5pc3RyYXRpb24iLz4NCgkJCTxkb3NlUXVhbnRpdHkgdmFsdWU9IjEiLz4NCgkJCTxjb25zdW1hYmxlPg0KCQkJCTxtYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUzIi8+IDwhLS0gUHJvZHVjdCB0ZW1wbGF0ZSAtLT4NCgkJCQkJPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCQkJPGNvZGUgY29kZT0iMzEyNjE1IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljg4IiAgZGlzcGxheU5hbWU9IlByZWRuaXNvbmUgMjAgTUcgb3JhbCB0YWJsZXQiPg0KCQkJCQkJCTxvcmlnaW5hbFRleHQ+UHJlZG5pc29uZTwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJPC9jb2RlPg0KCQkJCQk8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCgkJCTwvY29uc3VtYWJsZT4NCgkJPC9zdWJzdGFuY2VBZG1pbmlzdHJhdGlvbj4NCgk8L2VudHJ5Pg0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxzdWJzdGFuY2VBZG1pbmlzdHJhdGlvbiBjbGFzc0NvZGU9IlNCQURNIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjQiLz4gPCEtLSBNZWRpY2F0aW9uIGFjdGl2aXR5IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9ImNkYmQ1YjA3LTZjZGUtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCgkJCQk8bG93IHZhbHVlPSIyMDAwMDMyOCIvPg0KCQkJCTxoaWdoIHZhbHVlPSIyMDAwMDQwNCIvPg0KCQkJPC9lZmZlY3RpdmVUaW1lPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IlBJVkxfVFMiIG9wZXJhdG9yPSJBIj4NCgkJCQk8cGVyaW9kIHZhbHVlPSI2IiB1bml0PSJoIi8+DQoJCQk8L2VmZmVjdGl2ZVRpbWU+DQoJCQk8cm91dGVDb2RlIGNvZGU9IlBPIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMiIgY29kZVN5c3RlbU5hbWU9IlJvdXRlT2ZBZG1pbmlzdHJhdGlvbiIvPg0KCQkJPGRvc2VRdWFudGl0eSB2YWx1ZT0iMSIvPg0KCQkJPGNvbnN1bWFibGU+DQoJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTMiLz4gPCEtLSBQcm9kdWN0IHRlbXBsYXRlIC0tPg0KCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQk8Y29kZSBjb2RlPSIxOTc0NTQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuODgiICBkaXNwbGF5TmFtZT0iQ2VwaGFsZXhpbiA1MDAgTUcgb3JhbCB0YWJsZXQiPg0KCQkJCQkJCTxvcmlnaW5hbFRleHQ+Q2VwaGFsZXhpbjwvb3JpZ2luYWxUZXh0Pg0KCQkJCQkJPC9jb2RlPg0KCQkJCQkJPG5hbWU+S2VmbGV4PC9uYW1lPg0KCQkJCQk8L21hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCTwvbWFudWZhY3R1cmVkUHJvZHVjdD4NCgkJCTwvY29uc3VtYWJsZT4NCgkJCTxlbnRyeVJlbGF0aW9uc2hpcCB0eXBlQ29kZT0iUlNPTiI+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iQ09ORCIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjgiLz4gPCEtLSBQcm9ibGVtIG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iY2RiZDViMDgtNmNkZS0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IkFTU0VSVElPTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS40Ii8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj4NCgkJCQkJCTxsb3cgdmFsdWU9IjIwMDAwMzI4Ii8+DQoJCQkJCTwvZWZmZWN0aXZlVGltZT4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJDRSIgY29kZT0iMzIzOTgwMDQiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiICBkaXNwbGF5TmFtZT0iQnJvbmNoaXRpcyIvPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2VudHJ5UmVsYXRpb25zaGlwPg0KCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KCTwvZW50cnk+DQo8L3NlY3Rpb24+DQo8L2NvbXBvbmVudD4NCgkJCTwhLS0gDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KTWVkaWNhbCBFcXVpcG1lbnQgc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNyIvPiA8IS0tIE1lZGljYWwgZXF1aXBtZW50IHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJPGNvZGUgY29kZT0iNDYyNjQtOCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+DQoJPHRpdGxlPk1lZGljYWwgRXF1aXBtZW50PC90aXRsZT4NCgk8dGV4dD4NCgkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJCTx0cj48dGg+U3VwcGx5L0RldmljZTwvdGg+PHRoPkRhdGUgU3VwcGxpZWQ8L3RoPjwvdHI+DQoJCQk8L3RoZWFkPg0KCQkJPHRib2R5Pg0KCQkJCTx0cj48dGQ+QXV0b21hdGljIGltcGxhbnRhYmxlIGNhcmRpb3ZlcnRlci9kZWZpYnJpbGxhdG9yPC90ZD48dGQ+Tm92IDE5OTk8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5Ub3RhbCBoaXAgcmVwbGFjZW1lbnQgcHJvc3RoZXNpczwvdGQ+PHRkPjE5OTg8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5XaGVlbGNoYWlyPC90ZD48dGQ+MTk5OTwvdGQ+PC90cj4NCgkJCTwvdGJvZHk+DQoJCTwvdGFibGU+DQoJPC90ZXh0Pg0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxzdXBwbHkgY2xhc3NDb2RlPSJTUExZIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzQiLz4gPCEtLSBTdXBwbHkgYWN0aXZpdHkgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iMjQxMzc3M2MtMjM3Mi00Mjk5LWJiZTYtNWIwZjYwNjY0NDQ2Ii8+DQoJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCTxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPjxjZW50ZXIgdmFsdWU9IjE5OTkxMSIvPjwvZWZmZWN0aXZlVGltZT4NCgkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iREVWIj4NCgkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTIiLz4gPCEtLSBQcm9kdWN0IGluc3RhbmNlIHRlbXBsYXRlIC0tPg0KCQkJCQk8cGxheWluZ0RldmljZT4NCgkJCQkJCTxjb2RlIGNvZGU9IjcyNTA2MDAxIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQXV0b21hdGljIGltcGxhbnRhYmxlIGNhcmRpb3ZlcnRlci9kZWZpYnJpbGxhdG9yIi8+DQoJCQkJCTwvcGxheWluZ0RldmljZT4NCgkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCTwvcGFydGljaXBhbnQ+DQoJCTwvc3VwcGx5Pg0KCTwvZW50cnk+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPHN1cHBseSBjbGFzc0NvZGU9IlNQTFkiIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zNCIvPiA8IS0tIFN1cHBseSBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSIyMzBiMGFiNy0yMDZkLTQyZDgtYTk0Ny1hYjRmNjNhYWQ3OTUiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+PGNlbnRlciB2YWx1ZT0iMTk5OCIvPjwvZWZmZWN0aXZlVGltZT4NCgkJCTxwYXJ0aWNpcGFudCB0eXBlQ29kZT0iREVWIj4NCgkJCQk8cGFydGljaXBhbnRSb2xlIGNsYXNzQ29kZT0iTUFOVSI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTIiLz4gPCEtLSBQcm9kdWN0IGluc3RhbmNlIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iMDNjYTAxYjAtN2JlMS0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxwbGF5aW5nRGV2aWNlPg0KCQkJCQkJPGNvZGUgY29kZT0iMzA0MTIwMDA3IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iVG90YWwgaGlwIHJlcGxhY2VtZW50IHByb3N0aGVzaXMiLz4NCgkJCQkJPC9wbGF5aW5nRGV2aWNlPg0KCQkJCQk8c2NvcGluZ0VudGl0eT4NCgkJCQkJCTxpZCByb290PSIwYWJlYTk1MC01YjQwLTRiN2UtYjhkOS0yYTVlYTNhYzU1MDAiLz4NCgkJCQkJCTxkZXNjPkdvb2QgSGVhbHRoIFByb3N0aGVzZXMgQ29tcGFueTwvZGVzYz4NCgkJCQkJPC9zY29waW5nRW50aXR5Pg0KCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJPC9wYXJ0aWNpcGFudD4NCgkJPC9zdXBwbHk+DQoJPC9lbnRyeT4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8c3VwcGx5IGNsYXNzQ29kZT0iU1BMWSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjM0Ii8+IDwhLS0gU3VwcGx5IGFjdGl2aXR5IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9ImM0ZmZlOThlLTNjZDMtNGM1NC1iNWJkLTA4ZWNiODAzNzllMCIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQk8ZWZmZWN0aXZlVGltZSB4c2k6dHlwZT0iSVZMX1RTIj48Y2VudGVyIHZhbHVlPSIxOTk5Ii8+PC9lZmZlY3RpdmVUaW1lPg0KCQkJPHBhcnRpY2lwYW50IHR5cGVDb2RlPSJERVYiPg0KCQkJCTxwYXJ0aWNpcGFudFJvbGUgY2xhc3NDb2RlPSJNQU5VIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MiIvPiA8IS0tIFByb2R1Y3QgaW5zdGFuY2UgdGVtcGxhdGUgLS0+DQoJCQkJCTxwbGF5aW5nRGV2aWNlPg0KCQkJCQkJPGNvZGUgY29kZT0iNTg5MzgwMDgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJXaGVlbGNoYWlyIi8+DQoJCQkJCTwvcGxheWluZ0RldmljZT4NCgkJCQk8L3BhcnRpY2lwYW50Um9sZT4NCgkJCTwvcGFydGljaXBhbnQ+DQoJCTwvc3VwcGx5Pg0KCTwvZW50cnk+DQo8L3NlY3Rpb24+DQo8L2NvbXBvbmVudD4NCgkJCTwhLS0gDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KSW1tdW5pemF0aW9ucyBzZWN0aW9uDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLS0+DQo8Y29tcG9uZW50Pg0KPHNlY3Rpb24+DQoJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS42Ii8+IDwhLS0gSW1tdW5pemF0aW9ucyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjExMzY5LTYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPg0KCTx0aXRsZT5JbW11bml6YXRpb25zPC90aXRsZT4NCgk8dGV4dD4NCgkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJCTx0cj48dGg+VmFjY2luZTwvdGg+PHRoPkRhdGU8L3RoPjx0aD5TdGF0dXM8L3RoPjwvdHI+DQoJCQk8L3RoZWFkPg0KCQkJPHRib2R5Pg0KCQkJCTx0cj48dGQ+SW5mbHVlbnphIHZpcnVzIHZhY2NpbmUsIElNPC90ZD48dGQ+Tm92IDE5OTk8L3RkPjx0ZD5Db21wbGV0ZWQ8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5JbmZsdWVuemEgdmlydXMgdmFjY2luZSwgSU08L3RkPjx0ZD5EZWMgMTk5ODwvdGQ+PHRkPkNvbXBsZXRlZDwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkPlBuZXVtb2NvY2NhbCBwb2x5c2FjY2hhcmlkZSB2YWNjaW5lLCBJTTwvdGQ+PHRkPkRlYyAxOTk4PC90ZD48dGQ+Q29tcGxldGVkPC90ZD48L3RyPg0KCQkJCTx0cj48dGQ+VGV0YW51cyBhbmQgZGlwaHRoZXJpYSB0b3hvaWRzLCBJTTwvdGQ+PHRkPjE5OTc8L3RkPjx0ZD5Db21wbGV0ZWQ8L3RkPjwvdHI+DQoJCQk8L3Rib2R5Pg0KCQk8L3RhYmxlPg0KCTwvdGV4dD4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI0Ii8+IDwhLS0gTWVkaWNhdGlvbiBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJlNmYxYmE0My1jMGVkLTRiOWItOWYxMi1mNDM1ZDhhZDhmOTIiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+PGNlbnRlciB2YWx1ZT0iMTk5OTExIi8+PC9lZmZlY3RpdmVUaW1lPg0KCQkJPHJvdXRlQ29kZSBjb2RlPSJJTSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTIiIGNvZGVTeXN0ZW1OYW1lPSJSb3V0ZU9mQWRtaW5pc3RyYXRpb24iIGRpc3BsYXlOYW1lPSJJbnRyYW11c2N1bGFyIGluamVjdGlvbiIvPgkJDQoJCQk8Y29uc3VtYWJsZT4NCgkJCQk8bWFudWZhY3R1cmVkUHJvZHVjdD4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS41MyIvPiA8IS0tIFByb2R1Y3QgdGVtcGxhdGUgLS0+DQoJCQkJCTxtYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQkJCTxjb2RlIGNvZGU9Ijg4IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjU5IiBkaXNwbGF5TmFtZT0iSW5mbHVlbnphIHZpcnVzIHZhY2NpbmUiPg0KCQkJCQkJCTxvcmlnaW5hbFRleHQ+SW5mbHVlbnphIHZpcnVzIHZhY2NpbmU8L29yaWdpbmFsVGV4dD4NCgkJCQkJCTwvY29kZT4NCgkJCQkJPC9tYW51ZmFjdHVyZWRNYXRlcmlhbD4NCgkJCQk8L21hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQk8L2NvbnN1bWFibGU+DQoJCTwvc3Vic3RhbmNlQWRtaW5pc3RyYXRpb24+DQoJPC9lbnRyeT4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8c3Vic3RhbmNlQWRtaW5pc3RyYXRpb24gY2xhc3NDb2RlPSJTQkFETSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjI0Ii8+IDwhLS0gTWVkaWNhdGlvbiBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSIxMTVmMGY3MC0xMzQzLTQ5MzgtYjYyZi02MzFkZTk3NDlhMGEiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgeHNpOnR5cGU9IklWTF9UUyI+PGNlbnRlciB2YWx1ZT0iMTk5ODEyIi8+PC9lZmZlY3RpdmVUaW1lPg0KCQkJPHJvdXRlQ29kZSBjb2RlPSJJTSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS4xMTIiIGNvZGVTeXN0ZW1OYW1lPSJSb3V0ZU9mQWRtaW5pc3RyYXRpb24iIGRpc3BsYXlOYW1lPSJJbnRyYW11c2N1bGFyIGluamVjdGlvbiIvPgkJCQ0KCQkJPGNvbnN1bWFibGU+DQoJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTMiLz4gPCEtLSBQcm9kdWN0IHRlbXBsYXRlIC0tPg0KCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQk8Y29kZSBjb2RlPSI4OCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi41OSIgZGlzcGxheU5hbWU9IkluZmx1ZW56YSB2aXJ1cyB2YWNjaW5lIj4NCgkJCQkJCQk8b3JpZ2luYWxUZXh0PkluZmx1ZW56YSB2aXJ1cyB2YWNjaW5lPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQk8L2NvZGU+DQoJCQkJCTwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJPC9jb25zdW1hYmxlPg0KCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KCTwvZW50cnk+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNCIvPiA8IS0tIE1lZGljYXRpb24gYWN0aXZpdHkgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iNzg1OTg0MDctOWYxNi00MmQ1LThmZmQtMDkyODFhNjBmZTMzIi8+DQoJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCTxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPjxjZW50ZXIgdmFsdWU9IjE5OTgxMiIvPjwvZWZmZWN0aXZlVGltZT4NCgkJCTxyb3V0ZUNvZGUgY29kZT0iSU0iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuMTEyIiBjb2RlU3lzdGVtTmFtZT0iUm91dGVPZkFkbWluaXN0cmF0aW9uIiBkaXNwbGF5TmFtZT0iSW50cmFtdXNjdWxhciBpbmplY3Rpb24iLz4JCQ0KCQkJPGNvbnN1bWFibGU+DQoJCQkJPG1hbnVmYWN0dXJlZFByb2R1Y3Q+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuNTMiLz4gPCEtLSBQcm9kdWN0IHRlbXBsYXRlIC0tPg0KCQkJCQk8bWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJCQk8Y29kZSBjb2RlPSIzMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi41OSIgZGlzcGxheU5hbWU9IlBuZXVtb2NvY2NhbCBwb2x5c2FjY2hhcmlkZSB2YWNjaW5lIj4NCgkJCQkJCQk8b3JpZ2luYWxUZXh0PlBuZXVtb2NvY2NhbCBwb2x5c2FjY2hhcmlkZSB2YWNjaW5lPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQk8L2NvZGU+DQoJCQkJCTwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJPC9jb25zdW1hYmxlPg0KCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KCTwvZW50cnk+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPHN1YnN0YW5jZUFkbWluaXN0cmF0aW9uIGNsYXNzQ29kZT0iU0JBRE0iIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yNCIvPiA8IS0tIE1lZGljYXRpb24gYWN0aXZpdHkgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iMjYxZTk0YTAtOTVmYi00OTc1LWI1YTUtYzhlMTJjMDFjMWJjIi8+DQoJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCTxlZmZlY3RpdmVUaW1lIHhzaTp0eXBlPSJJVkxfVFMiPjxjZW50ZXIgdmFsdWU9IjE5OTciLz48L2VmZmVjdGl2ZVRpbWU+DQoJCQk8cm91dGVDb2RlIGNvZGU9IklNIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjExMiIgY29kZVN5c3RlbU5hbWU9IlJvdXRlT2ZBZG1pbmlzdHJhdGlvbiIgZGlzcGxheU5hbWU9IkludHJhbXVzY3VsYXIgaW5qZWN0aW9uIi8+CQkNCgkJCTxjb25zdW1hYmxlPg0KCQkJCTxtYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUzIi8+IDwhLS0gUHJvZHVjdCB0ZW1wbGF0ZSAtLT4NCgkJCQkJPG1hbnVmYWN0dXJlZE1hdGVyaWFsPg0KCQkJCQkJPGNvZGUgY29kZT0iMDkiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuNTkiIGRpc3BsYXlOYW1lPSJUZXRhbnVzIGFuZCBkaXBodGhlcmlhIHRveG9pZHMiPg0KCQkJCQkJCTxvcmlnaW5hbFRleHQ+VGV0YW51cyBhbmQgZGlwaHRoZXJpYSB0b3hvaWRzPC9vcmlnaW5hbFRleHQ+DQoJCQkJCQk8L2NvZGU+DQoJCQkJCTwvbWFudWZhY3R1cmVkTWF0ZXJpYWw+DQoJCQkJPC9tYW51ZmFjdHVyZWRQcm9kdWN0Pg0KCQkJPC9jb25zdW1hYmxlPg0KCQk8L3N1YnN0YW5jZUFkbWluaXN0cmF0aW9uPg0KCTwvZW50cnk+DQo8L3NlY3Rpb24+DQo8L2NvbXBvbmVudD4NCgkJCTwhLS0gDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KVml0YWwgU2lnbnMgc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTYiLz4gPCEtLSBWaXRhbCBzaWducyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9Ijg3MTYtMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+DQoJPHRpdGxlPlZpdGFsIFNpZ25zPC90aXRsZT4NCgk8dGV4dD4NCgkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJCTx0cj48dGggYWxpZ249InJpZ2h0Ij5EYXRlIC8gVGltZTogPC90aD48dGg+Tm92IDE0LCAxOTk5PC90aD48dGg+QXByaWwgNywgMjAwMDwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQkJPHRyPjx0aCBhbGlnbj0ibGVmdCI+SGVpZ2h0PC90aD48dGQ+MTc3IGNtPC90ZD48dGQ+MTc3IGNtPC90ZD48L3RyPg0KCQkJCTx0cj48dGggYWxpZ249ImxlZnQiPldlaWdodDwvdGg+PHRkPjg2IGtnPC90ZD48dGQ+ODgga2c8L3RkPjwvdHI+DQoJCQkJPHRyPjx0aCBhbGlnbj0ibGVmdCI+Qmxvb2QgUHJlc3N1cmU8L3RoPjx0ZD4xMzIvODYgbW1IZzwvdGQ+PHRkPjE0NS84OCBtbUhnPC90ZD48L3RyPg0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPG9yZ2FuaXplciBjbGFzc0NvZGU9IkNMVVNURVIiIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zNSIvPiA8IS0tIFZpdGFsIHNpZ25zIG9yZ2FuaXplciB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJjNmY4ODMyMC02N2FkLTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCTxjb2RlIGNvZGU9IjQ2NjgwMDA1IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iVml0YWwgc2lnbnMiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjE5OTkxMTE0Ii8+DQoJCQk8Y29tcG9uZW50Pg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzEiLz4gPCEtLSBSZXN1bHQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSJjNmY4ODMyMS02N2FkLTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCQkJPGNvZGUgY29kZT0iNTAzNzMwMDAiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJCb2R5IGhlaWdodCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjE5OTkxMTE0Ii8+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSIxNzciIHVuaXQ9ImNtIi8+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvY29tcG9uZW50Pg0KCQkJPGNvbXBvbmVudD4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIi8+IDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYzZmODgzMjItNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IjI3MTEzMDAxIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQm9keSB3ZWlnaHQiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIxOTk5MTExNCIvPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlBRIiB2YWx1ZT0iODYiIHVuaXQ9ImtnIi8+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvY29tcG9uZW50Pg0KCQkJPGNvbXBvbmVudD4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIi8+IDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYzZmODgzMjMtNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IjI3MTY0OTAwNiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IlN5c3RvbGljIEJQIi8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMTk5OTExMTQiLz4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjEzMiIgdW5pdD0ibW1bSGddIi8+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvY29tcG9uZW50Pg0KCQkJPGNvbXBvbmVudD4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIi8+IDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYzZmODgzMjQtNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IjI3MTY1MDAwNiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkRpYXN0b2xpYyBCUCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjE5OTkxMTE0Ii8+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSI4NiIgdW5pdD0ibW1bSGddIi8+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvY29tcG9uZW50Pg0KCQk8L29yZ2FuaXplcj4NCgk8L2VudHJ5Pg0KCTxlbnRyeSB0eXBlQ29kZT0iRFJJViI+DQoJCTxvcmdhbml6ZXIgY2xhc3NDb2RlPSJDTFVTVEVSIiBtb29kQ29kZT0iRVZOIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzUiLz4gPCEtLSBWaXRhbCBzaWducyBvcmdhbml6ZXIgdGVtcGxhdGUgLS0+DQoJCQk8aWQgcm9vdD0iZDExMjc1ZTAtNjdhZS0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+DQoJCQk8Y29kZSBjb2RlPSI0NjY4MDAwNSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IlZpdGFsIHNpZ25zIi8+DQoJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDAwMDQwNyIvPg0KCQkJPGNvbXBvbmVudD4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIi8+IDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iZDExMjc1ZTEtNjdhZS0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IjUwMzczMDAwIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQm9keSBoZWlnaHQiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDAwMDQwNyIvPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlBRIiB2YWx1ZT0iMTc3IiB1bml0PSJjbSIvPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkJCTxjb21wb25lbnQ+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zMSIvPiA8IS0tIFJlc3VsdCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9ImQxMTI3NWUyLTY3YWUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSIyNzExMzAwMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi45NiIgZGlzcGxheU5hbWU9IkJvZHkgd2VpZ2h0Ii8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDA0MDciLz4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9Ijg4IiB1bml0PSJrZyIvPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkJCTxjb21wb25lbnQ+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zMSIvPiA8IS0tIFJlc3VsdCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9ImQxMTI3NWUzLTY3YWUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSIyNzE2NDkwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJTeXN0b2xpYyBCUCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDAwNDA3Ii8+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSIxNDUiIHVuaXQ9Im1tW0hnXSIvPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkJCTxjb21wb25lbnQ+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zMSIvPiA8IS0tIFJlc3VsdCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9ImQxMTI3NWU0LTY3YWUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSIyNzE2NTAwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJEaWFzdG9saWMgQlAiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDAwMDQwNyIvPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlBRIiB2YWx1ZT0iODgiIHVuaXQ9Im1tW0hnXSIvPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkJPC9vcmdhbml6ZXI+DQoJPC9lbnRyeT4NCjwvc2VjdGlvbj4NCjwvY29tcG9uZW50Pg0KCQkJPCEtLSANCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQpSZXN1bHRzIHNlY3Rpb24NCioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQotLT4NCjxjb21wb25lbnQ+DQo8c2VjdGlvbj4NCgk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjE0Ii8+IDwhLS0gUmVzdWx0cyBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjMwOTU0LTIiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPg0KCTx0aXRsZT5SZXN1bHRzPC90aXRsZT4NCgk8dGV4dD4NCgkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJCTx0cj48dGg+JiMxNjA7PC90aD48dGg+TWFyY2ggMjMsIDIwMDA8L3RoPjx0aD5BcHJpbCAwNiwgMjAwMDwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQkJPHRyPjx0ZCBjb2xzcGFuPSIzIj48Y29udGVudCBzdHlsZUNvZGU9IkJvbGRJdGFsaWNzIj5IZW1hdG9sb2d5PC9jb250ZW50PjwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkPkhHQiAoTSAxMy0xOCBnL2RsOyBGIDEyLTE2IGcvZGwpPC90ZD48dGQ+MTMuMjwvdGQ+PHRkPiYjMTYwOzwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkPldCQyAoNC4zLTEwLjggMTArMy91bCk8L3RkPjx0ZD42Ljc8L3RkPjx0ZD4mIzE2MDs8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5QTFQgKDEzNS0xNDUgbWVxL2wpPC90ZD48dGQ+MTIzKjwvdGQ+PHRkPiYjMTYwOzwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkIGNvbHNwYW49IjMiPjxjb250ZW50IHN0eWxlQ29kZT0iQm9sZEl0YWxpY3MiPkNoZW1pc3RyeTwvY29udGVudD48L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5OQSAoMTM1LTE0NW1lcS9sKTwvdGQ+PHRkPiYjMTYwOzwvdGQ+PHRkPjE0MDwvdGQ+PC90cj4NCgkJCQk8dHI+PHRkPksgKDMuNS01LjAgbWVxL2wpPC90ZD48dGQ+JiMxNjA7PC90ZD48dGQ+NC4wPC90ZD48L3RyPg0KCQkJCTx0cj48dGQ+Q0wgKDk4LTEwNiBtZXEvbCk8L3RkPjx0ZD4mIzE2MDs8L3RkPjx0ZD4xMDI8L3RkPjwvdHI+DQoJCQkJPHRyPjx0ZD5IQ08zICgxOC0yMyBtZXEvbCk8L3RkPjx0ZD4mIzE2MDs8L3RkPjx0ZD4zNSo8L3RkPjwvdHI+DQoJCQk8L3Rib2R5Pg0KCQk8L3RhYmxlPg0KCTwvdGV4dD4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8b3JnYW5pemVyIGNsYXNzQ29kZT0iQkFUVEVSWSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMyIi8+IDwhLS0gUmVzdWx0IG9yZ2FuaXplciB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSI3ZDVhMDJiMC02N2E0LTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCTxjb2RlIGNvZGU9IjQzNzg5MDA5IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iQ0JDIFdPIERJRkZFUkVOVElBTCIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDAzMjMxNDMwIi8+DQoJCQk8Y29tcG9uZW50Pg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzEiLz4gPCEtLSBSZXN1bHQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSIxMDdjMmRjMC02N2E1LTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCQkJPGNvZGUgY29kZT0iMzAzMTMtMSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iSEdCIi8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDAzMjMxNDMwIi8+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSIxMy4yIiB1bml0PSJnL2RsIi8+DQoJCQkJCTxpbnRlcnByZXRhdGlvbkNvZGUgY29kZT0iTiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNS44MyIvPg0KCQkJCQk8cmVmZXJlbmNlUmFuZ2U+DQoJCQkJCQk8b2JzZXJ2YXRpb25SYW5nZT4NCgkJCQkJCQk8dGV4dD5NIDEzLTE4IGcvZGw7IEYgMTItMTYgZy9kbDwvdGV4dD4NCgkJCQkJCTwvb2JzZXJ2YXRpb25SYW5nZT4NCgkJCQkJPC9yZWZlcmVuY2VSYW5nZT4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9jb21wb25lbnQ+DQoJCQk8Y29tcG9uZW50Pg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzEiLz4gPCEtLSBSZXN1bHQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSI4YjNmYTM3MC02N2E1LTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCQkJPGNvZGUgY29kZT0iMzM3NjUtOSIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iV0JDIi8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDAzMjMxNDMwIi8+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSI2LjciIHVuaXQ9IjEwKzMvdWwiLz4NCgkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIi8+DQoJCQkJCTxyZWZlcmVuY2VSYW5nZT4NCgkJCQkJCTxvYnNlcnZhdGlvblJhbmdlPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSVZMX1BRIj4NCgkJCQkJCQkJPGxvdyB2YWx1ZT0iNC4zIiB1bml0PSIxMCszL3VsIi8+DQoJCQkJCQkJCTxoaWdoIHZhbHVlPSIxMC44IiB1bml0PSIxMCszL3VsIi8+DQoJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCTwvb2JzZXJ2YXRpb25SYW5nZT4NCgkJCQkJPC9yZWZlcmVuY2VSYW5nZT4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9jb21wb25lbnQ+DQoJCQk8Y29tcG9uZW50Pg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzEiLz4gPCEtLSBSZXN1bHQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSI4MGE2Yzc0MC02N2E1LTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCQkJPGNvZGUgY29kZT0iMjY1MTUtNyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iUExUIi8+DQoJCQkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJCQk8ZWZmZWN0aXZlVGltZSB2YWx1ZT0iMjAwMDAzMjMxNDMwIi8+DQoJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iUFEiIHZhbHVlPSIxMjMiIHVuaXQ9IjEwKzMvdWwiLz4NCgkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJMIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIi8+DQoJCQkJCTxyZWZlcmVuY2VSYW5nZT4NCgkJCQkJCTxvYnNlcnZhdGlvblJhbmdlPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSVZMX1BRIj4NCgkJCQkJCQkJPGxvdyB2YWx1ZT0iMTUwIiB1bml0PSIxMCszL3VsIi8+DQoJCQkJCQkJCTxoaWdoIHZhbHVlPSIzNTAiIHVuaXQ9IjEwKzMvdWwiLz4NCgkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJPC9vYnNlcnZhdGlvblJhbmdlPg0KCQkJCQk8L3JlZmVyZW5jZVJhbmdlPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkJPC9vcmdhbml6ZXI+DQoJPC9lbnRyeT4NCgk8ZW50cnkgdHlwZUNvZGU9IkRSSVYiPg0KCQk8b3JnYW5pemVyIGNsYXNzQ29kZT0iQkFUVEVSWSIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMyIi8+IDwhLS0gUmVzdWx0IG9yZ2FuaXplciB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJhNDAwMjdlMC02N2E1LTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCTxjb2RlIGNvZGU9IjIwMTA5MDA1IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iTFlURVMiLz4NCgkJCTxzdGF0dXNDb2RlIGNvZGU9ImNvbXBsZXRlZCIvPg0KCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDAwNDA2MTMwMCIvPg0KCQkJPGNvbXBvbmVudD4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIi8+IDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYTQwMDI3ZTEtNjdhNS0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IjI5NTEtMiIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iTkEiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDAwMDQwNjEzMDAiLz4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjE0MCIgdW5pdD0ibWVxL2wiLz4NCgkJCQkJPGludGVycHJldGF0aW9uQ29kZSBjb2RlPSJOIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My41LjgzIi8+DQoJCQkJCTxyZWZlcmVuY2VSYW5nZT4NCgkJCQkJCTxvYnNlcnZhdGlvblJhbmdlPg0KCQkJCQkJCTx2YWx1ZSB4c2k6dHlwZT0iSVZMX1BRIj4NCgkJCQkJCQkJPGxvdyB2YWx1ZT0iMTM1IiB1bml0PSJtZXEvbCIvPg0KCQkJCQkJCQk8aGlnaCB2YWx1ZT0iMTQ1IiB1bml0PSJtZXEvbCIvPg0KCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQk8L29ic2VydmF0aW9uUmFuZ2U+DQoJCQkJCTwvcmVmZXJlbmNlUmFuZ2U+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvY29tcG9uZW50Pg0KCQkJPGNvbXBvbmVudD4NCgkJCQk8b2JzZXJ2YXRpb24gY2xhc3NDb2RlPSJPQlMiIG1vb2RDb2RlPSJFVk4iPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjMxIi8+IDwhLS0gUmVzdWx0IG9ic2VydmF0aW9uIHRlbXBsYXRlIC0tPg0KCQkJCQk8aWQgcm9vdD0iYTQwMDI3ZTItNjdhNS0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2Ii8+DQoJCQkJCTxjb2RlIGNvZGU9IjI4MjMtMyIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIiBkaXNwbGF5TmFtZT0iSyIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDAwNDA2MTMwMCIvPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlBRIiB2YWx1ZT0iNC4wIiB1bml0PSJtZXEvbCIvPg0KCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiLz4NCgkJCQkJPHJlZmVyZW5jZVJhbmdlPg0KCQkJCQkJPG9ic2VydmF0aW9uUmFuZ2U+DQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJJVkxfUFEiPg0KCQkJCQkJCQk8bG93IHZhbHVlPSIzLjUiIHVuaXQ9Im1lcS9sIi8+DQoJCQkJCQkJCTxoaWdoIHZhbHVlPSI1LjAiIHVuaXQ9Im1lcS9sIi8+DQoJCQkJCQkJPC92YWx1ZT4NCgkJCQkJCTwvb2JzZXJ2YXRpb25SYW5nZT4NCgkJCQkJPC9yZWZlcmVuY2VSYW5nZT4NCgkJCQk8L29ic2VydmF0aW9uPg0KCQkJPC9jb21wb25lbnQ+DQoJCQk8Y29tcG9uZW50Pg0KCQkJCTxvYnNlcnZhdGlvbiBjbGFzc0NvZGU9Ik9CUyIgbW9vZENvZGU9IkVWTiI+DQoJCQkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMzEiLz4gPCEtLSBSZXN1bHQgb2JzZXJ2YXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJCTxpZCByb290PSJhNDAwMjdlMy02N2E1LTExZGItYmQxMy0wODAwMjAwYzlhNjYiLz4NCgkJCQkJPGNvZGUgY29kZT0iMjA3NS0wIiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiIGRpc3BsYXlOYW1lPSJDTCIvPg0KCQkJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDAwNDA2MTMwMCIvPg0KCQkJCQk8dmFsdWUgeHNpOnR5cGU9IlBRIiB2YWx1ZT0iMTAyIiB1bml0PSJtZXEvbCIvPg0KCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9Ik4iIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiLz4NCgkJCQkJPHJlZmVyZW5jZVJhbmdlPg0KCQkJCQkJPG9ic2VydmF0aW9uUmFuZ2U+DQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJJVkxfUFEiPg0KCQkJCQkJCQk8bG93IHZhbHVlPSI5OCIgdW5pdD0ibWVxL2wiLz4NCgkJCQkJCQkJPGhpZ2ggdmFsdWU9IjEwNiIgdW5pdD0ibWVxL2wiLz4NCgkJCQkJCQk8L3ZhbHVlPg0KCQkJCQkJPC9vYnNlcnZhdGlvblJhbmdlPg0KCQkJCQk8L3JlZmVyZW5jZVJhbmdlPg0KCQkJCTwvb2JzZXJ2YXRpb24+DQoJCQk8L2NvbXBvbmVudD4NCgkJCTxjb21wb25lbnQ+DQoJCQkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iRVZOIj4NCgkJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4zMSIvPiA8IS0tIFJlc3VsdCBvYnNlcnZhdGlvbiB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9ImE0MDAyN2U0LTY3YTUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIvPg0KCQkJCQk8Y29kZSBjb2RlPSIxOTYzLTgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIgZGlzcGxheU5hbWU9IkhDTzMiLz4NCgkJCQkJPHN0YXR1c0NvZGUgY29kZT0iY29tcGxldGVkIi8+DQoJCQkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIyMDAwMDQwNjEzMDAiLz4NCgkJCQkJPHZhbHVlIHhzaTp0eXBlPSJQUSIgdmFsdWU9IjM1IiB1bml0PSJtZXEvbCIvPg0KCQkJCQk8aW50ZXJwcmV0YXRpb25Db2RlIGNvZGU9IkgiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuODMiLz4NCgkJCQkJPHJlZmVyZW5jZVJhbmdlPg0KCQkJCQkJPG9ic2VydmF0aW9uUmFuZ2U+DQoJCQkJCQkJPHZhbHVlIHhzaTp0eXBlPSJJVkxfUFEiPg0KCQkJCQkJCQk8bG93IHZhbHVlPSIxOCIgdW5pdD0ibWVxL2wiLz4NCgkJCQkJCQkJPGhpZ2ggdmFsdWU9IjIzIiB1bml0PSJtZXEvbCIvPg0KCQkJCQkJCTwvdmFsdWU+DQoJCQkJCQk8L29ic2VydmF0aW9uUmFuZ2U+DQoJCQkJCTwvcmVmZXJlbmNlUmFuZ2U+DQoJCQkJPC9vYnNlcnZhdGlvbj4NCgkJCTwvY29tcG9uZW50Pg0KCQk8L29yZ2FuaXplcj4NCgk8L2VudHJ5Pg0KPC9zZWN0aW9uPgkJCQ0KPC9jb21wb25lbnQ+DQoJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNClByb2NlZHVyZXMgc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMTIiLz4gPCEtLSBQcm9jZWR1cmVzIHNlY3Rpb24gdGVtcGxhdGUgLS0+DQoJPGNvZGUgY29kZT0iNDc1MTktNCIgY29kZVN5c3RlbT0iMi4xNi44NDAuMS4xMTM4ODMuNi4xIi8+DQoJPHRpdGxlPlByb2NlZHVyZXM8L3RpdGxlPg0KCTx0ZXh0Pg0KCQkJPHRhYmxlIGJvcmRlcj0iMSIgd2lkdGg9IjEwMCUiPg0KCQkJPHRoZWFkPg0KCQkJCTx0cj48dGg+UHJvY2VkdXJlPC90aD48dGg+RGF0ZTwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQkJPHRyPjx0ZD48Y29udGVudCBJRD0iUHJvYzEiPlRvdGFsIGhpcCByZXBsYWNlbWVudCwgbGVmdDwvY29udGVudD48L3RkPjx0ZD4xOTk4PC90ZD48L3RyPg0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPHByb2NlZHVyZSBjbGFzc0NvZGU9IlBST0MiIG1vb2RDb2RlPSJFVk4iPg0KCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4yOSIvPiA8IS0tIFByb2NlZHVyZSBhY3Rpdml0eSB0ZW1wbGF0ZSAtLT4NCgkJCTxpZCByb290PSJlNDAxZjM0MC03YmUyLTExZGItOWZlMS0wODAwMjAwYzlhNjYiLz4NCgkJCTxjb2RlIGNvZGU9IjUyNzM0MDA3IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42Ljk2IiBkaXNwbGF5TmFtZT0iVG90YWwgaGlwIHJlcGxhY2VtZW50Ij4NCgkJCQk8b3JpZ2luYWxUZXh0PjxyZWZlcmVuY2UgdmFsdWU9IiNQcm9jMSIvPjwvb3JpZ2luYWxUZXh0Pg0KCQkJCTxxdWFsaWZpZXI+DQoJCQkJCTxuYW1lIGNvZGU9IjI3Mjc0MTAwMyIgZGlzcGxheU5hbWU9IkxhdGVyYWxpdHkiLz4NCgkJCQkJPHZhbHVlIGNvZGU9Ijc3NzEwMDAiIGRpc3BsYXlOYW1lPSJMZWZ0Ii8+DQoJCQkJPC9xdWFsaWZpZXI+DQoJCQk8L2NvZGU+DQoJCQk8c3RhdHVzQ29kZSBjb2RlPSJjb21wbGV0ZWQiLz4NCgkJCTxlZmZlY3RpdmVUaW1lIHZhbHVlPSIxOTk4Ii8+DQoJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkRFViI+DQoJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9Ik1BTlUiPg0KCQkJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjUyIi8+IDwhLS0gUHJvZHVjdCBpbnN0YW5jZSB0ZW1wbGF0ZSAtLT4NCgkJCQkJPGlkIHJvb3Q9IjAzY2EwMWIwLTdiZTEtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIvPg0KCQkJCTwvcGFydGljaXBhbnRSb2xlPg0KCQkJPC9wYXJ0aWNpcGFudD4NCgkJPC9wcm9jZWR1cmU+DQoJPC9lbnRyeT4NCjwvc2VjdGlvbj4NCjwvY29tcG9uZW50Pg0KDQoJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCkVuY291bnRlcnMgc2VjdGlvbg0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0tPg0KPGNvbXBvbmVudD4NCjxzZWN0aW9uPg0KCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMyIvPiA8IS0tIEVuY291bnRlcnMgc2VjdGlvbiB0ZW1wbGF0ZSAtLT4NCgk8Y29kZSBjb2RlPSI0NjI0MC04IiBjb2RlU3lzdGVtPSIyLjE2Ljg0MC4xLjExMzg4My42LjEiLz4NCgk8dGl0bGU+RW5jb3VudGVyczwvdGl0bGU+DQoJPHRleHQ+DQoJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCTx0aGVhZD4NCgkJCQk8dHI+PHRoPkVuY291bnRlcjwvdGg+PHRoPkxvY2F0aW9uPC90aD48dGg+RGF0ZTwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQkJPHRyPjx0ZD5DaGVja3VwIEV4YW1pbmF0aW9uPC90ZD48dGQ+R29vZCBIZWFsdGggQ2xpbmljPC90ZD48dGQ+QXByIDA3LCAyMDAwPC90ZD48L3RyPg0KCQkJPC90Ym9keT4NCgkJPC90YWJsZT4NCgk8L3RleHQ+DQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPGVuY291bnRlciBjbGFzc0NvZGU9IkVOQyIgbW9vZENvZGU9IkVWTiI+DQoJCQk8dGVtcGxhdGVJZCByb290PSIyLjE2Ljg0MC4xLjExMzg4My4xMC4yMC4xLjIxIi8+IDwhLS0gRW5jb3VudGVyIGFjdGl2aXR5IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9IjJhNjIwMTU1LTlkMTEtNDM5ZS05MmIzLTVkOTgxNWZmNGRlOCIvPg0KCQkJPGNvZGUgY29kZT0iR0VOUkwiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjUuNCIgZGlzcGxheU5hbWU9IkdlbmVyYWwiPg0KCQkJCTxvcmlnaW5hbFRleHQ+Q2hlY2t1cCBFeGFtaW5hdGlvbjwvb3JpZ2luYWxUZXh0Pg0KCQkJPC9jb2RlPg0KCQkJPGVmZmVjdGl2ZVRpbWUgdmFsdWU9IjIwMDAwNDA3Ii8+DQoJCQk8cGFydGljaXBhbnQgdHlwZUNvZGU9IkxPQyI+DQoJCQkJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS40NSIvPiA8IS0tIExvY2F0aW9uIHBhcnRpY2lwYXRpb24gdGVtcGxhdGUgLS0+DQoJCQkJPHBhcnRpY2lwYW50Um9sZSBjbGFzc0NvZGU9IlNETE9DIj4NCgkJCQkJPGlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjE5LjUiLz4NCgkJCQkJPHBsYXlpbmdFbnRpdHkgY2xhc3NDb2RlPSJQTEMiPg0KCQkJCQkJPG5hbWU+R29vZCBIZWFsdGggQ2xpbmljPC9uYW1lPg0KCQkJCQk8L3BsYXlpbmdFbnRpdHk+DQoJCQkJPC9wYXJ0aWNpcGFudFJvbGU+DQoJCQk8L3BhcnRpY2lwYW50Pg0KCQk8L2VuY291bnRlcj4NCgk8L2VudHJ5Pg0KPC9zZWN0aW9uPg0KPC9jb21wb25lbnQ+DQoJCQk8IS0tIA0KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNClBsYW4gb2YgQ2FyZSBzZWN0aW9uDQoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLS0+DQo8Y29tcG9uZW50Pg0KPHNlY3Rpb24+DQoJPHRlbXBsYXRlSWQgcm9vdD0iMi4xNi44NDAuMS4xMTM4ODMuMTAuMjAuMS4xMCIvPiA8IS0tIFBsYW4gb2YgQ2FyZSBzZWN0aW9uIHRlbXBsYXRlIC0tPg0KCTxjb2RlIGNvZGU9IjE4Nzc2LTUiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuMSIvPg0KCTx0aXRsZT5QbGFuPC90aXRsZT4NCgkJPHRleHQ+DQoJCTx0YWJsZSBib3JkZXI9IjEiIHdpZHRoPSIxMDAlIj4NCgkJCTx0aGVhZD4NCgkJCTx0cj48dGg+UGxhbm5lZCBBY3Rpdml0eTwvdGg+PHRoPlBsYW5uZWQgRGF0ZTwvdGg+PC90cj4NCgkJCTwvdGhlYWQ+DQoJCQk8dGJvZHk+DQoJCQk8dHI+PHRkPlB1bG1vbmFyeSBmdW5jdGlvbiB0ZXN0PC90ZD48dGQ+QXByaWwgMjEsIDIwMDA8L3RkPjwvdHI+DQoJCQk8L3Rib2R5Pg0KCQk8L3RhYmxlPg0KCTwvdGV4dD4JDQoJPGVudHJ5IHR5cGVDb2RlPSJEUklWIj4NCgkJPG9ic2VydmF0aW9uIGNsYXNzQ29kZT0iT0JTIiBtb29kQ29kZT0iUlFPIj4NCgkJCTx0ZW1wbGF0ZUlkIHJvb3Q9IjIuMTYuODQwLjEuMTEzODgzLjEwLjIwLjEuMjUiLz4gPCEtLSBQbGFuIG9mIEFjdGl2aXR5IGFjdGl2aXR5IHRlbXBsYXRlIC0tPg0KCQkJPGlkIHJvb3Q9IjlhNmQxYmFjLTE3ZDMtNDE5NS04OWE0LTExMjFiYzgwOWI0YSIvPg0KCQkJPGNvZGUgY29kZT0iMjM0MjYwMDYiIGNvZGVTeXN0ZW09IjIuMTYuODQwLjEuMTEzODgzLjYuOTYiIGRpc3BsYXlOYW1lPSJQdWxtb25hcnkgZnVuY3Rpb24gdGVzdCIvPg0KCQkJPHN0YXR1c0NvZGUgY29kZT0ibmV3Ii8+DQoJCQk8ZWZmZWN0aXZlVGltZT48Y2VudGVyIHZhbHVlPSIyMDAwMDQyMSIvPjwvZWZmZWN0aXZlVGltZT4NCgkJPC9vYnNlcnZhdGlvbj4NCgk8L2VudHJ5Pg0KPC9zZWN0aW9uPg0KPC9jb21wb25lbnQ+DQo8L3N0cnVjdHVyZWRCb2R5Pg0KPC9jb21wb25lbnQ+DQo8L0NsaW5pY2FsRG9jdW1lbnQ+DQo=","base64").toString();
        var result = bb.parseString(data);
        result.meta.sections.sort();

        // check validation
        var val = bb.validator.validateDocumentModel(result);

        // generate ccda
        var xml = bbg.generateCCD(result);

        // parse generated ccda
        var result2 = bb.parseString(xml);
        result2.meta.sections.sort();

        // re-generate
        var xml2 = bbg.generateCCD(result2);

        delete result.errors;
        delete result2.errors;
        delete result.data.providers;
        result.meta.sections = result.meta.sections.filter(function (v) {
            return v !== 'providers';
        });

        assert.deepEqual(result2, result);
    });

    it('cms_sample.xml should not crash', function () {
        var data = Buffer("LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KTVlNRURJQ0FSRS5HT1YgUEVSU09OQUwgSEVBTFRIIElORk9STUFUSU9OCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoqKioqKioqKioqQ09ORklERU5USUFMKioqKioqKioqKioKClByb2R1Y2VkIGJ5IHRoZSBCbHVlIEJ1dHRvbiAodjIuMCkKCjAzLzE2LzIwMTMgNToxMCBBTQoKCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KRGVtb2dyYXBoaWMKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IE15TWVkaWNhcmUuZ292CgoKCk5hbWU6IEpPSE4gRE9FCgpEYXRlIG9mIEJpcnRoOiAwMS8wMS8xOTEwCgpBZGRyZXNzIExpbmUgMTogMTIzIEFOWSBST0FECgpBZGRyZXNzIExpbmUgMjogCgpDaXR5OiBBTllUT1dOCgpTdGF0ZTogVkEKClppcDogMDAwMDEKClBob25lIE51bWJlcjogMTIzLTQ1Ni03ODkwCgpFbWFpbDogSk9ITkRPRUBleGFtcGxlLmNvbQoKUGFydCBBIEVmZmVjdGl2ZSBEYXRlOiAwMS8wMS8yMDEyCgpQYXJ0IEIgRWZmZWN0aXZlIERhdGU6IDAxLzAxLzIwMTIKCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KRW1lcmdlbmN5IENvbnRhY3QKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IFNlbGYtRW50ZXJlZAoKCgpDb250YWN0IE5hbWU6IEpBTkUgRE9FCgpBZGRyZXNzIFR5cGU6SG9tZQoKQWRkcmVzcyBMaW5lIDE6IDEyMyBBbnlXaGVyZSBTdAoKQWRkcmVzcyBMaW5lIDI6IAoKQ2l0eTogQW55V2hlcmUKClN0YXRlOiBEQwoKWmlwOiAwMDAwMi0xMTExCgpSZWxhdGlvbnNoaXA6IE90aGVyCgpIb21lIFBob25lOiAxMjMtNDU2LTc4OTAKCldvcmsgUGhvbmU6IDAwMC0wMDEtMDAwMQoKTW9iaWxlIFBob25lOiAwMDAtMDAxLTAwMDIKCkVtYWlsIEFkZHJlc3M6IEpBTkVET0VAZXhhbXBsZS5jb20KCgoKQ29udGFjdCBOYW1lOiBTVEVWRSBET0UKCkFkZHJlc3MgVHlwZToKCkFkZHJlc3MgTGluZSAxOiAxMjMgQW55V2hlcmUgUmQKCkFkZHJlc3MgTGluZSAyOiAKCkNpdHk6IEFueVdoZXJlCgpTdGF0ZTogVkEKClppcDogMDAwMDEKClJlbGF0aW9uc2hpcDogT3RoZXIKCkhvbWUgUGhvbmU6IDEyMy00NTYtNzg5MAoKV29yayBQaG9uZTogMDAwLTAwMS0wMDAxCgpNb2JpbGUgUGhvbmU6IDAwMC0wMDEtMDAwMgoKRW1haWwgQWRkcmVzczogU1RFVkVET0VAZXhhbXBsZS5jb20KCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KU2VsZiBSZXBvcnRlZCBNZWRpY2FsIENvbmRpdGlvbnMKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IFNlbGYtRW50ZXJlZAoKCgpDb25kaXRpb24gTmFtZTogQXJ0aHJpdGlzCgpNZWRpY2FsIENvbmRpdGlvbiBTdGFydCBEYXRlOiAwOC8wOS8yMDA1CgpNZWRpY2FsIENvbmRpdGlvbiBFbmQgRGF0ZTogMDIvMjgvMjAxMQoKCgpDb25kaXRpb24gTmFtZTogQXN0aG1hCgpNZWRpY2FsIENvbmRpdGlvbiBTdGFydCBEYXRlOiAwMS8yNS8yMDA4CgpNZWRpY2FsIENvbmRpdGlvbiBFbmQgRGF0ZTogMDEvMjUvMjAxMAoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpTZWxmIFJlcG9ydGVkIEFsbGVyZ2llcwoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KClNvdXJjZTogU2VsZi1FbnRlcmVkCgoKCkFsbGVyZ3kgTmFtZTogQW50aWJvdGljCgpUeXBlOiBEcnVncwoKUmVhY3Rpb246IFZvbWl0aW5nCgpTZXZlcml0eTogU2V2ZXJlCgpEaWFnbm9zZWQ6IFllcwoKVHJlYXRtZW50OiBBbGxlcmd5IFNob3RzCgpGaXJzdCBFcGlzb2RlIERhdGU6IDAxLzA4LzE5MjYKCkxhc3QgRXBpc29kZSBEYXRlOiAwMy8xMy8xOTU1CgpMYXN0IFRyZWF0bWVudCBEYXRlOiAwOS8yOC8xOTQ5CgpDb21tZW50czogRXJ5dGhyb215Y2luIAoKCgpBbGxlcmd5IE5hbWU6IEdyYXNzZXMKClR5cGU6IEVudmlyb25tZW50YWwKClJlYWN0aW9uOiBTbmVlemluZwoKU2V2ZXJpdHk6IFNldmVyZQoKRGlhZ25vc2VkOiBZZXMKClRyZWF0bWVudDogQXZvaWRhbmNlCgpGaXJzdCBFcGlzb2RlIERhdGU6IDA1LzEzLzE5NzMKCkxhc3QgRXBpc29kZSBEYXRlOiAwNy8yMC8xOTk2CgpMYXN0IFRyZWF0bWVudCBEYXRlOiAwOS8yNy8yMDA4CgpDb21tZW50czogCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tClNlbGYgUmVwb3J0ZWQgSW1wbGFudGFibGUgRGV2aWNlCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKU291cmNlOiBTZWxmLUVudGVyZWQKCgoKRGV2aWNlIE5hbWU6IEFydGlmaWNpYWwgRXllIExlbnNlcwoKRGF0ZSBJbXBsYW50ZWQ6IDEvMjcvMTk0MgoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpTZWxmIFJlcG9ydGVkIEltbXVuaXphdGlvbnMKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IFNlbGYtRW50ZXJlZAoKCgpJbW11bml6YXRpb24gTmFtZTogVmFyaWNlbGxhL0NoaWNrZW4gUG94CgpEYXRlIEFkbWluaXN0ZXJlZDowNC8yMS8yMDAyCgpNZXRob2Q6IE5hc2FsIFNwcmF5KG1pc3QpCgpXZXJlIHlvdSB2YWNjaW5hdGVkIGluIHRoZSBVUzogCgpDb21tZW50czogY29uZ2VzdGlvbgoKQm9vc3RlciAxIERhdGU6IDAyLzAyLzE5OTAKCkJvb3N0ZXIgMiBEYXRlOiAKCkJvb3N0ZXIgMyBEYXRlOiAKCgoKSW1tdW5pemF0aW9uIE5hbWU6IHR5cGhvaWQKCkRhdGUgQWRtaW5pc3RlcmVkOjAxLzAyLzIwMDkKCk1ldGhvZDogSW5qZWN0aW9uCgpXZXJlIHlvdSB2YWNjaW5hdGVkIGluIHRoZSBVUzogCgpDb21tZW50czogCgpCb29zdGVyIDEgRGF0ZTogCgpCb29zdGVyIDIgRGF0ZTogCgpCb29zdGVyIDMgRGF0ZTogCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tClNlbGYgUmVwb3J0ZWQgTGFicyBhbmQgVGVzdHMKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IFNlbGYtRW50ZXJlZAoKCgpUZXN0L0xhYiBUeXBlOiBHbHVjb3NlIExldmVsCkRhdGUgVGFrZW46IDAzLzIxLzIwMDgKCkFkbWluaXN0ZXJlZCBieTogQW55TGFiCgpSZXF1ZXN0aW5nIERvY3RvcjogRHIuIFNtaXRoCgpSZWFzb24gVGVzdC9MYWIgUmVxdWVzdGVkOiBPbmdvaW5nIGVsZXZhdGVkIGdsdWNvc2UKClJlc3VsdHM6IDEzNSwgMTcwLCAxNTAsIDEyMAoKQ29tbWVudHM6IEZhc3RpbmcsIGhvdXIgMSwgaG91ciAyLCBob3VyIDMKCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KU2VsZiBSZXBvcnRlZCBWaXRhbCBTdGF0aXN0aWNzCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKU291cmNlOiBTZWxmLUVudGVyZWQKCgoKVml0YWwgU3RhdGlzdGljIFR5cGU6IEJsb29kIFByZXNzdXJlCgpEYXRlOiAwNy8yMi8yMDExCgpUaW1lOiAzOjAwIFBNCgpSZWFkaW5nOiAxMjAvODAKCkNvbW1lbnRzOiAKCgoKVml0YWwgU3RhdGlzdGljIFR5cGU6IEdsdWNvc2UKCkRhdGU6IDAzLzIwLzIwMTIKClRpbWU6IDEyOjAwIFBNCgpSZWFkaW5nOiAxMTAKCkNvbW1lbnRzOiAKCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KRmFtaWx5IE1lZGljYWwgSGlzdG9yeQoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KClNvdXJjZTogU2VsZi1FbnRlcmVkCgoKCkZhbWlseSBNZW1iZXI6IEJyb3RoZXIKClR5cGU6IAoKRE9COjEvMTAvMTkxNQoKRE9EOiAKCkFnZTogCgpUeXBlOiBBbGxlcmd5CgpEZXNjcmlwdGlvbjogQW50aWFycnl0aG1pYQoKRGVzY3JpcHRpb246IEFudGliaW90aWMKCkRlc2NyaXB0aW9uOiBBbnRpY29udnVsc2FudHMKClR5cGU6IENvbmRpdGlvbgoKRGVzY3JpcHRpb246IEFsbGVyZ2llcwoKRGVzY3JpcHRpb246IEFsemhlaW1lcidzIERpc2Vhc2UKCkRlc2NyaXB0aW9uOiBBbmdpbmEgKEhlYXJ0IFBhaW4pCgpEZXNjcmlwdGlvbjogQ2F0YXJhY3RzCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KRHJ1Z3MKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IFNlbGYtRW50ZXJlZAoKCgpEcnVnIE5hbWU6IEFzcGlyaW4KClN1cHBseTogRGlhbHkKCk9yaWcgRHJ1ZyBFbnRyeTogQXNwaXJpbgoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpQcmV2ZW50aXZlIFNlcnZpY2VzCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKU291cmNlOiBNeU1lZGljYXJlLmdvdgoKCgpEZXNjcmlwdGlvbjogRElBQkVURVMKCk5leHQgRWxpZ2libGUgRGF0ZTogMTAvMS8yMDExCgpMYXN0IERhdGUgb2YgU2VydmljZTogCgoKCkRlc2NyaXB0aW9uOiBQQVAgVEVTVCBEUgoKTmV4dCBFbGlnaWJsZSBEYXRlOiAxMC8xLzIwMTEKCkxhc3QgRGF0ZSBvZiBTZXJ2aWNlOiAKCgoKRGVzY3JpcHRpb246IEFCRE9NSU5BTCBBT1JUSUMgQU5FVVJZU00KCk5leHQgRWxpZ2libGUgRGF0ZTogNy8xLzIwMTIKCkxhc3QgRGF0ZSBvZiBTZXJ2aWNlOiAKCgoKRGVzY3JpcHRpb246IEFOTlVBTCBXRUxMTkVTUyBWSVNJVAoKTmV4dCBFbGlnaWJsZSBEYXRlOiAxLzEvMjAxMwoKTGFzdCBEYXRlIG9mIFNlcnZpY2U6IAoKCgpEZXNjcmlwdGlvbjogREVQUkVTU0lPTiBTQ1JFRU5JTkcKCk5leHQgRWxpZ2libGUgRGF0ZTogMTAvMTQvMjAxMgoKTGFzdCBEYXRlIG9mIFNlcnZpY2U6IAoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpQcm92aWRlcnMKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IFNlbGYtRW50ZXJlZAoKCgpQcm92aWRlciBOYW1lOiBBTlkgQ0FSRQoKUHJvdmlkZXIgQWRkcmVzczogMTIzIEFueSBSZCwgQW55d2hlcmUsIE1EIDk5OTk5CgpUeXBlOiBOSEMKClNwZWNpYWx0eTogCgpNZWRpY2FyZSBQcm92aWRlcjogTm90IEF2YWlsYWJsZQoKCgpQcm92aWRlciBOYW1lOiBBTlkgSE9TUElUQUwxCgpQcm92aWRlciBBZGRyZXNzOiAxMjMgRHJpdmUsIEFueXdoZXJlLCBWQSAwMDAwMQoKVHlwZTogSE9TCgpTcGVjaWFsdHk6IAoKTWVkaWNhcmUgUHJvdmlkZXI6IE5vdCBBdmFpbGFibGUKClByb3ZpZGVyIE5hbWU6IEphbmUgRG9lCgpQcm92aWRlciBBZGRyZXNzOiAxMjMgUm9hZCwgQW55d2hlcmUsIFZBIDAwMDAxCgpUeXBlOiBQSFkKClNwZWNpYWx0eTogT3RoZXIKCk1lZGljYXJlIFByb3ZpZGVyOiBOb3QgQXZhaWxhYmxlCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tClBoYXJtYWNpZXMKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IFNlbGYtRW50ZXJlZAoKCgpQaGFybWFjeSBOYW1lOiBQSEFSTUFDWSwgRUFTVCBTVFJFRVQgQU5ZV0hFUkUsIERDIDAwMDAyCgpQaGFybWFjeSBQaG9uZTogMDAwLTAwMC0wMDAxCgoKClBoYXJtYWN5IE5hbWU6IEFOWSBQSEFSTUFDWSwgV0VTVCBTVFJFRVQgQU5ZV0hFUkUsIFZBIDAwMDAxCgpQaGFybWFjeSBQaG9uZTogMDAwLTAwMC0wMDAyCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tClBsYW5zCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKU291cmNlOiBNeU1lZGljYXJlLmdvdgoKCgpDb250cmFjdCBJRC9QbGFuIElEOiBIOTk5OS85OTk5CgpQbGFuIFBlcmlvZDogMDkvMDEvMjAxMSAtIGN1cnJlbnQKClBsYW4gTmFtZTogQSBNZWRpY2FyZSBQbGFuIFBsdXMgKEhNTykKCk1hcmtldGluZyBOYW1lOiBIZWFsdGhDYXJlIFBheWVyCgpQbGFuIEFkZHJlc3M6IDEyMyBBbnkgUm9hZCBBbnl0b3duIFBBIDAwMDAzCgpQbGFuIFR5cGU6IDMgLSBDb29yZGluYXRlZCBDYXJlIFBsYW4gKEhNTywgUFBPLCBQU08sIFNOUCkKCgoKQ29udHJhY3QgSUQvUGxhbiBJRDogUzk5OTkvMDAwCgpQbGFuIFBlcmlvZDogMDEvMDEvMjAxMCAtIGN1cnJlbnQKClBsYW4gTmFtZTogQSBNZWRpY2FyZSBSeCBQbGFuIChQRFApCgpNYXJrZXRpbmcgTmFtZTogQW5vdGhlciBIZWFsdGhDYXJlIFBheWVyCgpQbGFuIEFkZHJlc3M6IDEyMyBBbnkgUm9hZCBBbnl0b3duIFBBIDAwMDAzCgpQbGFuIFR5cGU6IDExIC0gTWVkaWNhcmUgUHJlc2NyaXB0aW9uIERydWcgUGxhbgoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpFbXBsb3llciBTdWJzaWR5CgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKU291cmNlOiBNeU1lZGljYXJlLmdvdgoKCkVtcGxveWVyIFBsYW46IFNUQVRFIEhFQUxUSCBCRU5FRklUUyBQUk9HUkFNCgpFbXBsb3llciBTdWJzaWR5IFN0YXJ0IERhdGU6IDAxLzAxLzIwMTEKCkVtcGxveWVyIFN1YnNpZHkgRW5kIERhdGU6IDEyLzMxLzIwMTEKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpQcmltYXJ5IEluc3VyYW5jZQoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KClNvdXJjZTogTXlNZWRpY2FyZS5nb3YKCgoKTVNQIFR5cGU6IEVuZCBzdGFnZSBSZW5hbCBEaXNlYXNlIChFU1JEKQoKUG9saWN5IE51bWJlcjogMTIzNDU2Nzg5MAoKSW5zdXJlciBOYW1lOiBJbnN1cmVyMQoKSW5zdXJlciBBZGRyZXNzOiBQTyBCT1ggMDAwMCBBbnl0b3duLCBDTyAwMDAwMi0wMDAwCgpFZmZlY3RpdmUgRGF0ZTogMDEvMDEvMjAxMQoKVGVybWluYXRpb24gRGF0ZTogMDkvMzAvMjAxMQoKCgpNU1AgVHlwZTogRW5kIHN0YWdlIFJlbmFsIERpc2Vhc2UgKEVTUkQpCgpQb2xpY3kgTnVtYmVyOiAxMjM0NTY3ODkwMQoKSW5zdXJlciBOYW1lOiBJbnN1cmVyMgoKSW5zdXJlciBBZGRyZXNzOiAwMDAwIEFueSBST0FEIEFOWVdIRVJFLCBWQSAwMDAwMC0wMDAwCgpFZmZlY3RpdmUgRGF0ZTogMDEvMDEvMjAxMAoKVGVybWluYXRpb24gRGF0ZTogMTIvMzEvMjAxMAoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpPdGhlciBJbnN1cmFuY2UKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpTb3VyY2U6IE15TWVkaWNhcmUuZ292CgoKCk1TUCBUeXBlOiAKClBvbGljeSBOdW1iZXI6IDAwMDAxCgpJbnN1cmVyIE5hbWU6IEluc3VyZXIKCkluc3VyZXIgQWRkcmVzczogMDAgQWRkcmVzcyBTVFJFRVQgQU5ZV0hFUkUsIFBBIDAwMDAwCgpFZmZlY3RpdmUgRGF0ZTogMTAvMDEvMTk4NAoKVGVybWluYXRpb24gRGF0ZTogMTEvMzAvMjAwOAoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpDbGFpbSBTdW1tYXJ5CgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKU291cmNlOiBNeU1lZGljYXJlLmdvdgoKCgpDbGFpbSBOdW1iZXI6IDEyMzQ1Njc4OTAwMDAKClByb3ZpZGVyOiBObyBJbmZvcm1hdGlvbiBBdmFpbGFibGUgClByb3ZpZGVyIEJpbGxpbmcgQWRkcmVzczogICAgCgpTZXJ2aWNlIFN0YXJ0IERhdGU6IDEwLzE4LzIwMTIKClNlcnZpY2UgRW5kIERhdGU6IAoKQW1vdW50IENoYXJnZWQ6ICQ2MC4wMAoKTWVkaWNhcmUgQXBwcm92ZWQ6ICQzNC4wMAoKUHJvdmlkZXIgUGFpZDogJDI3LjIwCgpZb3UgTWF5IGJlIEJpbGxlZDogJDYuODAKCkNsYWltIFR5cGU6IFBhcnRCCgpEaWFnbm9zaXMgQ29kZSAxOiAzNTM0CkRpYWdub3NpcyBDb2RlIDI6IDczOTMKRGlhZ25vc2lzIENvZGUgMzogNzM5MgpEaWFnbm9zaXMgQ29kZSA0OiAzNTMzIAoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KQ2xhaW0gTGluZXMgZm9yIENsYWltIE51bWJlcjogMTIzNDU2Nzg5MDAwMAoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgoKTGluZSBudW1iZXI6ICAxCgpEYXRlIG9mIFNlcnZpY2UgRnJvbTogIDEwLzE4LzIwMTIKCkRhdGUgb2YgU2VydmljZSBUbzogIDEwLzE4LzIwMTIKClByb2NlZHVyZSBDb2RlL0Rlc2NyaXB0aW9uOiAgOTg5NDEgLSBDaGlyb3ByYWN0aWMgTWFuaXB1bGF0aXZlIFRyZWF0bWVudCAoQ210KTsgU3BpbmFsLCBUaHJlZSBUbyBGb3VyIFJlZ2lvbnMKCk1vZGlmaWVyIDEvRGVzY3JpcHRpb246ICBBVCAtIEFjdXRlIFRyZWF0bWVudCAoVGhpcyBNb2RpZmllciBTaG91bGQgQmUgVXNlZCBXaGVuIFJlcG9ydGluZyBTZXJ2aWNlIDk4OTQwLCA5ODk0MSwgOTg5NDIpCgpNb2RpZmllciAyL0Rlc2NyaXB0aW9uOiAgCgpNb2RpZmllciAzL0Rlc2NyaXB0aW9uOiAgCgpNb2RpZmllciA0L0Rlc2NyaXB0aW9uOiAgCgpRdWFudGl0eSBCaWxsZWQvVW5pdHM6ICAxCgpTdWJtaXR0ZWQgQW1vdW50L0NoYXJnZXM6ICAkNjAuMDAKCkFsbG93ZWQgQW1vdW50OiAgJDM0LjAwCgpOb24tQ292ZXJlZDogICQyNi4wMAoKUGxhY2Ugb2YgU2VydmljZS9EZXNjcmlwdGlvbjogIDExIC0gT2ZmaWNlCgpUeXBlIG9mIFNlcnZpY2UvRGVzY3JpcHRpb246ICAxIC0gTWVkaWNhbCBDYXJlCgpSZW5kZXJpbmcgUHJvdmlkZXIgTm86ICAwMDAwMDAxCgpSZW5kZXJpbmcgUHJvdmlkZXIgTlBJOiAgMTIzNDU2Nzg5CgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgoKCkNsYWltIE51bWJlcjogMTIzNDU2Nzg5MDAwMDBWQUEKClByb3ZpZGVyOiBObyBJbmZvcm1hdGlvbiBBdmFpbGFibGUKIApQcm92aWRlciBCaWxsaW5nIEFkZHJlc3M6ICAgIAoKU2VydmljZSBTdGFydCBEYXRlOiAwOS8yMi8yMDEyCgpTZXJ2aWNlIEVuZCBEYXRlOiAKCkFtb3VudCBDaGFyZ2VkOiAkNTA0LjgwCgpNZWRpY2FyZSBBcHByb3ZlZDogJDUwNC44MAoKUHJvdmlkZXIgUGFpZDogJDEyNi4zMQoKWW91IE1heSBiZSBCaWxsZWQ6ICQzOC44NAoKQ2xhaW0gVHlwZTogT3V0cGF0aWVudAoKRGlhZ25vc2lzIENvZGUgMTogNTY0MDAKRGlhZ25vc2lzIENvZGUgMjogNzI0NQpEaWFnbm9zaXMgQ29kZSAzOiBWMTU4OAoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KQ2xhaW0gTGluZXMgZm9yIENsYWltIE51bWJlcjogMTIzNDU2Nzg5MDAwMDBWQUEKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgoKCkxpbmUgbnVtYmVyOiAgMQoKRGF0ZSBvZiBTZXJ2aWNlIEZyb206ICAwOS8yMi8yMDEyCgpSZXZlbnVlIENvZGUvRGVzY3JpcHRpb246IDAyNTAgLSBHZW5lcmFsIENsYXNzaWZpY2F0aW9uIFBIQVJNQUNZCgpQcm9jZWR1cmUgQ29kZS9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMS9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMi9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMy9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgNC9EZXNjcmlwdGlvbjogIAoKUXVhbnRpdHkgQmlsbGVkL1VuaXRzOiAgMQoKU3VibWl0dGVkIEFtb3VudC9DaGFyZ2VzOiAgJDE0LjMwCgpBbGxvd2VkIEFtb3VudDogICQxNC4zMAoKTm9uLUNvdmVyZWQ6ICAkMC4wMAoKCgpMaW5lIG51bWJlcjogIDIKCkRhdGUgb2YgU2VydmljZSBGcm9tOiAgMDkvMjIvMjAxMgoKUmV2ZW51ZSBDb2RlL0Rlc2NyaXB0aW9uOiAwMzIwIC0gR2VuZXJhbCBDbGFzc2lmaWNhdGlvbiBEWCBYLVJBWQoKUHJvY2VkdXJlIENvZGUvRGVzY3JpcHRpb246ICA3NDAyMCAtIFJhZGlvbG9naWMgRXhhbWluYXRpb24sIEFiZG9tZW47IENvbXBsZXRlLCBJbmNsdWRpbmcgRGVjdWJpdHVzIEFuZC9PciBFcmVjdCBWaWV3cwoKTW9kaWZpZXIgMS9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMi9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMy9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgNC9EZXNjcmlwdGlvbjogIAoKUXVhbnRpdHkgQmlsbGVkL1VuaXRzOiAgMQoKU3VibWl0dGVkIEFtb3VudC9DaGFyZ2VzOiAgJDE3NS41MAoKQWxsb3dlZCBBbW91bnQ6ICAkMTc1LjUwCgpOb24tQ292ZXJlZDogICQwLjAwCgoKCkxpbmUgbnVtYmVyOiAgMwoKRGF0ZSBvZiBTZXJ2aWNlIEZyb206ICAwOS8yMi8yMDEyCgpSZXZlbnVlIENvZGUvRGVzY3JpcHRpb246IDA0NTAgLSBHZW5lcmFsIENsYXNzaWZpY2F0aW9uIEVNRVJHIFJPT00KClByb2NlZHVyZSBDb2RlL0Rlc2NyaXB0aW9uOiAgOTkyODMgLSBFbWVyZ2VuY3kgRGVwYXJ0bWVudCBWaXNpdCBGb3IgVGhlIEV2YWx1YXRpb24gQW5kIE1hbmFnZW1lbnQgT2YgQSBQYXRpZW50LCBXaGljaCBSZXF1aXJlcyBUaAoKTW9kaWZpZXIgMS9EZXNjcmlwdGlvbjogIDI1IC0gU2lnbmlmaWNhbnQsIFNlcGFyYXRlbHkgSWRlbnRpZmlhYmxlIEV2YWx1YXRpb24gQW5kIE1hbmFnZW1lbnQgU2VydmljZSBCeSBUaGUgU2FtZSBQaHlzaWNpYW4gT24KCk1vZGlmaWVyIDIvRGVzY3JpcHRpb246ICAKCk1vZGlmaWVyIDMvRGVzY3JpcHRpb246ICAKCk1vZGlmaWVyIDQvRGVzY3JpcHRpb246ICAKClF1YW50aXR5IEJpbGxlZC9Vbml0czogIDEKClN1Ym1pdHRlZCBBbW91bnQvQ2hhcmdlczogICQzMTUuMDAKCkFsbG93ZWQgQW1vdW50OiAgJDMxNS4wMAoKTm9uLUNvdmVyZWQ6ICAkMC4wMAoKCgpMaW5lIG51bWJlcjogIDQKCkRhdGUgb2YgU2VydmljZSBGcm9tOiAgCgpSZXZlbnVlIENvZGUvRGVzY3JpcHRpb246IDAwMDEgLSBUb3RhbCBDaGFyZ2VzCgpQcm9jZWR1cmUgQ29kZS9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMS9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMi9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMy9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgNC9EZXNjcmlwdGlvbjogIAoKUXVhbnRpdHkgQmlsbGVkL1VuaXRzOiAgMAoKU3VibWl0dGVkIEFtb3VudC9DaGFyZ2VzOiAgJDUwNC44MAoKQWxsb3dlZCBBbW91bnQ6ICAkNTA0LjgwCgpOb24tQ292ZXJlZDogICQwLjAwCgpDbGFpbSBOdW1iZXI6IDEyMzQ1Njc4OTAxMjMKClByb3ZpZGVyOiBObyBJbmZvcm1hdGlvbiBBdmFpbGFibGUKClByb3ZpZGVyIEJpbGxpbmcgQWRkcmVzczogICAgCgpTZXJ2aWNlIFN0YXJ0IERhdGU6IDEyLzAxLzIwMTIKClNlcnZpY2UgRW5kIERhdGU6IAoKQW1vdW50IENoYXJnZWQ6ICogTm90IEF2YWlsYWJsZSAqCgpNZWRpY2FyZSBBcHByb3ZlZDogKiBOb3QgQXZhaWxhYmxlICoKClByb3ZpZGVyIFBhaWQ6ICogTm90IEF2YWlsYWJsZSAqCgpZb3UgTWF5IGJlIEJpbGxlZDogKiBOb3QgQXZhaWxhYmxlICoKCkNsYWltIFR5cGU6IFBhcnRCCgpEaWFnbm9zaXMgQ29kZSAxOiA3MzkyCkRpYWdub3NpcyBDb2RlIDI6IDcyNDEKRGlhZ25vc2lzIENvZGUgMzogNzM5MwpEaWFnbm9zaXMgQ29kZSA0OiA3MzkxCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpDbGFpbSBMaW5lcyBmb3IgQ2xhaW0gTnVtYmVyOiAxMjM0NTY3ODkwMTIzCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCgpMaW5lIG51bWJlcjogIDEKCkRhdGUgb2YgU2VydmljZSBGcm9tOiAgMTIvMDEvMjAxMgoKRGF0ZSBvZiBTZXJ2aWNlIFRvOiAgMTIvMDEvMjAxMgoKUHJvY2VkdXJlIENvZGUvRGVzY3JpcHRpb246ICA5ODk0MSAtIENoaXJvcHJhY3RpYyBNYW5pcHVsYXRpdmUgVHJlYXRtZW50LCAzIFRvIDQgU3BpbmFsIFJlZ2lvbnMKCk1vZGlmaWVyIDEvRGVzY3JpcHRpb246ICBHQSAtIFdhaXZlciBPZiBMaWFiaWxpdHkgU3RhdGVtZW50IElzc3VlZCBBcyBSZXF1aXJlZCBCeSBQYXllciBQb2xpY3ksIEluZGl2aWR1YWwgQ2FzZQoKTW9kaWZpZXIgMi9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgMy9EZXNjcmlwdGlvbjogIAoKTW9kaWZpZXIgNC9EZXNjcmlwdGlvbjogIAoKUXVhbnRpdHkgQmlsbGVkL1VuaXRzOiAgMQoKU3VibWl0dGVkIEFtb3VudC9DaGFyZ2VzOiAgKiBOb3QgQXZhaWxhYmxlICoKCkFsbG93ZWQgQW1vdW50OiAgKiBOb3QgQXZhaWxhYmxlICoKCk5vbi1Db3ZlcmVkOiAgKiBOb3QgQXZhaWxhYmxlICoKClBsYWNlIG9mIFNlcnZpY2UvRGVzY3JpcHRpb246ICAxMSAtIE9mZmljZQoKVHlwZSBvZiBTZXJ2aWNlL0Rlc2NyaXB0aW9uOiAgMSAtIE1lZGljYWwgQ2FyZQoKUmVuZGVyaW5nIFByb3ZpZGVyIE5vOiAgMTIzNDU2CgpSZW5kZXJpbmcgUHJvdmlkZXIgTlBJOiAgMTIzNDU2Nzg5CgoKCkxpbmUgbnVtYmVyOiAgMgoKRGF0ZSBvZiBTZXJ2aWNlIEZyb206ICAxMi8wMS8yMDEyCgpEYXRlIG9mIFNlcnZpY2UgVG86ICAxMi8wMS8yMDEyCgpQcm9jZWR1cmUgQ29kZS9EZXNjcmlwdGlvbjogIEcwMjgzIC0gRWxlY3RyaWNhbCBTdGltdWxhdGlvbiAoVW5hdHRlbmRlZCksIFRvIE9uZSBPciBNb3JlIEFyZWFzIEZvciBJbmRpY2F0aW9uKFMpIE90aGVyIFRoYW4gV291bmQKCk1vZGlmaWVyIDEvRGVzY3JpcHRpb246ICBHWSAtIEl0ZW0gT3IgU2VydmljZSBTdGF0dXRvcmlseSBFeGNsdWRlZCwgRG9lcyBOb3QgTWVldCBUaGUgRGVmaW5pdGlvbiBPZiBBbnkgTWVkaWNhcmUgQmVuZWZpdCBPciwKCk1vZGlmaWVyIDIvRGVzY3JpcHRpb246ICAKCk1vZGlmaWVyIDMvRGVzY3JpcHRpb246ICAKCk1vZGlmaWVyIDQvRGVzY3JpcHRpb246ICAKClF1YW50aXR5IEJpbGxlZC9Vbml0czogIDEKClN1Ym1pdHRlZCBBbW91bnQvQ2hhcmdlczogICogTm90IEF2YWlsYWJsZSAqCgpBbGxvd2VkIEFtb3VudDogICogTm90IEF2YWlsYWJsZSAqCgpOb24tQ292ZXJlZDogICogTm90IEF2YWlsYWJsZSAqCgpQbGFjZSBvZiBTZXJ2aWNlL0Rlc2NyaXB0aW9uOiAgMTEgLSBPZmZpY2UKClR5cGUgb2YgU2VydmljZS9EZXNjcmlwdGlvbjogIDEgLSBNZWRpY2FsIENhcmUKClJlbmRlcmluZyBQcm92aWRlciBObzogIDEyMzQ1NgoKUmVuZGVyaW5nIFByb3ZpZGVyIE5QSTogIDEyMzQ1Njc4OQoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpDbGFpbSBMaW5lcyBmb3IgQ2xhaW0gTnVtYmVyOiAxMjM0NTY3ODkwMTIKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgoKCkNsYWltIFR5cGU6IFBhcnQgRAoKQ2xhaW0gTnVtYmVyOiAxMjM0NTY3ODkwMTIKCkNsYWltIFNlcnZpY2UgRGF0ZTogMTEvMTcvMjAxMQoKUGhhcm1hY3kgLyBTZXJ2aWNlIFByb3ZpZGVyOiAxMjM0NTY3ODkKClBoYXJtYWN5IE5hbWU6IFBIQVJNQUNZMiAjMDAwMDAKCkRydWcgQ29kZTogMDAwOTMwMTM1MDUKCkRydWcgTmFtZTogQ0FSVkVESUxPTAoKRmlsbCBOdW1iZXI6IDAKCkRheXMnIFN1cHBseTogMzAKClByZXNjcmliZXIgSWRlbnRpZmVyOiAxMjM0NTY3ODkKClByZXNjcmliZXIgTmFtZTogSmFuZSBEb2UKCgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KQ2xhaW0gTGluZXMgZm9yIENsYWltIE51bWJlcjogMTIzNDU2Nzg5MDExCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCgpDbGFpbSBUeXBlOiBQYXJ0IEQKCkNsYWltIE51bWJlcjogMTIzNDU2Nzg5MDExCgpDbGFpbSBTZXJ2aWNlIERhdGU6IDExLzIzLzIwMTEKClBoYXJtYWN5IC8gU2VydmljZSBQcm92aWRlcjogMTIzNDU2Nzg5MAoKUGhhcm1hY3kgTmFtZTogUEhBUk1BQ1kzICMwMDAwMAoKRHJ1ZyBDb2RlOiAwMDc4MTIyMzMxMAoKRHJ1ZyBOYW1lOiBPTUVQUkFaT0xFCgpGaWxsIE51bWJlcjogNAoKRGF5cycgU3VwcGx5OiAzMAoKUHJlc2NyaWJlciBJZGVudGlmZXI6IDEyMzQ1Njc4OQoKUHJlc2NyaWJlciBOYW1lOiBKYW5lIERvZQoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCgo=","base64").toString();
        var result = bb.parseText(data);

        // check validation
        var val = bb.validator.validateDocumentModel(result);

        // generate ccda
        var xml = bbg.generateCCD(result);

        // parse generated ccda
        var result2 = bb.parseString(xml);

        // re-generate
        var xml2 = bbg.generateCCD(result2);

        delete result.errors;
        delete result2.errors;
        delete result.data.claims;
        delete result2.data.claims;
        delete result.data.plan_of_care;
        delete result2.data.plan_of_care;
        delete result.data.providers;
        delete result2.data.providers;

        assert.deepEqual(result2.data, result.data);
    });

    it('skewed sample data from app should still be same', function () {
        //var data = fs.readFileSync("./sample.JSON").toString();

        var data = Buffer("ewogICAgICAgICAgImFsbGVyZ2llcyI6IFsKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDQ4ZjExN2M2MDA3YzNkNDE2IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDM3OGEwNDU2MDA3NzQ5ZGI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAxLW9yaWdpbmFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjEyLjA2NFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNjkwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFlNDc4YTA0NTYwMDc3NDlkYmMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDMtY21zLnR4dCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjIzOjIwLjQ1OVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogInVwZGF0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwNi0wNS0wMVQwMDowMDowMFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMzZlM2U5MzAtN2IxNC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib2JzZXJ2YXRpb24iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICI0YWRjMTAyMC03YjE0LTExZGItOWZlMS0wODAwMjAwYzlhNjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhbGxlcmdlbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDb2RlaW5lIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIyNjcwIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJSWE5PUk0iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludG9sZXJhbmNlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlByb3BlbnNpdHkgdG8gYWR2ZXJzZSByZWFjdGlvbnMgdG8gZHJ1ZyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNDE5NTExMDAzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA2LTA1LTAxVDAwOjAwOjAwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkFjdGl2ZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNTU1NjEwMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic2V2ZXJpdHkiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk1vZGVyYXRlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNjczNjAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiTm9ybWFsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiTiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIk9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQxNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4wNjVaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjcwMFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYnNlcnZhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzZXZlcml0eSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50ZXJwcmV0YXRpb24iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIk9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiTiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk5vcm1hbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIzNzE5MjMwMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJNaWxkIHRvIG1vZGVyYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVhY3Rpb25zIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNldmVyaXR5IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludGVycHJldGF0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIk9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJTdWNlcHRpYmxlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMzcxOTIzMDAzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJNaWxkIHRvIG1vZGVyYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVhY3Rpb24iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjQ3NDcyMDA0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkhpdmVzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJzZWNvbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjdUMTM6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDgtMDUtMDFUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI1NTU2MTAwMyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQWN0aXZlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA4LTA1LTAxVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludG9sZXJhbmNlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNTkwMzcwMDciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkRydWcgaW50b2xlcmFuY2UiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFsbGVyZ2VuIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlJYTk9STSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMTE5MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQXNwaXJpbiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICI0YWRjMTAyMC03YjE0LTExZGItOWZlMS0wODAwMjAwYzlhNjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA4LTA1LTAxVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjM2ZTNlOTMwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ1MyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc1MFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYnNlcnZhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWFjdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic2V2ZXJpdHkiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50ZXJwcmV0YXRpb24iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiT2JzZXJ2YXRpb24gSW50ZXJwcmV0YXRpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIlMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlN1Y2VwdGlibGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIyNTU2MDQwMDIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk1pbGQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWFjdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI0MjI1ODcwMDciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiTmF1c2VhIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJzZWNvbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjdUMTM6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDUtMDFUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI3MzQyNTAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSW5hY3RpdmUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludG9sZXJhbmNlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNDE0Mjg1MDAxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJGb29kIGFsbGVyZ3kgKGRpc29yZGVyKSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWxsZXJnZW4iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRyYW5zbGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiT0lEIDIuMTYuODQwLjEuMTEzODgzLjYuMiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJWMTUuMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQWxsZXJneSB0byBlZ2dzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJVTklJIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIyOTFQNDVGODk2IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJFZ2dzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjRhZGMxMDIwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAic2Vjb25kIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIxOTg0LTA2LTA1VDEwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjM2ZTNlOTMwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ1NCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc1NFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvYnNlcnZhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWFjdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic2V2ZXJpdHkiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50ZXJwcmV0YXRpb24iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiT2JzZXJ2YXRpb24gSW50ZXJwcmV0YXRpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIlMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlN1Y2VwdGlibGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIyNTU2MDQwMDIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk1pbGQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWFjdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI0MjI1ODcwMDciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiTmF1c2VhIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJzZWNvbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjdUMTM6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDUtMDFUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI3MzQyNTAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSW5hY3RpdmUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludG9sZXJhbmNlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNDE2MDk4MDAyIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJEcnVnIGFsbGVyZ3kgKGRpc29yZGVyKSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWxsZXJnZW4iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiUlhOT1JNIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI4NjYwNDEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk5lb215Y2luIFN1bGZhdGUgNTAwIE1HIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjRhZGMxMDIwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAic2Vjb25kIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA5LTA4LTI2VDEwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjM2ZTNlOTMwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQxNSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4wNjRaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjcxM1oiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZTQ3OGEwNDU2MDA3NzQ5ZGJjIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAzLWNtcy50eHQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxOTowNy41MzlaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJ1cGRhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDUtMDFUMDA6MDA6MDBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjM2ZTNlOTMwLTdiMTQtMTFkYi05ZmUxLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9ic2VydmF0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiNGFkYzEwMjAtN2IxNC0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWxsZXJnZW4iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQUxMRVJHRU5JQyBFWFRSQUNULCBQRU5JQ0lMTElOIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIzMTQ0MjIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlJYTk9STSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50b2xlcmFuY2UiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUHJvcGVuc2l0eSB0byBhZHZlcnNlIHJlYWN0aW9ucyB0byBkcnVnIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI0MTk1MTEwMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDUtMDFUMDA6MDA6MDBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSW5hY3RpdmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjczNDI1MDA3IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlYWN0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWFjdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk5hdXNlYSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNldmVyaXR5IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjU1NjA0MDAyIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJNaWxkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwNy0wNS0wMVQwMDowMDowMFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJoaWdoIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjdUMTM6MDA6MDBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogInNlY29uZCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlYWN0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiTmF1c2VhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjQyMjU4NzAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzZXZlcml0eSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk1pbGQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjI1NTYwNDAwMiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJTdWNlcHRpYmxlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJPYnNlcnZhdGlvbiBJbnRlcnByZXRhdGlvbiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic2V2ZXJpdHkiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIk1vZGVyYXRlIHRvIHNldmVyZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjM3MTkyNDAwOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiTm9ybWFsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiTiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIk9ic2VydmF0aW9uIEludGVycHJldGF0aW9uIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAicHJvYmxlbXMiOiBbCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQyNSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4wOTdaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjcwNloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzb3VyY2VfbGlzdF9pZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJlYzhhNmZmOC1lZDRiLTRmN2UtODJjMy1lOThlNThiNDVkZTciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwYXRpZW50X3N0YXR1cyI6ICJBbGl2ZSBhbmQgd2VsbCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJoaWdoIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogInNlY29uZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjdUMTM6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA4LTAxLTAzVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQWN0aXZlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib25zZXRfYWdlX3VuaXQiOiAiWWVhciIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvbnNldF9hZ2UiOiAiNTciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvYmxlbSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwOC0wMS0wM1QwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDEtMDNUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjE5NTk2NzAwMSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQXN0aG1hIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmVnYXRpb25faW5kaWNhdG9yIjogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJhYjE3OTFiMC01YzcxLTExZGItYjBkZS0wODAwMjAwYzlhNjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaGlnaCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwNy0wMS0wM1QwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwNy0wMS0wM1QwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzhmMTE3YzYwMDdjM2Q0NTgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43NjZaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlX2xpc3RfaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICI2MTUwMjg4MDAwMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjEiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiNjU5OTM1MjAwMDAxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIxLjMuNi4xLjQuMS4yMjgxMi4zLjk5OTMwLjMuNC4xIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQWN0aXZlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvYmxlbSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTA5LTIwVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIzNjk3MTAwOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiU2ludXNpdGlzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmVnYXRpb25faW5kaWNhdG9yIjogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjYxNTAyODgwMDAwMyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjQuMS4yLjEiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiNjU5OTM1MjAwMDAxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIxLjMuNi4xLjQuMS4yMjgxMi4zLjk5OTMwLjMuNC4xLjIuMSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQyNCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4wOTRaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjY5NVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZTQ3OGEwNDU2MDA3NzQ5ZGJjIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAzLWNtcy50eHQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxOTozMS42NDZaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJ1cGRhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA4LTAxLTAzVDAwOjAwOjAwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwOC0wMS0wM1QwMDowMDowMFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiYWIxNzkxYjAtNWM3MS0xMWRiLWIwZGUtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmVnYXRpb25faW5kaWNhdG9yIjogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvbnNldF9hZ2UiOiAiNTciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib25zZXRfYWdlX3VuaXQiOiAiWWVhciIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwYXRpZW50X3N0YXR1cyI6ICJBbGl2ZSBhbmQgd2VsbCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9ibGVtIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUG5ldW1vbmlhIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic291cmNlX2xpc3RfaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiZWM4YTZmZjgtZWQ0Yi00ZjdlLTgyYzMtZTk4ZTU4YjQ1ZGU3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUmVzb2x2ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA4LTAxLTAzVDAwOjAwOjAwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjdUMTM6MDA6MDBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJzZWNvbmQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICJkZW1vZ3JhcGhpY3MiOiB7CiAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MTgiLAogICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDM3OGEwNDU2MDA3NzQ5ZGI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjEyLjA2NloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjcyNVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWU0NzhhMDQ1NjAwNzc0OWRiYyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAzLWNtcy50eHQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTk6MTIuODQ0WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJ1cGRhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICJhZGRyZXNzZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdHJlZXRfbGluZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjEzNTcgQW1iZXIgRHJpdmUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiQmVhdmVydG9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0ZSI6ICJPUiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiemlwIjogIjk3ODY3IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ1c2UiOiAicHJpbWFyeSBob21lIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAiYmlydGhwbGFjZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiQmVhdmVydG9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk9SIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICI5Nzg2NyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIgogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgImRvYiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMTk3NS0wNS0wMVQwMDowMDowMFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICJlbWFpbCI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiAiaXNhYmVsbGFAYW1pZGEuY29tIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ0eXBlIjogIiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgImdlbmRlciI6ICJGZW1hbGUiLAogICAgICAgICAgICAgICAgICAgICJndWFyZGlhbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWxhdGlvbiI6ICJQYXJlbnQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3NlcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdHJlZXRfbGluZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiMTM1NyBBbWJlciBEcml2ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiQmVhdmVydG9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk9SIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICI5Nzg2NyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVzZSI6ICJwcmltYXJ5IGhvbWUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYXN0IjogIkpvbmVzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpcnN0IjogIlJhbHBoIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGhvbmUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibnVtYmVyIjogIig4MTYpMjc2LTY5MDkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidHlwZSI6ICJwcmltYXJ5IGhvbWUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OTkuMiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjk5ODk5MSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuNC4xIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTExLTAwLTIzMzAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICJsYW5ndWFnZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYW5ndWFnZSI6ICJlbiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlZmVycmVkIjogdHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtb2RlIjogIkV4cHJlc3NlZCBzcG9rZW4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2ZpY2llbmN5IjogIkdvb2QiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICJtYXJpdGFsX3N0YXR1cyI6ICJNYXJyaWVkIiwKICAgICAgICAgICAgICAgICAgICAibmFtZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1pZGRsZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJJc2EiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYXN0IjogIkpvbmVzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpcnN0IjogIklzYWJlbGxhIgogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgInBob25lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibnVtYmVyIjogIig4MTYpMjc2LTY5MDkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInR5cGUiOiAicHJpbWFyeSBob21lIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAicmFjZV9ldGhuaWNpdHkiOiAiV2hpdGUiLAogICAgICAgICAgICAgICAgICAgICJyZWxpZ2lvbiI6ICJDaHJpc3RpYW4gKG5vbi1DYXRob2xpYywgbm9uLXNwZWNpZmljKSIKICAgICAgICAgIH0sCiAgICAgICAgICAicHJvY2VkdXJlcyI6IFsKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDQ4ZjExN2M2MDA3YzNkNDI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDM3OGEwNDU2MDA3NzQ5ZGI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAxLW9yaWdpbmFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjEyLjEwMVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzIwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDozNy43NjJaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvY2VkdXJlX3R5cGUiOiAiYWN0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvY2F0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWRkcmVzcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICIwMjM2OCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiTUEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiQmx1ZSBCZWxsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdHJlZXRfbGluZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjE3IERhd3MgUmQuIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG9jYXRpb25fdHlwZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiSGVhbHRoY2FyZVNlcnZpY2VMb2NhdGlvbiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjExMTgtOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkdhc3Ryb2VudGVyb2xvZ3kgQ2xpbmljIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQ29tbXVuaXR5IEdhc3Ryb2VudGVyb2xvZ3kgQ2xpbmljIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyZm9ybWVyIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvcmdhbml6YXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJDb21tdW5pdHkgSGVhbHRoIGFuZCBIb3NwaXRhbHMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwaG9uZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInR5cGUiOiAid29yayBwbGFjZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibnVtYmVyIjogIig1NTUpNTU1LTU1NS0xMjM0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWRkcmVzcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICIwMjM2OCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiTUEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiQmx1ZSBCZWxsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdHJlZXRfbGluZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjE3IERhd3MgUmQuIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTIzNCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIyLjE2Ljg0MC4xLjExMzg4My4xOSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByaW9yaXR5IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiT0lEIDIuMTYuODQwLjEuMTEzODgzLjUuNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJDUiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDYWxsYmFjayByZXN1bHRzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDExLTAyLTAzVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJDb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIxMjM0NTY3IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIxLjIuMy40LjUuNi43LjgiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9jZWR1cmUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjc0MDI1MDA1IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkNvbG9uaWMgcG9seXBlY3RvbXkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MjYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMDk5WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43MjlaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvY2VkdXJlX3R5cGUiOiAicHJvY2VkdXJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBlcmZvcm1lciI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib3JnYW5pemF0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGhvbmUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidHlwZSI6ICJ3b3JrIHBsYWNlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm51bWJlciI6ICI1NTUtNTU1LTUwMDAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZGRyZXNzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiemlwIjogIjk5MTIzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk9SIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiUG9ydGxhbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RyZWV0X2xpbmVzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjEwMDEgVmlsbGFnZSBBdmVudWUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkNvbW11bml0eSBIZWFsdGggYW5kIEhvc3BpdGFscyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTkuMTM5MyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwaG9uZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInR5cGUiOiAid29yayBwbGFjZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibnVtYmVyIjogIjU1NS01NTUtNTAwMCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ6aXAiOiAiOTkxMjMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk9SIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXR5IjogIlBvcnRsYW5kIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdHJlZXRfbGluZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjEwMDEgVmlsbGFnZSBBdmVudWUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIyOTgxODIzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OS40NTYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzcGVjaW1lbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMzA5MjI2MDA1IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJjb2xvbmljIHBvbHlwIHNhbXBsZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJjMmVlOWVlOS1hZTMxLTQ2MjgtYTkxOS1mZWMxY2JiNTg2ODMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYm9keV9zaXRlcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJPSUQgMi4xNi44NDAuMS4xMTM4ODMuMy44OC4xMi4zMjIxLjguOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiYXBwcm9wcmlhdGVfY29kZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiY29sb24iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMDUtMTJUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogIkNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJkNjhiN2UzMi03ODEwLTRmNWItOWNjMi1hY2Q1NGIwZmQ4NWQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9jZWR1cmUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNzM3NjEwMDEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQ29sb25vc2NvcHkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MjciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMTAwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43NDJaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvY2VkdXJlX3R5cGUiOiAib2JzZXJ2YXRpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG9jYXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZGRyZXNzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY291bnRyeSI6ICJVUyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiemlwIjogIjAyMzY4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0ZSI6ICJNQSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2l0eSI6ICJCbHVlIEJlbGwiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0cmVldF9saW5lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiMTcgRGF3cyBSZC4iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb2NhdGlvbl90eXBlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJIZWFsdGhjYXJlU2VydmljZUxvY2F0aW9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMTExOC05IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiR2FzdHJvZW50ZXJvbG9neSBDbGluaWMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDb21tdW5pdHkgR2FzdHJvZW50ZXJvbG9neSBDbGluaWMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJmb3JtZXIiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9yZ2FuaXphdGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkNvbW11bml0eSBIZWFsdGggYW5kIEhvc3BpdGFscyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIyLjE2Ljg0MC4xLjExMzg4My4xOS41IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBob25lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidHlwZSI6ICJ3b3JrIHBsYWNlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJudW1iZXIiOiAiKDU1NSk1NTUtNTU1LTEyMzQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZGRyZXNzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY291bnRyeSI6ICJVUyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiemlwIjogIjAyMzY4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0ZSI6ICJNQSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2l0eSI6ICJCbHVlIEJlbGwiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0cmVldF9saW5lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiMTcgRGF3cyBSZC4iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIxMjM0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjIuMTYuODQwLjEuMTEzODgzLjE5LjUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmlvcml0eSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIk9JRCAyLjE2Ljg0MC4xLjExMzg4My41LjciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiQ1IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQ2FsbGJhY2sgcmVzdWx0cyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImJvZHlfc2l0ZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI0MTY5NDkwMDgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkFiZG9tZW4gYW5kIHBlbHZpcyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAxMS0wMi0wM1QwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiAiQWJvcnRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjEyMzQ1Njc4OSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9jZWR1cmUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjc0MDI1MDA1IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkNvbG9uaWMgcG9seXBlY3RvbXkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzhmMTE3YzYwMDdjM2Q0NTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43NzFaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvY2VkdXJlX3R5cGUiOiAib2JzZXJ2YXRpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyZm9ybWVyIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwaG9uZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm51bWJlciI6ICIrMS0oNTU1KTU1NS0xMTIyIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWRkcmVzcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICI5NzAwNSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiT1IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiUG9ydGxhbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0cmVldF9saW5lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiMTAwMiBIZWFsdGhjYXJlIERyLiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaXJzdCI6ICJNYXJ0aW4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxhc3QiOiAiUm9kcmlndWV6IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVmaXgiOiAiRHIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIxMTExMTExMTExIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjIuMTYuODQwLjEuMTEzODgzLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImJvZHlfc2l0ZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI4MjA5NDAwOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiTG93ZXIgUmVzcGlyYXRvcnkgVHJhY3QgU3RydWN0dXJlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAxMi0xMC0wMlQwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiAiQWN0aXZlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTExNDQ1NTYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9jZWR1cmUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjQxNTI2MDA1IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlNpbnVzIENUIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICJlbmNvdW50ZXJzIjogWwogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMDY5WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43MzVaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmluZGluZ3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDEtMDNUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjIzMzYwNDAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlBuZXVtb25pYSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICI0NTY2NSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJkYjczNDY0Ny1mYzk5LTQyNGMtYTg2NC03ZTNjZGE4MmU3MDMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb2NhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ6aXAiOiAiMDIzNjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk1BIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXR5IjogIkJsdWUgQmVsbCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RyZWV0X2xpbmVzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIxNyBEYXdzIFJkLiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvY2F0aW9uX3R5cGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkhlYWx0aGNhcmVTZXJ2aWNlTG9jYXRpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIxMTYwLTEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJVcmdlbnQgQ2FyZSBDZW50ZXIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDb21tdW5pdHkgVXJnZW50IENhcmUgQ2VudGVyIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyZm9ybWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjU5MDU4MDAxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkdlbmVyYWwgUGh5c2ljaWFuIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIlBzZWR1b01ELTMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJzZWNvbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjdUMTM6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMmE2MjAxNTUtOWQxMS00MzllLTkyYjMtNWQ5ODE1ZmY0ZGU4IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZW5jb3VudGVyIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRyYW5zbGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkhMN0FjdENvZGUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJBTUIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJBbWJ1bGF0b3J5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJDUFQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiOTkyMTMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiT2ZmaWNlIG91dHBhdGllbnQgdmlzaXQgMTUgbWludXRlcyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ1NSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc1OVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaW5kaW5ncyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTQ3ODUyIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjEuMyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvY2F0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGhvbmUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJudW1iZXIiOiAiKzEtKDU1NSk1NTUtMTEyMiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ6aXAiOiAiOTcwMDUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk9SIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXR5IjogIlBvcnRsYW5kIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdHJlZXRfbGluZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjEwMDAgSG9zcGl0YWwgV2F5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG9jYXRpb25fdHlwZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiSGVhbHRoY2FyZVNlcnZpY2VMb2NhdGlvbiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjEwNjEtMSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIklucGF0aWVudCBNZWRpY2FsL1N1cmdpY2FsIFdhcmQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJMb2NhbCBDb21tdW5pdHkgSG9zcGl0YWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJmb3JtZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwaG9uZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm51bWJlciI6ICIrMS0oNTU1KTU1NS0xMTIyIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWRkcmVzcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICI5NzAwNSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiT1IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiUG9ydGxhbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0cmVldF9saW5lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiMTAwMiBIZWFsdGhjYXJlIERyLiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaXJzdCI6ICJNYXJ0aW4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxhc3QiOiAiUm9kcmlndWV6IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVmaXgiOiAiRHIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIxMTExMTExMTExIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjIuMTYuODQwLjEuMTEzODgzLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJoaWdoIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTEwLTA1VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTEwLTAyVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiNTI4MzgxNSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjMuNCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImVuY291bnRlciI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkNQVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI5OTIzMSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJVTksiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NThmMTE3YzYwMDdjM2Q0ZGYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDozNy43ODFaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmluZGluZ3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDEtMDNUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjIzMzYwNDAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlBuZXVtb25pYSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICI0NTY2NSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJkYjczNDY0Ny1mYzk5LTQyNGMtYTg2NC03ZTNjZGE4MmU3MDMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb2NhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ6aXAiOiAiMDIzNjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk1BIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXR5IjogIkJsdWUgQmVsbCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RyZWV0X2xpbmVzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIxNyBEYXdzIFJkLiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvY2F0aW9uX3R5cGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkhlYWx0aGNhcmVTZXJ2aWNlTG9jYXRpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIxMTYwLTEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJVcmdlbnQgQ2FyZSBDZW50ZXIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDb21tdW5pdHkgVXJnZW50IENhcmUgQ2VudGVyIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyZm9ybWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjU5MDU4MDAxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkdlbmVyYWwgUGh5c2ljaWFuIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIlBzZWR1b01ELTMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjRUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMmE2MjAxNTUtOWQxMS00MzllLTkyYjMtNWQ5ODE1ZmY0ZGU4IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZW5jb3VudGVyIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRyYW5zbGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkhMN0FjdENvZGUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJBTUIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJBbWJ1bGF0b3J5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJDUFQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiOTkyMTMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiT2ZmaWNlIG91dHBhdGllbnQgdmlzaXQgMTUgbWludXRlcyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYjY1OGYxMTdjNjAwN2MzZDRlMCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYjY1NzhhMDQ1NjAwNzc0OWRiZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wNC1wYXJ0aWFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjIwOjM3Ljc4NFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaW5kaW5ncyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwNy0wMS0wM1QwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjMzNjA0MDA3IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUG5ldW1vbmlhIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjQ1NjY1IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImRiNzM0NjQ3LWZjOTktNDI0Yy1hODY0LTdlM2NkYTgyZTcwMyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvY2F0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWRkcmVzcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICIwMjM2OCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiTUEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiQmx1ZSBCZWxsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdHJlZXRfbGluZXMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjE3IERhd3MgUmQuIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG9jYXRpb25fdHlwZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiSGVhbHRoY2FyZVNlcnZpY2VMb2NhdGlvbiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjExNjAtMSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlVyZ2VudCBDYXJlIENlbnRlciIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkNvbW11bml0eSBVcmdlbnQgQ2FyZSBDZW50ZXIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJmb3JtZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNTkwNTgwMDEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiR2VuZXJhbCBQaHlzaWNpYW4iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiUHNlZHVvTUQtMyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwNy0wMi0yN1QwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIyYTYyMDE1NS05ZDExLTQzOWUtOTJiMy01ZDk4MTVmZjRkZTgiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJlbmNvdW50ZXIiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidHJhbnNsYXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiSEw3QWN0Q29kZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIkFNQiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkFtYnVsYXRvcnkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkNQVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI5OTIxMyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJPZmZpY2Ugb3V0cGF0aWVudCB2aXNpdCAxNSBtaW51dGVzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICJyZXN1bHRzIjogWwogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzhmMTE3YzYwMDdjM2Q0NWIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43ODBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0cyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICIlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiA4LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhYm5vcm1hbCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJoaWdoIGFsZXJ0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlZmVyZW5jZV9yYW5nZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJhbmdlIjogIm5vcm1hbDogNC4wLTUuNiUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAxMi0xMS0yNlQwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZXN1bHQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNDU0OC00IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSGVtb2dsb2JpbiBBMWMvSGVtb2dsb2Jpbi50b3RhbCBpbiBCbG9vZCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiZGMxNmE2NzEtYzhmNy00MTI1LWEzZjYtYzg3ODc2MDZmNTc2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0X3NldCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjQ1NDgtNCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJIZW1vZ2xvYmluIEExYy9IZW1vZ2xvYmluLnRvdGFsIGluIEJsb29kIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiY2UxOWQyYmUtM2QzYi00NGVhLTk1ZjEtNWEwYTA0NTg2Mzc3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM4ZjExN2M2MDA3YzNkNDVlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzg4WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDozNy43NDhaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0cyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICIlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiA1NSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50ZXJwcmV0YXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibm9ybWFsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlZmVyZW5jZV9yYW5nZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJhbmdlIjogIk5vcm1hbDogNTAtNzUlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMTEtMjZUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjE4MDQxLTQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJBb3J0aWMgdmFsdmUgRWplY3Rpb24gW1RpbWVdIGJ5IFVTLmRvcHBsZXIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImFhYTAwZjllLTAxNTQtNGVhYS1iZTg1LWFlYjM0MTY5ZjA2YSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAiY20yIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxLjUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludGVycHJldGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFibm9ybWFsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlZmVyZW5jZV9yYW5nZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJhbmdlIjogIk5vcm1hbCAoMy4wLTQuMCBjbTIpLCBtaWxkICgxLjXigJMyLjAgY20yKSwgbW9kZXJhdGUgKDEuMOKAkzEuNSBjbTIpLCBzZXZlcmUgKGxlc3MgdGhhbiAxLjAgY20yKSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiAiY29tcGxldGVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTExLTI2VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTE9JTkMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIxODA4OS0zIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQVYgT3JpZmljZSBBcmVhIFVTIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIzNDdmOTU4Yy05YjZiLTRlZWItODQ4ZC02MjQ1NjcxMTdjYjciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZXN1bHRfc2V0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTE9JTkMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMzQ1NTItMCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICIyRCBlY2hvY2FyZGlvZ3JhbSBwYW5lbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImNlMTlkMmJlLTNkM2ItNDRlYS05NWYxLTVhMGEwNDU4NjM3NyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ1ZiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc5MloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFiNjU3OGEwNDU2MDA3NzQ5ZGJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTA0LXBhcnRpYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjA6MzcuNzU1WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdHMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMTEtMjZUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjE4ODQ0LTEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJFS0cgaW1wcmVzc2lvbiBOYXJyYXRpdmUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImJhNGY4NWZhLTU4NmMtNDg5OC05YWFkLWI1OTJkNGMyYzM4MyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdF9zZXQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIzNDUzNC04IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkVLRyAxMiBjaGFubmVsIHBhbmVsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiY2UxOWQyYmUtM2QzYi00NGVhLTk1ZjEtNWEwYTA0NTg2Mzc3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM4ZjExN2M2MDA3YzNkNDVhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzc3WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdHMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAibVtJVV0vTCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogNiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50ZXJwcmV0YXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWJub3JtYWwiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaGlnaCBhbGVydCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWZlcmVuY2VfcmFuZ2UiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyYW5nZSI6ICJub3JtYWw6IDAuMjnigJM1LjExIElVL21sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMTEtMjZUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjMwMTYtMyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlRoeXJvdHJvcGluIFtVbml0cy92b2x1bWVdIGluIFNlcnVtIG9yIFBsYXNtYSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMTMzMWVlYTEtM2VmZS00OTdlLTk2YmMtZGU1Njc5NmEyNTNkIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0X3NldCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjExNTc5LTAiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiVGh5cm90cm9waW4gW1VuaXRzL3ZvbHVtZV0gaW4gU2VydW0gb3IgUGxhc21hIGJ5IERldGVjdGlvbiBsaW1pdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMC4wNSBtSVUvTCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImNlMTlkMmJlLTNkM2ItNDRlYS05NWYxLTVhMGEwNDU4NjM3NyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ1YyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc4MloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFiNjU3OGEwNDU2MDA3NzQ5ZGJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTA0LXBhcnRpYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjI6NDMuNjcyWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAidXBkYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImNlMTlkMmJlLTNkM2ItNDRlYS05NWYxLTVhMGEwNDU4NjM3NyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdF9zZXQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDcmVhdGluaW5lIFtNYXNzL3ZvbHVtZV0gaW4gU2VydW0gb3IgUGxhc21hIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjIxNjAtMCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQyOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4xMDJaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjY5NloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFiNjU3OGEwNDU2MDA3NzQ5ZGJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTA0LXBhcnRpYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjA6MzcuNzY4WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdHMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAiZy9kbCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogMTMuMiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50ZXJwcmV0YXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTm9ybWFsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlZmVyZW5jZV9yYW5nZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJhbmdlIjogIk0gMTMtMTggZy9kbDsgRiAxMi0xNiBnL2RsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAibWludXRlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDAtMDMtMjNUMTQ6MzA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjMwMzEzLTEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJIR0IiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEwN2MyZGMwLTY3YTUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAiMTArMy91bCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogNi43LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJOb3JtYWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVmZXJlbmNlX3JhbmdlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICIxMCszL3VsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiAiMTAuOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiAiNC4zIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAibWludXRlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDAtMDMtMjNUMTQ6MzA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjMzNzY1LTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJXQkMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEwN2MyZGMwLTY3YTUtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAiMTArMy91bCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogMTIzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJMb3ciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVmZXJlbmNlX3JhbmdlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICIxMCszL3VsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiAiMzUwIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6ICIxNTAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJtaW51dGUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwMC0wMy0yM1QxNDozMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZXN1bHQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjY1MTUtNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlBMVCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMTA3YzJkYzAtNjdhNS0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0X3NldCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI0Mzc4OTAwOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDQkMgV08gRElGRkVSRU5USUFMIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiN2Q1YTAyYjAtNjdhNC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM4ZjExN2M2MDA3YzNkNDVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzg2WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDozNy43NzZaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVzdWx0cyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICIxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxLjUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludGVycHJldGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFibm9ybWFsIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2ggYWxlcnQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVmZXJlbmNlX3JhbmdlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmFuZ2UiOiAiTm9ybWFsIHJlZmVyZW5jZSByYW5nZSAxLjAtMS41OyBUYXJnZXRlZCBJTlIgMi4wLTMuMCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiAiY29tcGxldGVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTExLTI2VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTE9JTkMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI2MzAxLTYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJTlIgaW4gUGxhdGVsZXQgcG9vciBwbGFzbWEgYnkgQ29hZ3VsYXRpb24gYXNzYXkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjc4ZGY2MGIxLWRhZjctNDgzOC1iNTA5LWVjM2EzZjQxMTZjMSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3VsdF9zZXQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI2MzAxLTYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSU5SIGluIFBsYXRlbGV0IHBvb3IgcGxhc21hIGJ5IENvYWd1bGF0aW9uIGFzc2F5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiY2UxOWQyYmUtM2QzYi00NGVhLTk1ZjEtNWEwYTA0NTg2Mzc3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICJpbW11bml6YXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MWEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMDcwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC42OTJaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW5zdHJ1Y3Rpb25zIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZyZWVfdGV4dCI6ICJQb3NzaWJsZSBmbHUtbGlrZSBzeW1wdG9tcyBmb3IgdGhyZWUgZGF5cy4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIxNzEwNDQwMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogImltbXVuaXphdGlvbiBlZHVjYXRpb24iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJmb3JtZXIiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib3JnYW5pemF0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiR29vZCBIZWFsdGggQ2xpbmljIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY291bnRyeSI6ICJVUyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ6aXAiOiAiOTkwOTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiTUkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2l0eSI6ICJBbm4gQXJib3IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RyZWV0X2xpbmVzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjEwMjEgSGVhbHRoIERyaXZlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpcnN0IjogIkFtYW5kYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYXN0IjogIkFzc2lnbmVkIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjI5ODE4MjQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTkuNDU2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkbWluaXN0cmF0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRvc2UiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAibWNnIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiA1MAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyb3V0ZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJNZWRpY2F0aW9uIFJvdXRlIEZEQSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiQzI4MTYxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJbnRyYW11c2N1bGFyIGluamVjdGlvbiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWFudWZhY3R1cmVyIjogIkhlYWx0aCBMUyAtIEltbXVubyBJbmMuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3RfbnVtYmVyIjogIjEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRyYW5zbGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiQ1ZYIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjE0MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJbmZsdWVuemEsIHNlYXNvbmFsLCBpbmplY3RhYmxlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJDVlgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjg4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJbmZsdWVuemEgdmlydXMgdmFjY2luZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJlNmYxYmE0My1jMGVkLTRiOWItOWYxMi1mNDM1ZDhhZDhmOTIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJtb250aCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMTk5OS0xMS0wMVQwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MWIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMDcyWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43MDJaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW5zdHJ1Y3Rpb25zIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZyZWVfdGV4dCI6ICJQb3NzaWJsZSBmbHUtbGlrZSBzeW1wdG9tcyBmb3IgdGhyZWUgZGF5cy4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIxNzEwNDQwMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogImltbXVuaXphdGlvbiBlZHVjYXRpb24iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJmb3JtZXIiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib3JnYW5pemF0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiR29vZCBIZWFsdGggQ2xpbmljIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY291bnRyeSI6ICJVUyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ6aXAiOiAiOTkwOTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiTUkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2l0eSI6ICJBbm4gQXJib3IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RyZWV0X2xpbmVzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjEwMjEgSGVhbHRoIERyaXZlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpcnN0IjogIkFtYW5kYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYXN0IjogIkFzc2lnbmVkIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjI5ODE4MjQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTkuNDU2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkbWluaXN0cmF0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRvc2UiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAibWNnIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiA1MAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyb3V0ZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJNZWRpY2F0aW9uIFJvdXRlIEZEQSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiQzI4MTYxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJbnRyYW11c2N1bGFyIGluamVjdGlvbiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWFudWZhY3R1cmVyIjogIkhlYWx0aCBMUyAtIEltbXVubyBJbmMuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3RfbnVtYmVyIjogIjEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRyYW5zbGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiQ1ZYIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjE0MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJbmZsdWVuemEsIHNlYXNvbmFsLCBpbmplY3RhYmxlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJDVlgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjg4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJbmZsdWVuemEgdmlydXMgdmFjY2luZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJyZWZ1c2VkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImU2ZjFiYTQzLWMwZWQtNGI5Yi05ZjEyLWY0MzVkOGFkOGY5MiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMTk5OC0xMi0xNVQwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MWMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMDczWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43MTdaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYjY1NzhhMDQ1NjAwNzc0OWRiZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wNC1wYXJ0aWFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjIwOjM3Ljc0NloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJmb3JtZXIiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib3JnYW5pemF0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiR29vZCBIZWFsdGggQ2xpbmljIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkZHJlc3MiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY291bnRyeSI6ICJVUyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ6aXAiOiAiOTkwOTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiTUkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2l0eSI6ICJBbm4gQXJib3IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RyZWV0X2xpbmVzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjEwMjEgSGVhbHRoIERyaXZlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpcnN0IjogIkFtYW5kYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYXN0IjogIkFzc2lnbmVkIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjI5ODE4MjQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIyLjE2Ljg0MC4xLjExMzg4My4xOS41Ljk5OTkuNDU2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkbWluaXN0cmF0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRvc2UiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAibWNnIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiA1MAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyb3V0ZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJNZWRpY2F0aW9uIFJvdXRlIEZEQSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiQzI4MTYxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJJbnRyYW11c2N1bGFyIGluamVjdGlvbiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWFudWZhY3R1cmVyIjogIkhlYWx0aCBMUyAtIEltbXVubyBJbmMuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3RfbnVtYmVyIjogIjEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInRyYW5zbGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiQ1ZYIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjEwOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJQbmV1bW9jb2NjYWwgTk9TIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJDVlgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjMzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJQbmV1bW9jb2NjYWwgcG9seXNhY2NoYXJpZGUgdmFjY2luZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJlNmYxYmE0My1jMGVkLTRiOWItOWYxMi1mNDM1ZDhhZDhmOTIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjE5OTgtMTItMTVUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDQ4ZjExN2M2MDA3YzNkNDFkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDM3OGEwNDU2MDA3NzQ5ZGI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAxLW9yaWdpbmFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjEyLjA3NloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzI2WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDozNy43NTFaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVmdXNhbF9yZWFzb24iOiAiUGF0aWVudCBvYmplY3Rpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyZm9ybWVyIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm9yZ2FuaXphdGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkdvb2QgSGVhbHRoIENsaW5pYyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjIuMTYuODQwLjEuMTEzODgzLjE5LjUuOTk5OS4xMzk0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZGRyZXNzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiemlwIjogIjk5MDk5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXRlIjogIk1JIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiQW5uIEFyYm9yIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0cmVldF9saW5lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIxMDIxIEhlYWx0aCBEcml2ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaXJzdCI6ICJBbWFuZGEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibGFzdCI6ICJBc3NpZ25lZCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIyOTgxODI0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjQ1NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZG1pbmlzdHJhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkb3NlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ1bml0IjogIm1jZyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogNTAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicm91dGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTWVkaWNhdGlvbiBSb3V0ZSBGREEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIkMyODE2MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSW50cmFtdXNjdWxhciBpbmplY3Rpb24iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9kdWN0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1hbnVmYWN0dXJlciI6ICJIZWFsdGggTFMgLSBJbW11bm8gSW5jLiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG90X251bWJlciI6ICIxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9kdWN0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ0cmFuc2xhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkNWWCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIwOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJUZXRhbnVzIGFuZCBkaXBodGhlcmlhIHRveG9pZHMgLSBwcmVzZXJ2YXRpdmUgZnJlZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiQ1ZYIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIxMDMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlRldGFudXMgYW5kIGRpcGh0aGVyaWEgdG94b2lkcyAtIHByZXNlcnZhdGl2ZSBmcmVlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogInJlZnVzZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiZTZmMWJhNDMtYzBlZC00YjliLTlmMTItZjQzNWQ4YWQ4ZjkyIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIxOTk4LTEyLTE1VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYjY1OGYxMTdjNjAwN2MzZDRlMSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYjY1NzhhMDQ1NjAwNzc0OWRiZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wNC1wYXJ0aWFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjIwOjM3Ljc5MFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnN0cnVjdGlvbnMiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiNDg3NjctOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQW5ub3RhdGlvbiBDb21tZW50IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyZm9ybWVyIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBob25lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm51bWJlciI6ICIrMS0oNTU1KTU1NS0xMDAyIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWRkcmVzcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb3VudHJ5IjogIlVTIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICI5NzAwNSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0ZSI6ICJPUiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXR5IjogIlBvcnRsYW5kIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0cmVldF9saW5lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIxMDAyIEhlYWx0aGNhcmUgRHIuIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpcnN0IjogIkhlbnJ5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxhc3QiOiAiU2V2ZW4iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTU2OTg3NDU2MiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjIuMTYuODQwLjEuMTEzODgzLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZG1pbmlzdHJhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkb3NlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ1bml0IjogIm1sIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAwLjUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicm91dGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTWVkaWNhdGlvbiBSb3V0ZSBGREEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIkMyODE2MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSU5UUkFNVVNDVUxBUiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWFudWZhY3R1cmVyIjogIk1lcmNrIGFuZCBDby4sIEluYy4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdF9udW1iZXIiOiAiTUs0NTY5ODciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiQ1ZYIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIzMyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUG5ldW1vY29jY2FsICgyIHllYXJzIGFuZCB1cCkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiAicmVmdXNlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjEwNDkyODAiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjQuMTExLjAuNC40IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTA4LTA2VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgIF0sCiAgICAgICAgICAic29jaWFsX2hpc3RvcnkiOiBbCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQyZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4xMTBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc0M1oiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6ICJOb25lIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMTYwNTczMDAzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkFsY29ob2wgY29uc3VtcHRpb24iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIzN2Y3NmM1MS02NDExLTRlMWQtOGEzNy05NTdmZDQ5ZDJjZWYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA1LTA1LTAxVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQyYiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4xMDVaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjcwN1oiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6ICIxIHBhY2sgcGVyIGRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiU05PTUVEIENUIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjIyOTgxOTAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJUb2JhY2NvIHVzZSBhbmQgZXhwb3N1cmUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICI5YjU2YzI1ZC05MTA0LTQ1ZWUtOWZhNC1lMGYzYWZhYTAxYzEiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaGlnaCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogInNlY29uZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwOS0wMi0yN1QxMzowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAwNS0wNS0wMVQwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MmMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMTA2WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43MjFaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYjY1NzhhMDQ1NjAwNzc0OWRiZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wNC1wYXJ0aWFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjIxOjE2LjQ1NloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogInVwZGF0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiVG9iYWNjbyB1c2UgYW5kIGV4cG9zdXJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjIyOTgxOTAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDktMDItMjNUMTM6MDA6MDBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogInNlY29uZCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjQ1ZWZiNjA0LTcwNDktNGEyZS1hZDMzLWQzODU1NmM5NjM2YyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogIk5vbmUiCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDQ4ZjExN2M2MDA3YzNkNDJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDM3OGEwNDU2MDA3NzQ5ZGI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAxLW9yaWdpbmFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjEyLjEwM1oiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzMxWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDo1Ni45NTBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJ1cGRhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlNtb2tpbmcgU3RhdHVzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA1LTA1LTAxVDAwOjAwOjAwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAxMi0wMi0yN1QxMzowMDowMFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAic2Vjb25kIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTIzNDU2Nzg5IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAiRm9ybWVyIHNtb2tlciIKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICBdLAogICAgICAgICAgIm1lZGljYXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MWUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMDc5WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43MzdaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGlzcGVuc2UiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyZm9ybWVyIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvcmdhbml6YXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJDb21tdW5pdHkgSGVhbHRoIGFuZCBIb3NwaXRhbHMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYWRkcmVzcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvdW50cnkiOiAiVVMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInppcCI6ICI5OTEyMyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdGUiOiAiT1IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNpdHkiOiAiUG9ydGxhbmQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0cmVldF9saW5lcyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiMTAwMSBWaWxsYWdlIEF2ZW51ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjI5ODE4MjMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjQ1NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogImNiNzM0NjQ3LWZjOTktNDI0Yy1hODY0LTdlM2NkYTgyZTcwNCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMi4zLjQuNTY3ODkuMSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbmRpY2F0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlNOT01FRCBDVCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMjMzNjA0MDA3IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJQbmV1bW9uaWEiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDEtMDNUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjQwNDY4NDAwMyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiRmluZGluZyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjQ1NjY1IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiZGI3MzQ2NDctZmM5OS00MjRjLWE4NjQtN2UzY2RhODJlNzAzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNvbmRpdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJTTk9NRUQgQ1QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjU2MDE4MDA0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJXaGVlemluZyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJITDdBY3RDb2RlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJBU1NFUlRJT04iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkcnVnX3ZlaGljbGUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJSWE5PUk0iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMzI0MDQ5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkFlcm9zb2wiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJmb3JtZXIiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAib3JnYW5pemF0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiQ29tbXVuaXR5IEhlYWx0aCBhbmQgSG9zcGl0YWxzIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMi4xNi44NDAuMS4xMTM4ODMuMTkuNS45OTk5LjEzOTMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZG1pbmlzdHJhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnZhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZnJlcXVlbmN5IjogdHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyaW9kIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICJoIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogNgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmF0ZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICJtbC9taW4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6IDkwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRvc2UiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAibWcvYWN0dWF0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZvcm0iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTWVkaWNhdGlvbiBSb3V0ZSBGREEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIkM0Mjk0NCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSU5IQUxBTlQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJvdXRlIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIk1lZGljYXRpb24gUm91dGUgRkRBIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICJDMzgyMTYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlJFU1BJUkFUT1JZIChJTkhBTEFUSU9OKSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN1cHBseSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdXRob3IiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaXJzdCI6ICJIZW5yeSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsYXN0IjogIlNldmVuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWZpeCI6ICJEci4iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjJhNjIwMTU1LTlkMTEtNDM5ZS05MmIzLTVkOTgxNWZlNGRlOCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicXVhbnRpdHkiOiAiNzUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlcGVhdE51bWJlciI6ICIxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvdyI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDA3LTAxLTAzVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9kdWN0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1hbnVmYWN0dXJlciI6ICJNZWRpY2F0aW9uIEZhY3RvcnkgSW5jLiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvZHVjdCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJSWE5PUk0iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ0cmFuc2xhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlJYTk9STSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI1NzM2MjEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUHJvdmVudGlsIDAuMDkgTUcvQUNUVUFUIGluaGFsYW50IHNvbHV0aW9uIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIyMTk0ODMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIlByb3ZlbnRpbCBIRkEiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuZW5jb2RlZF9uYW1lIjogIlByb3ZlbnRpbCBIRkEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMmE2MjAxNTUtOWQxMS00MzllLTkyYjMtNWQ5ODE1ZmY0ZWU4IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNpZyI6ICJQcm92ZW50aWwgSEZBIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJDb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiY2RiZDMzZjAtNmNkZS0xMWRiLTlmZTEtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImhpZ2giOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMDUtMTVUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDctMDEtMDNUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM4ZjExN2M2MDA3YzNkNDU2IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzYyWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFkbWluaXN0cmF0aW9uIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludGVydmFsIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmcmVxdWVuY3kiOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyaW9kIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICJoIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogMTIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZvcm0iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTWVkaWNhdGlvbiBSb3V0ZSBGREEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIkM0Mjk4NiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiU09MVVRJT04iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9kdWN0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiUlhOT1JNIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIzMjk2NDYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkNlZmVwaW1lIDIwIE1HL01MIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogIlByZXNjcmliZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICI2NTkxMjI1MDAwMDUxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIxLjMuNi4xLjQuMS4yMjgxMi4zLjk5OTMwLjMuNC45IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjY1OTEyMjUwMDAwNzEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibG93IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTEwLTAyVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ1NyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc2MloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhZG1pbmlzdHJhdGlvbiI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnZhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZnJlcXVlbmN5IjogdHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGVyaW9kIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICJoIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogNgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZG9zZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZvcm0iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTWVkaWNhdGlvbiBSb3V0ZSBGREEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIkM0Mjk5OCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiVEFCTEVUIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvZHVjdCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9kdWN0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIlJYTk9STSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiMzA5MTE0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJDZXBoYWxleGluIDUwMCBNRyBPcmFsIFRhYmxldCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJQcmVzY3JpYmVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiNjU5MTIyNTAwMDA1IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIxLjMuNi4xLjQuMS4yMjgxMi4zLjk5OTMwLjMuNC45IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjY1OTEyMjUwMDAwNyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjQuOSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJsb3ciOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMDktMjBUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZTQ4ZjExN2M2MDA3YzNkNDljIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZTQ3OGEwNDU2MDA3NzQ5ZGJjIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAzLWNtcy50eHQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyOC4zMjdaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogIkNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzaWciOiAiQXNwaXJpbiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9kdWN0IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuZW5jb2RlZF9uYW1lIjogIkFzcGlyaW4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQXNwaXJpbiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWU0OGYxMTdjNjAwN2MzZDQ5YiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWU0NzhhMDQ1NjAwNzc0OWRiYyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMy1jbXMudHh0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjguMzI2WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJDb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic2lnIjogIlByb3ZlbnRpbCBIRkEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvZHVjdCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ1bmVuY29kZWRfbmFtZSI6ICJQcm92ZW50aWwiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByb2R1Y3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUHJvdmVudGlsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgXSwKICAgICAgICAgICJ2aXRhbHMiOiBbCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ2MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc5NVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ1bml0IjogIltsYl9hdl0iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxNjAsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMTAtMDJUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2aXRhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjMxNDEtOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJXZWlnaHQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjExNjY2MDIxOTAwMDI5MTgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTE2NjYwMjE5MDAwMzUxOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ2MiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc5NloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ1bml0IjogIm1tW0hnXSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6IDEyMCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJlY2lzaW9uIjogImRheSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGUiOiAiMjAxMi0xMC0wMlQwMDowMDowMFoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiAiY29tcGxldGVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZpdGFsIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTE9JTkMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiODQ4MC02IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkJQIFN5c3RvbGljIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIxMTY2NjAyMTkwMDAyOTE4MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICIxMTY2NjAyMTkwMDAzNTE4MSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ2MyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc5N1oiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFiNjU3OGEwNDU2MDA3NzQ5ZGJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTA0LXBhcnRpYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjA6MzcuNzY0WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAibW1bSGddIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogNzgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMTAtMDJUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2aXRhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjg0NjItNCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJCUCBEaWFzdG9saWMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjExNjY2MDIxOTAwMDI5MjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTE2NjYwMjE5MDAwMzUyOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjOGYxMTdjNjAwN2MzZDQ2NCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjc5OFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFiNjU3OGEwNDU2MDA3NzQ5ZGJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTA0LXBhcnRpYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjA6MzcuNzY5WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAiMSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6IDI3LjUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMTItMTAtMDJUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2aXRhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjM5MTU2LTUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiQm9keSBNYXNzIEluZGV4IENhbGN1bGF0ZWQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjExNjY2MDIxOTAwMDI5MzkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJleHRlbnNpb24iOiAiMTE2NjYwMjE5MDAwMzUzOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiMS4zLjYuMS40LjEuMjI4MTIuMy45OTkzMC4zLjQuNiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQyZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4xMTRaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjY5OFoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFiNjU3OGEwNDU2MDA3NzQ5ZGJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTA0LXBhcnRpYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjA6MzcuNzc4WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAiY20iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxNzcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTm9ybWFsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIxOTk5LTExLTE0VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidml0YWwiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI4MzAyLTIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSGVpZ2h0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiYzZmODgzMjEtNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDQ4ZjExN2M2MDA3YzNkNDMzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDM3OGEwNDU2MDA3NzQ5ZGI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAxLW9yaWdpbmFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjEyLjEyMVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNjk4WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDozNy43NTBaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICJtbVtIZ10iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxNDUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTm9ybWFsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDAwLTA0LTA3VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidml0YWwiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI4NDgwLTYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSW50cmF2YXNjdWxhciBTeXN0b2xpYyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXJzIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogImM2Zjg4MzIxLTY3YWQtMTFkYi1iZDEzLTA4MDAyMDBjOWE2NiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQ0OGYxMTdjNjAwN2MzZDQyZiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXRhZGF0YSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJhdHRyaWJ1dGlvbiI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWQzNzhhMDQ1NjAwNzc0OWRiOCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMS1vcmlnaW5hbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoxMi4xMTdaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJuZXciCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWRjNzhhMDQ1NjAwNzc0OWRiYSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMi11cGRhdGVkLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjIwLjcxMVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFiNjU3OGEwNDU2MDA3NzQ5ZGJlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTA0LXBhcnRpYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjA6MzcuNzU3WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAia2ciLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiA4NiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludGVycHJldGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJOb3JtYWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjE5OTktMTEtMTRUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2aXRhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjMxNDEtOSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJQYXRpZW50IEJvZHkgV2VpZ2h0IC0gTWVhc3VyZWQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJjNmY4ODMyMS02N2FkLTExZGItYmQxMy0wODAwMjAwYzlhNjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MzAiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMTE4WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43MjNaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYWU0NzhhMDQ1NjAwNzc0OWRiYyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wMy1jbXMudHh0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MjA6MjEuNjkyWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAidXBkYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImRhdGVfdGltZSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwb2ludCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIxOTk5LTExLTE0VDE1OjAwOjAwWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJob3VyIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiYzZmODgzMjEtNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW50ZXJwcmV0YXRpb25zIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIk5vcm1hbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICJtbVtIZ10iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidmFsdWUiOiAxMzIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2aXRhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJuYW1lIjogIkludHJhdmFzY3VsYXIgU3lzdG9saWMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiODQ4MC02IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDQ4ZjExN2M2MDA3YzNkNDMxIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZDM3OGEwNDU2MDA3NzQ5ZGI4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAxLW9yaWdpbmFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjEyLjExOVoiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzMzWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAiZHVwbGljYXRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWI2NTc4YTA0NTYwMDc3NDlkYmUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDQtcGFydGlhbC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToyMDozNy43NjZaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidW5pdCI6ICJjbSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6IDE3NywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImludGVycHJldGF0aW9ucyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJOb3JtYWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJkYXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlIjogIjIwMDAtMDQtMDdUMDA6MDA6MDBaIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic3RhdHVzIjogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2aXRhbCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlX3N5c3RlbV9uYW1lIjogIkxPSU5DIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjb2RlIjogIjgzMDItMiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibmFtZSI6ICJIZWlnaHQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICJjNmY4ODMyMS02N2FkLTExZGItYmQxMy0wODAwMjAwYzlhNjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkNDhmMTE3YzYwMDdjM2Q0MzIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkMzc4YTA0NTYwMDc3NDlkYjgiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDEtb3JpZ2luYWwueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MTIuMTIxWiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFkYzc4YTA0NTYwMDc3NDlkYmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDItdXBkYXRlZC54bWwiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZWQiOiAiMjAxNC0wOS0wMlQwMToxODoyMC43NDhaIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlX3JlYXNvbiI6ICJkdXBsaWNhdGUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWNvcmQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX2lkIjogIjU0MDUxYjY1NzhhMDQ1NjAwNzc0OWRiZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZmlsZW5hbWUiOiAiYmx1ZWJ1dHRvbi0wNC1wYXJ0aWFsLnhtbCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjIwOjM3Ljc3M1oiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogImR1cGxpY2F0ZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ1bml0IjogImtnIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogODgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnRlcnByZXRhdGlvbnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTm9ybWFsIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDAwLTA0LTA3VDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidml0YWwiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICIzMTQxLTkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiUGF0aWVudCBCb2R5IFdlaWdodCAtIE1lYXN1cmVkIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImlkZW50aWZpZXIiOiAiYzZmODgzMjEtNjdhZC0xMWRiLWJkMTMtMDgwMDIwMGM5YTY2IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM4ZjExN2M2MDA3YzNkNDYwIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1ldGFkYXRhIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImF0dHJpYnV0aW9uIjogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlY29yZCI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJfaWQiOiAiNTQwNTFhZGM3OGEwNDU2MDA3NzQ5ZGJhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJmaWxlbmFtZSI6ICJibHVlYnV0dG9uLTAyLXVwZGF0ZWQueG1sIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VkIjogIjIwMTQtMDktMDJUMDE6MTg6MjAuNzk0WiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtZXJnZV9yZWFzb24iOiAibmV3IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAiW2luX3VzXSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ2YWx1ZSI6IDY0LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZV90aW1lIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInBvaW50IjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwcmVjaXNpb24iOiAiZGF5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIyMDEyLTEwLTAyVDAwOjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInN0YXR1cyI6ICJjb21wbGV0ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAidml0YWwiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZV9zeXN0ZW1fbmFtZSI6ICJMT0lOQyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29kZSI6ICI4MzAyLTIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSGVpZ2h0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllcnMiOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImV4dGVuc2lvbiI6ICI2NjYwMjE5MDAwMjk2IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaWRlbnRpZmllciI6ICIxLjMuNi4xLjQuMS4yMjgxMi4zLjk5OTMwLjMuNC42IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZXh0ZW5zaW9uIjogIjY2NjAyMTkwMDAzNTYiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpZGVudGlmaWVyIjogIjEuMy42LjEuNC4xLjIyODEyLjMuOTk5MzAuMy40LjYiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFlNDhmMTE3YzYwMDdjM2Q0YTQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWV0YWRhdGEiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiYXR0cmlidXRpb24iOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb3JkIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIl9pZCI6ICI1NDA1MWFlNDc4YTA0NTYwMDc3NDlkYmMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImZpbGVuYW1lIjogImJsdWVidXR0b24tMDMtY21zLnR4dCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1lcmdlZCI6ICIyMDE0LTA5LTAyVDAxOjE4OjI4LjMzNloiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWVyZ2VfcmVhc29uIjogIm5ldyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzdGF0dXMiOiAiY29tcGxldGVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInVuaXQiOiAibW1bSGddIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZhbHVlIjogODAsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJkYXRlX3RpbWUiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAicG9pbnQiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInByZWNpc2lvbiI6ICJob3VyIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZGF0ZSI6ICIxOTk5LTExLTE0VDE1OjAwOjAwWiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInZpdGFsIjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGVfc3lzdGVtX25hbWUiOiAiTE9JTkMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm5hbWUiOiAiSW50cmF2YXNjdWxhciBEaWFzdG9saWMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImNvZGUiOiAiODQ2Mi00IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgXQp9","base64");

        //convert string into JSON 
        var result = JSON.parse(data);

        // check validation
        var val = bb.validator.validateDocumentModel(result);

        // generate ccda

        delete result.errors;
        var input = {
            data: result
        };
        var xml = bbg.generateCCD(input);

        // parse generated ccda
        var result2 = bb.parseString(xml);

        // re-generate
        var xml2 = bbg.generateCCD(result2);

        delete result2.errors;
        //assert.deepEqual(result2.data, result);
    });
});

}).call(this,require("buffer").Buffer,"/test/sample_runs")
},{"../../index":2,"blue-button":"blue-button","buffer":74,"chai":42,"path":78}]},{},[83]);
